
var params = process.argv.slice(2);

function getParam(x, defaultValue) {
  var param = params.find(elem => elem.startsWith(x));
  if(typeof param !== "undefined") {
    var returnValue = param.substring(x.length + 1);
    if(returnValue == "") return defaultValue;
    return returnValue;
  } else {
    return defaultValue;
  }
}

function existsParam(x) {
  var param = params.find(elem => elem == x);
  return typeof param !== "undefined";
}

function isBoolParamTrue(x) {
  return existsParam(x) || getParam(x, "false") == true;
}

function getNonParam() {
  return params.find(elem => !elem.startsWith("-"))
}

const fs = require("fs");
const fspath = require('path');
const https = require('https');
//const http = require('http');
const url = require('url');
const hostname = getParam("hostname", 'localhost');
var port = parseInt(getParam("port", "3000"));

// The default client id is suitable only for localhost:3000
var googleClientId = getParam("google-client-id", "844835838734-2iphm3ff20ephn906md1ru8vbkpu4mg8.apps.googleusercontent.com");

const getPort = require('get-port');

const serverFile = "./server.elm";
const htaccessFile = "./htaccess.elm";
var path =  getParam("--path",    "");
var question = getParam("--question", "true") == "true";
var autosave = getParam("--autosave", "false") == "true";

var fileToOpen = getNonParam();
if(fileToOpen) {
  if(fileToOpen.indexOf("/") == -1 && fileToOpen.indexOf("\\") == -1) {
    path = "";
  } else {
    path = fileToOpen.replace(/[\/\\][^\/\\]*$/g, "");
  }
  fileToOpen = fileToOpen.replace(/.*[\/\\](?=[^\/\\]*$)/g, "");
  question = false; // When opening a file, by default we should not ask questions.
  autosave = false; // When opening a file, by default we want to let the user save it.
}
var timeBeforeExit = 2000; // Number of ms after receiving the closing signal (if file open) to kill the server.


leo = {};
leo.data = function(name) {
  return function() {
    let args = {};
    for(let i = 1; i <= arguments.length; i++) {
      args["_" + i] = arguments[i - 1];
    }
    return {"$d_ctor": name, args: args};
  }
}
leo.Just = leo.data("Just")
leo.Nothing = leo.data("Nothing")()
leo.Tuple2 = function(a, b) {
  return {"$t_ctor": "Tuple2", _1: a, _2: b}
}

var defaultOptions = {
  edit:     getParam("--edit",     "true") == "true",
  autosave: autosave,
  question: question,
  admin:    isBoolParamTrue("--admin"),
  production:    isBoolParamTrue("--production"),
  path:     path,
  closeable: !(!(fileToOpen)),
  openbrowser: isBoolParamTrue("--openbrowser"),
  key: "localhost-key.pem",
  cert: "localhost.pem",
  hyde: getParam("--hyde", "true") == "true"
};

async function start() {

// Don't modify, this will be replaced by the content of 'server.elm'
const defaultServerContent = "-- input: path            The file to serve.\n-- input: vars:           URL query vars.\n-- input: urlParams:      The URL params plainly\n-- input: defaultOptions  default options (options that vars can override for certain parts).\n--                        If nodefs is set, will use it instead of nodejs.nodeFS\n--                        If browserSide is set, will use a different kind of request. \n-- input: fileOperations  The current set of delayed file disk operations.\n--    Note that Elm pages are given in context the path, the vars, and the file system (fs) to read other files\n-- output: The page, either (almost) uninstrumented or augmented with the toolbar and edit scripts.\n\n{--------------------------------------------------------\n    Permission handling, file system, options processing\n---------------------------------------------------------}\nlistGetOrElse key listDict default = listDict.get key listDict |> Maybe.withDefault default\n\n{--\nupdatecheckpoint name x = {\n  apply x = x\n  update {input, outputNew, diffs} =\n    let _ = Debug.log \"\"\"Checkpoint @name\"\"\" () in  \n    Ok (InputsWithDiffs [(outputNew, Just diffs)])\n}.apply x\n--}\n\npreludeEnv = let _ = googlesigninbutton in -- Forces googlesigninbutton to be evaluated before preludeEnv\n  __CurrentEnv__\n\nmbApplyPrefix = case listDict.get \"path\" defaultOptions of\n  Just \"\" -> Nothing\n  Nothing -> Nothing\n  Just prefix -> Just (\\name -> if name == \"\" then prefix\n      else if Regex.matchIn \"/$\" prefix then prefix + name\n      else prefix + \"/\" + name)\n\ndirectReadFileSystem =\n  listDict.get \"nodefs\" defaultOptions |> Maybe.withDefault nodejs.nodeFS\n\nfs = nodejs.delayedFS directReadFileSystem fileOperations\n\nhydefilecache = listDict.get \"hydefilecache\" defaultOptions\n\nfs = case mbApplyPrefix of\n  Nothing -> fs\n  Just applyPrefix -> { fs |\n    read name = fs.read (applyPrefix name)\n    listdir name = fs.listdir (applyPrefix name)\n    listdircontent name = fs.listdircontent (applyPrefix name)\n    isdir name = fs.isdir (applyPrefix name)\n    isfile name = fs.isfile (applyPrefix name)\n  }\n\neditdelay = 1000\n\nboolVar name resDefault =\n  listDict.get name vars |>\n  Maybe.map (\\original ->\n    Update.bijection\n      (case of \"true\" -> True; \"\" -> True; _ -> False)\n      (case of True -> if original == \"true\" || original == \"\" then original else \"true\"; _ -> \"false\") original) |>\n  Maybe.withDefaultReplace (\n    listDict.get name defaultOptions |> Maybe.withDefault resDefault |> freeze)\n\nbrowserSide = listDict.get \"browserSide\" defaultOptions == Just True\n\nvaradmin = boolVar \"admin\" False\nvaredit = boolVar \"edit\" False\nvarls = boolVar \"ls\" False\nvarraw = boolVar \"raw\" False\ndefaultVarEdit = listDict.get \"edit\" defaultOptions |> Maybe.withDefault False\nvarproduction = listDict.get \"production\" defaultOptions |> Maybe.withDefault (freeze False)\niscloseable = listDict.get \"closeable\" defaultOptions |> Maybe.withDefault (freeze False)\n\nuserpermissions = {pageowner= True, admin= varadmin}\npermissionToCreate = userpermissions.admin\npermissionToEditServer = boolVar \"superadmin\" False -- should be possibly get from user authentication\n-- List.contains (\"sub\", \"102014571179481340426\") user -- That's my Google user ID.\n\ncanEditPage = userpermissions.pageowner && varedit && not varls\n\n{freezeWhen} = Update\n\nserverOwned what obj = freezeWhen (not permissionToEditServer) (\\od -> \"\"\"You tried to modify @what, which is part of the server. We prevented you from doing so.<br><br>\n\nIf you really intended to modify this, add ?superadmin=true to the URL and redo this operation. This is likely going to create or modify the existing <code>server.elm</code> at the location where you launched Editor.<br><br>\n\nFor debugging purposes, below is the new value that was pushed:\n<pre>@(Regex.replace \"<\" (always \"&lt;\") \"\"\"@od\"\"\")</pre>\nHere is the old value that was computed\n<pre>@(Regex.replace \"<\" (always \"&lt;\") \"\"\"@obj\"\"\")</pre>\n\"\"\") obj\n\ncanEvaluate = listDict.get \"evaluate\" vars |> Maybe.withDefaultReplace (serverOwned \"default value of evaluate\" \"true\")\n\n{--------------------------------------------------------\n Rewrite path to either a folder or a default file under\n---------------------------------------------------------}\n\npath: String\npath =\n  if fs.isdir path then\n   if not varls then\n     List.mapFirstSuccess (\\test ->\n       if fs.isfile <| path + test then Just (path + test) else Nothing)\n       [\"index.elm\" , \"/index.elm\", \"index.html\", \"/index.html\", \"README.md\" , \"/README.md\" ]\n     |> Maybe.withDefault path\n   else path\n  else path\n\n{---------------------------------------------------------------------------\n Retrieves the string content of the path. For folders, creates a custom page\n----------------------------------------------------------------------------}\n\napplyDotEditor source = \n  let prefix = Regex.extract \"^(.*/)[^/]*$\" path |> Maybe.map (\\[prefix] -> prefix) |> Maybe.withDefault \"\" in\n  let dotEditor = prefix +  \".editor\" in\n  case fs.read dotEditor of\n    Nothing -> source\n    Just modifier ->\n      case __evaluate__ ((\"vars\", vars)::(\"path\", path)::(\"fs\", fs)::(\"content\", source)::preludeEnv) modifier of\n        Err msg -> let _ = Debug.log (\"Error while executing \" + dotEditor + \" : \" + msg) () in\n          source\n        Ok newSource -> newSource\n\nisTextFile path =\n  Regex.matchIn \"\"\"\\.(?:txt|css|js|sass|scss)$\"\"\" path\n\n(sourcecontent, folderView): (String, Boolean)\n(sourcecontent, folderView) = --updatecheckpoint \"sourcecontent\" <|\n  Tuple.mapFirst String.newlines.toUnix <| --updatecheckpoint \"newlines restored\" <|\n  if path == \"server.elm\" then\n    (\"\"\"<html><head></head><body>The Elm server cannot display itself. This is a placeholder</body></html>\"\"\", False)\n  else\n    if fs.isdir path then\n      (\"\", True)\n    else\n      flip (,) False <|\n      if fs.isfile path && Regex.matchIn \"\"\"\\.(png|jpg|ico|gif|jpeg)$\"\"\" path then -- Normally not called because server.js takes care of these cases.\n        \"\"\"<html><head><title>@path</title></head><body><img src=\"@path\"></body></html>\"\"\"\n      else\n        (if hydefilecache == Nothing then fs.read path else\n          case hydefilecache of\n            Just {file=hydefile} ->\n              let withoutPipeline = \n                    case hydefilecache of\n                      Just {cacheContent} ->\n                        case evaluate cacheContent of\n                          {inputFiles, outputFiles} ->\n                            List.find (\\e -> e == path || e == \"/\" + path) inputFiles == Nothing &&\n                            List.find (\\e -> e == path || e == \"/\" + path) outputFiles == Nothing\n                          _ -> False\n                      _ -> False -- Need to recompute the cache anyway\n              in\n              if withoutPipeline then fs.read path else\n              let source = fs.read hydefile |>\n                      Maybe.withDefaultLazy (\\_ -> \"\"\"all = [Error \"hydefile '@hydefile' not found?!\"]\"\"\")\n                  source = source + Update.freeze \"\\n\\nlet t = \" + (listDict.get \"task\" vars |> Maybe.withDefault \"all\") + \"\\n    t = if typeof t == 'function' then t () else t\\n    t = if typeof t == 'list' then t else [t]\\nin t\"\n                  fileDirectory = Regex.replace \"/[^/]*$\" \"\" hydefile\n                  inDirectory name = if fileDirectory == \"\" then name else\n                    fileDirectory  + \"/\" + name\n                  fsReadRecord = \n                      { directReadFileSystem |\n                        read name =\n                          let name = inDirectory name in\n                          let _ = recordFileRead name in\n                          fs.read name,\n                        listdir name =\n                          let name = inDirectory name in\n                          let _ = recordFolderList name in\n                          fs.listdir name\n                      }\n                  fsHyde = nodejs.delayedFS fsReadRecord <|\n                    Update.lens {\n                      apply = identity\n                      update {outputNew, diffs} = -- input and outputOld were empty, diffs is valid\n                      -- We just need to change the paths\n                        outputNew |>\n                        List.map (case of\n                          (name, Rename newName) -> (inDirectory name, Rename (inDirectory newName))\n                          (name, x) -> (inDirectory name, x))|>\n                        flip (,) (Just diffs) |>\n                        List.singleton |> InputsWithDiffs |> Ok\n                    } fileOperations\n              in\n              let (generatedFilesDict, errors) =\n                    __evaluate__ ((\"fs\", fsHyde)::preludeEnv) source\n                    |> Result.map (\\writtenContent ->\n                        let (written, errors) = List.partition (case of Write -> True; _ -> False) writtenContent in\n                        let tuplesToWrite =\n                              List.map (case of Write name content -> (inDirectory name, content)) written\n                            joinedErrors = \n                              List.map (case of Error msg -> msg) errors |> String.join \"\\n\"\n                        in\n                        let _ = recordOutputFiles tuplesToWrite in -- Writes on disk and caches the names of written files\n                        (tuplesToWrite, joinedErrors))\n                    |> Result.withDefaultMapError (\\msg -> ([], msg))\n              in\n              let _ = cacheResult () in\n              --let _ = Debug.log \"generatedFilesDict\" generatedFilesDict in\n              case listDict.get (\"/\" + path) generatedFilesDict of\n                Nothing ->\n                  case listDict.get path generatedFilesDict of\n                    Nothing ->\n                      if errors == \"\" then\n                        let _ = Debug.log \"\"\"Unable to read (/)@path from output of hydefile\"\"\" () in\n                        fs.read path\n                      else\n                        Just <|\n                        serverOwned \"error recovery of hyde build tool\" <|\n                        \"\"\"<html><head></head><body><h1>Error while resolving the generated version of @path</h1><pre>@errors</pre></body></html>\"\"\"\n                    x -> x\n                x -> x\n            _ -> fs.read path\n        )\n      |> Maybe.withDefaultReplace (\n        serverOwned \"404 page\" (if isTextFile path then\n               if permissionToCreate then freeze \"\"\"@path does not exist yet. Modify this page to create it!\"\"\" else \"\"\"Error 404, @path does not exist or you don't have admin rights to modify it (?admin=true)\"\"\"\n            else \"\"\"<html><head></head><body>@(\n              if permissionToCreate then freeze \"\"\"<span>@path does not exist yet. Modify this page to create it!</span>\"\"\" else \"\"\"<span>Error 404, @path does not exist or you don't have admin rights to modify it (?admin=true)</span>\"\"\"\n                )</body></html>\"\"\")\n      )\n{---------------------------------------------------------------------------\nUtility functions to be inherited by the main body of any\nview of editor (edit / file listing / word processor / etc)\nLUCA stands for \"Last Universal Common Ancestor\"\n----------------------------------------------------------------------------}\n\nluca = \n  [<script id=\"thaditor-luca\">\n    function writeDocument(NC) {\n      document.open();\n      document.write(NC);\n      document.close();\n    }\n    var XHRequest = @(if browserSide then \"ProxiedServerRequest\" else \"XMLHttpRequest\");\n    function doReadServer(action, name) {\n      if (typeof readServer != \"undefined\") {\n        console.log(\"reading server\");\n        return readServer(action, name);\n      } else {\n        var request = new XMLHttpRequest();\n        var url = \"/\";\n        request.open('GET', url, false);  // `false` makes the request synchronous\n        request.setRequestHeader(\"action\", action);\n        request.setRequestHeader(\"name\", name);\n        request.send(null);\n        if(request.status == 200) {\n          return request.responseText || \"\";\n        } else {\n          console.log(\"error while reading \" + url, request);\n          return \"\";\n        }\n      }\n    }\n    function doWriteServer(action, name, content) {\n      if (typeof writeServer != \"undefined\") {\n        console.log(\"about to write to server\");\n        return writeServer(action, name, content);\n      } else {\n        var request = new XMLHttpRequest();\n        request.open('POST', url, false);  // `false` makes the request synchronous\n        request.setRequestHeader(\"action\", action);\n        request.setRequestHeader(\"name\", name);\n        request.send(content);\n        if(request.status == 200) {\n          return \"\";\n        } else if(request.status == 500) {\n          return request.responseText;\n        } else {\n          console.log(\"error while writing \" + url, request);\n          return \"\";\n        }\n      }\n    }\n    // Page reloading without trying to recover the editor's state.\n    function doReloadPage(url, replaceState) {\n      var xmlhttp = new XHRequest();\n      xmlhttp.onreadystatechange = ((xmlhttp, replaceState) => () => {\n        if (xmlhttp.readyState == XMLHttpRequest.DONE) {\n          //source of the editing menu disappearing after reloading\n          writeDocument(xmlhttp.responseText);\n          var newLocalURL = xmlhttp.getResponseHeader(\"New-Local-URL\");\n          if(newLocalURL) {\n            window.history[xmlhttp.replaceState ? \"replaceState\" : \"pushState\"]({localURL: newLocalURL}, \"Nav. to \" + newLocalURL, newLocalURL);\n          }\n        }\n      })(xmlhttp, replaceState);\n      xmlhttp.open(\"POST\", location.pathname + location.search);\n      xmlhttp.setRequestHeader(\"reload\", \"true\");\n      xmlhttp.setRequestHeader(\"url\", url);\n      if(googleAuthIdToken) {\n        xmlhttp.setRequestHeader(\"id-token\", googleAuthIdToken)\n      }\n      console.log(\"setting url to \", url);\n      xmlhttp.send(\"{\\\"a\\\":1}\");\n    }\n    window.onpopstate = function(e){\n        console.log(\"onpopstate\", e);\n        if(e.state && e.state.localURL) {\n          doReloadPage(location, true);\n        } else {\n          doReloadPage(location.pathname + location.search, true);\n        }\n    };\n    //document.body.appendChild(el(\"progress\", {id:\"progress-bar\", max:100, value:0, visible:false}, [], {}));\n\n    function sendNotification(msg, timeout) {\n      /*\n        Pushes the notification msg to the log & displays it for 3 seconds directly left of the moidfymenu.\n        css for notification box is textarea .notif\n      */\n\n      let modifyMenuDiv = document.querySelector(\"#modify-menu\");\n      if (!modifyMenuDiv) {\n        console.log(\"Notifications havent been set up for use outside of editor, like in the filesystem\");\n        return;\n      }\n      let notifBox = document.getElementById(\"notif-box\");\n      if (!notifBox) { //function el(tag, attributes, children, properties) \n        notifBox = el(\"textarea\", {id:\"notif-box\", class:\"textarea notifs\", visibility:true, readonly:true, isghost:true}, [], {value:msg});\n        modifyMenuDiv.append(notifBox);\n      }\n      notifBox.style.value = msg;\n      notifBox.style.display = 'block';\n      notifBox.style.zIndex = 100;\n      notifBox.style.visibility = true;\n      editor_model.editor_log.push(msg);\n      const issaving = editor_model.isSaving;\n      let log = document.getElementById(\"fullLog\");\n      if (log) {\n        let elog = editor_model.editor_log;\n        let logtxt = \"\";\n        for (let i = 0; i < editor_model.editor_log.length; i++) {\n          logtxt = logtxt + editor_model.editor_log[i] + \"\\n\";\n        }\n        logtxt == \"\" ? log.value = \"(no log)\" : log.value = logtxt;\n        log.style.display = 'block';\n      }\n      setTimeout(hideNotification, timeout ? timeout : 3000);\n    }\n\n    function hideNotification() {\n      let notifBox = document.getElementById(\"notif-box\");\n      if (notifBox) {\n        notifBox.style.display = 'none';\n      }\n    }\n\n    var uploadProgress = [];\n\n    function initializeProgress(numFiles) {\n      var progressBar = document.getElementById(\"progress-bar\");\n      if (!progressBar) {\n        console.err (\"Warning! Add the progress bar yourself before calling this. We'll add it for you this time.\");\n        document.body.appendChild(el(\"progress\", {id:\"progress-bar\", max:100, value:0, visible:false}, [], {}));\n      }\n      progressBar.value = 0;\n      progressBar.visible = true;\n      uploadProgress = [];\n\n      for(let i = numFiles; i > 0; i--) {\n        uploadProgress.push(0);\n      }\n    }\n\n    function updateProgress(fileNumber, percent) {\n      uploadProgress[fileNumber] = percent;\n      let total = uploadProgress.reduce((tot, curr) => tot + curr, 0) / uploadProgress.length;\n      console.log (\"prog updated\");\n      documentgetElementById(\"progress-bar\").value = total;\n    }\n\n    // Editor's API should be stored in the variable editor.\n\n    editor = typeof editor === \"object\" ? editor : {};\n    editor.uploadFile = function(targetPathName, file, onOk, onError, updateProgFunction) {\n      \n      var xhr = new XMLHttpRequest();\n      xhr.onprogress = (e) => {\n        updateProgFunction(i, (e.loaded * 100.0 / e.total) || 100)\n      }\n      xhr.onreadystatechange = ((xhr, file) => () => {\n        if (xhr.readyState == XMLHttpRequest.DONE) {\n          if (xhr.status == 200 || xhr.status == 201) {\n            onOk ? onOk(targetPathName, file) : 0;\n          } else {\n            console.log(\"Error while uploading picture or file\", xhr);\n            onError ? onError(targetPathName, file) : 0;\n          }\n        }\n        var progbar = document.getElementById(\"progress-bar\");\n      })(xhr, file);\n      @(if listDict.get \"browserSide\" defaultOptions == Just True then \"\"\"\n      xhr.open(\"POST\", \"/Thaditor/editor.php?action=write&name=\" + encodeURIComponent(targetPathName), false);\n      \"\"\" else \"\"\"\n      xhr.open(\"POST\", targetPathName, false);\n      xhr.setRequestHeader(\"write-file\", file.type);\n      \"\"\");\n      xhr.send(file);\n    }\n    // Returns the storage folder that will prefix a file name on upload (final and initial slash excluded)\n    editor.getStorageFolder = function(file) {\n      var storageOptions = document.querySelectorAll(\"meta[editor-storagefolder]\");\n      for(let s of storageOptions) {\n        if(file.type.startsWith(s.getAttribute(\"file-type\") || \"\")) {\n          let sf = storageOptions.getAttribute(\"editor-storagefolder\") || \"\";\n          if(!sf.endsWith(\"/\")) sf = sf + \"/\";\n          return sf;\n        }\n      }\n      let extension = \"\";\n      if(file && file.type.startsWith(\"image\")) {\n        var otherImages = document.querySelectorAll(\"img[src]\");\n        for(let i of otherImages) {\n           extension = (i.getAttribute(\"src\") || \"\").replace(/[^\\/]*$/, \"\");\n           break;\n        }\n        if(extension[0] == \"/\") { // Absolute URL\n          return extension;\n        }\n      }\n      if(extension != \"\" && extension[extension.length-1] != \"/\") {\n        extension = extension + \"/\";\n      }\n      // extension ends with a / or is empty\n      var tmp = location.pathname.split(\"/\");\n      tmp = tmp.slice(0, tmp.length - 1);\n      storageFolder = tmp.join(\"/\") + (extension != \"\" ?  \"/\" + extension : \"/\");\n      return storageFolder;\n    }\n\t  editor.fs = { listdir: \n\t\t    function(dirname) {\n          return JSON.parse(doReadServer(\"listdir\", dirname) || \"[]\");\n\t\t    }\n\t  };\n    editor.toTreasureMap = function(oldNode) {\n      if(!oldNode) return undefined;\n      if(oldNode.nodeType == 1 && oldNode.getAttribute(\"id\") && document.getElementById(oldNode.getAttribute(\"id\"))) {\n        return {id: oldNode.getAttribute(\"id\")};\n      }\n      let tentativeSelector = [];\n      let t = oldNode;\n      let isText = false, textIndex = 0;\n      while(t && t.parentNode) {\n        let index = Array.prototype.slice.call( t.parentNode.children ).indexOf(t);\n        if(t.nodeType === 1) {\n          tentativeSelector.unshift(t.tagName + \":nth-child(\" + (index + 1) + \")\" );\n        } else {\n          isText = true;\n          textIndex = Array.prototype.slice.call( t.parentNode.childNodes ).indexOf(t);\n        }\n        t = t.parentNode;\n      }\n      return {tentativeSelector: tentativeSelector, isText: isText, textIndex: textIndex};\n    }\n    // Returns the new node that matches the old node the closest.\n    // For text nodes, try to recover the text node, if not, returns the parent node;\n    editor.fromTreasureMap = function(data) {\n      if(!data) return undefined;\n      if(typeof data === \"object\" && data.id) {\n        return document.getElementById(data.id);\n      }\n      if(typeof data == \"object\" && Array.isArray(data.tentativeSelector)) {\n        let tentativeSelector = data.tentativeSelector;\n        while(tentativeSelector.length >= 1) {\n          let newNode = document.querySelector(tentativeSelector.join(\" \"));\n          if(newNode) {\n            return data.isText && newNode.childNodes && newNode.childNodes[data.textIndex] || newNode;\n          }\n          tentativeSelector.shift();\n        }\n        return undefined;\n      }\n    }\n    \n    function el(tag, attributes, children, properties) {\n      let tagClassIds = tag.split(/(?=#|\\.)/g);\n      let x;\n      for(let attr of tagClassIds) {\n        if(x && attr.startsWith(\".\")) {\n          x.classList.toggle(attr.substring(1), true);\n        } else if(x && attr.startsWith(\"#\")) {\n          x.setAttribute(\"id\", attr.substring(1));\n        } else if(!x) {\n          x = document.createElement(attr);\n        }\n      }\n      if(typeof attributes == \"object\")\n        for(let k in attributes)\n          x.setAttribute(k, attributes[k]);\n      if(Array.isArray(children)) {\n        for(let child of children) {\n          if(typeof child === \"string\") {\n            x.append(child)\n          } else if(typeof child !== \"undefined\")\n            x.appendChild(child);\n        }\n      } else if(typeof children !== \"undefined\") {\n        x.append(children);\n      }\n      if(typeof properties == \"object\") {\n        for(let k in properties)\n          x[k] = properties[k];\n      }\n      return x;\n    }    \n   </script>]\n\n\n-- Conversion of php script to elm script\nphpToElmFinal path string =\n  let includingFolder = Regex.replace \"\"\"(/)[^/]*$\"\"\" (\\{submatches=[slash]} -> slash) path in\n  let phpToElm string =\n        let echoRaw content = \"\\nob = ob + \" + content in\n        let wrapStr content = freeze String.q3 + Regex.replace \"@\" (\\{match=m} -> m + m) content + freeze String.q3 in\n        let echo content = echoRaw (wrapStr content) in\n        let phpStringToElmString =\n                (Regex.replace \"\"\"(\\\")([^\\\"]*)(\\\")\"\"\" <| \\m ->\n                  nth m.group 1 +\n                  (nth m.group 2\n                  |> Regex.replace \"\"\"\\$[0-9a-zA-Z_]*\"\"\" (\\n ->\n                     freeze \"\\\" + \" + nth n.group 0 + freeze \" + \\\"\")) +\n                  nth m.group 3) >>\n                (Regex.replace \"\"\"\\$_GET\\[([^\\]]*)\\]\"\"\" <| \\m ->\n                  freeze \"listDict.get \"+ nth m.group 1 + freeze \" $_GET |> Maybe.withDefaultReplace ''\"\n                ) >>\n                (Regex.replace \"\"\"\\$_SERVER\\[([^\\]]*)\\]\"\"\" <| \\m ->\n                  freeze \"listDict.get \"+ nth m.group 1 + freeze \" $_SERVER |> Maybe.withDefaultReplace ''\"\n                )\n        in\n        if not (Regex.matchIn \"<?php\" string) then\n          echo string\n        else\n        Regex.replace \"\"\"^((?:(?!<\\?php)[\\s\\S])+?)(?=(<\\?php))|(\\?>)([\\s\\S]*?)(?=<\\?php)|(\\?>)([\\s\\S]*?)$|(^)(<\\?php)([\\s\\S]*?)(?=\\?>)|(<\\?php)\\s*if\\s*\\(([\\s\\S]*?)\\s*\\)\\s*\\{\\s*\\?>((?:(?!<\\?php)[\\s\\S])+?)<\\?php\\s*\\}\\s*(?=\\?>)|(<\\?php)([\\s\\S]*?)(?=\\?>)\"\"\" (\n             \\{submatches=[content1, isRaw1, isRaw2, content2, isRaw3, content3, beginning1, isPhp1, code1, isPhpIf, condIf, codeIf, isPhp2, code2]} ->\n          if isPhp1 /= \"\" || isPhp2 /= \"\" || isPhpIf /= \"\" then\n            let prefix = if isPhp1 /= \"\" then echo beginning1 else freeze \"\" in\n            prefix +\n            if isPhpIf /= \"\" then\n              echoRaw <| \"(if \"+condIf+\" then \" + wrapStr codeIf + \" else \\\"\\\")\"\n            else\n            let code = if isPhp1 /= \"\" then code1 else code2 in\n            case Regex.extract \"\"\"^\\s*include\\(\"([^\"]*)\"\\)\"\"\" code of\n              Just [included] ->\n                phpToElm (fs.read (includingFolder + included) |> Maybe.withDefaultReplace (\"\\n[code to read \" + included + \" in \" + includingFolder +\"]\"))\n              _ ->\n            case Regex.extract \"\"\"^\\s*switch\\s*\\(([^\\)]*)\\)\\s*\\{((?:\\s*(?:case\\s*[^:]*?\\s*|default):((?:\\s*\\$[\\w_]+\\s*=\\s*(?:(?!;\\r?\\n)[\\s\\S])*;)*)(?:\\s*break\\s*;)?)*)\\s*\\}\\s*\"\"\" code of\n              Just [input, assignments, lastAssignment] ->\n                let vars = \"(\" + (Regex.find \"\"\"(\\$[\\w_]+)\\s*=\"\"\" lastAssignment |> List.map (\\[_, name] -> name) |> String.join \", \") + \")\" in\n                let results = assignments |> Regex.find \"\"\"\\s*(case\\s*([^:]*?)\\s*|default):((?:\\s*\\$[\\w_]+\\s*=\\s*(?:(?!;\\r?\\n)[\\s\\S])*;)*)(?:\\s*break\\s*;)?\"\"\" |>\n                      List.map (\\[whole, caseOrDefault, pattern, values] ->\n                        let tuple =\n                              Regex.find \"\"\"\\s*\\$[\\w_]+\\s*=\\s*((?:(?!;\\r?\\n)[\\s\\S])*?)\\s*;\"\"\" values |>\n                              List.map (\\[whole2, value2] -> phpStringToElmString value2) |> String.join \", \"\n                        in\n                        let finalPattern = if caseOrDefault == \"default\" then \"_\" else pattern in\n                        \"\\n  \" + finalPattern + \" -> (\" + tuple + \")\"\n                      ) |> String.join \"\"\n                in\n                \"\\n\" + vars + \" = case \" + phpStringToElmString input + \" of\"  + results\n              _ ->\n            case Regex.extract \"\"\"\\s*(?:echo|print)\\s+([^;]+?);\\s*\"\"\" code of\n              Just [content] -> echoRaw content\n              res ->\n                \"\\n[convert\" + code + \"]\\n\" + toString res\n          else\n          let content = if isRaw1 /= \"\" then\n                content1\n              else if isRaw2 /= \"\" then\n                content2\n              else -- if isRaw3 /= \"\" then\n                content3\n          in\n          echo content\n        ) string\n  in\n  flip (+) \"\\nob\" <|\n  (+) \"date _ = '2019'\\nob = freeze ''\" <| phpToElm string\n\n{---------------------------------------------------------------------------\n Evaluates the page according to the path extension.\n - Wraps html pages to parse them as raw html\n - Interprets markdown pages and evaluate them as raw html with CSS\n - Directly evaluate sources from elm/leo pages or folders\n----------------------------------------------------------------------------}\nevaluatedPage: Result String Html\nevaluatedPage = \n  if canEvaluate /= \"true\" then\n    Ok <html><head></head><body>URL parameter evaluate=@(canEvaluate) requested the page not to be evaluated</body></html>\n  else if isTextFile path || varraw then\n    Ok <html>\n        <head>\n        <title>@path</title>\n        <style type=\"text/css\" media=\"screen\">\n            #aceeditor { \n                  height: 100%;\n                  width: 100%;\n                  border: 1px solid #DDD;\n                  border-radius: 4px;\n                  border-bottom-right-radius: 0px;\n                  margin-top: 5px;\n            }\n        </style>\n        <script>\n          function loadAceEditor() {\n            console.log(\"executing script\");\n            var aceeditor = ace.edit(\"aceeditor\");\n            var mode = path.match(/\\.js$/) ? \"ace/mode/javascript\" :\n                       path.match(/\\.html?$/) ? \"ace/mode/html\" :\n                       path.match(/\\.css$/) ? \"ace/mode/css\" :\n                       path.match(/\\.json$/) ? \"ace/mode/json\" :\n                       path.match(/\\.leo$/) ? \"ace/mode/elm\" :\n                       path.match(/\\.elm$/) ? \"ace/mode/elm\" :\n                       path.match(/\\.php$/) ? \"ace/mode/php\" :\n                       \"ace/mode/plain_text\";\n            aceeditor.session.setMode({path: mode, v: Date.now()});\n            aceeditor.setOptions({\n              fontSize: \"20pt\"\n            });\n            aceeditor.setValue(document.getElementById(\"aceeditor\").getAttribute(\"initdata\"));\n            aceeditor.session.on('change', function(e) {\n              document.getElementById(\"aceeditor\").setAttribute(\"initdata\", aceeditor.getValue());\n            });\n            var callbackSelection = function() {\n              var anchor = aceeditor.selection.getSelectionAnchor();\n              var lead = aceeditor.selection.getSelectionLead();\n              var div = document.querySelector(\"#aceeditor\");\n              div.setAttribute(\"ghost-anchor-row\", anchor.row)\n              div.setAttribute(\"ghost-anchor-column\", anchor.column)\n              div.setAttribute(\"ghost-lead-row\", lead.row)\n              div.setAttribute(\"ghost-lead-column\", lead.column)\n            }\n            aceeditor.selection.on(\"changeSelection\", callbackSelection);\n            aceeditor.selection.on(\"changeCursor\", callbackSelection);\n            var div = document.querySelector(\"#aceeditor\");\n            aceeditor.selection.moveTo(div.getAttribute(\"ghost-anchor-row\") || 0, div.getAttribute(\"ghost-anchor-column\") || 0)\n            aceeditor.focus();\n          }\n        </script>\n        </head>\n        <body>\n        <div id=\"aceeditor\" list-ghost-attributes=\"class draggable style\" children-are-ghosts=\"true\"\n          save-ghost-attributes=\"style ghost-anchor-column ghost-anchor-row ghost-lead-column ghost-lead-row\" initdata=@sourcecontent></div>\n        <script>\n        editor.ghostNodes.push(node =>\n          node.tagName === \"SCRIPT\" && node.getAttribute(\"src\") && node.getAttribute(\"src\").match(/mode-(.*)\\.js|libs\\/ace\\/.*\\/ext-searchbox.js/)\n        );\n        \n        var script = document.createElement('script');\n        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.2/ace.js';\n        script.async = false;\n        script.setAttribute(\"isghost\", \"true\");\n        ace = undefined;\n        document.head.appendChild(script);\n        var path = @(jsCode.stringOf path);\n        onAceLoaded = (delay) => () => {\n          if(typeof ace != \"undefined\") {\n            console.log(\"ace loaded.\")\n            loadAceEditor();\n          } else {\n            console.log(\"ace not loaded. Retrying in \" + (delay * 2) + \"ms\");\n            setTimeout(onAceLoaded(delay * 2), 100);\n          }\n        }\n        onAceLoaded(1)();\n        </script>\n        </body>\n        </html>\n  else \n  let isPhp = Regex.matchIn \"\"\"\\.php$\"\"\" path in\n  let isHtml = Regex.matchIn \"\"\"\\.html?$\"\"\" path in\n  if isHtml || isPhp then\n    let sourcecontent = if isHtml then applyDotEditor sourcecontent else\n      let elmSourceContent = phpToElmFinal path sourcecontent in\n      __evaluate__ ((\"$_GET\", vars)::(\"$_SERVER\", [(\"SCRIPT_NAME\", \"/\" + path)])::(\"path\", path)::(\"fs\", fs)::preludeEnv) elmSourceContent |>\n      case of\n        Err msg -> serverOwned \"error message\" \"<html><head></head><body><pre>Error elm-reinterpreted php: \" + Regex.replace \"<\" \"&lt;\" msg + \"</pre>Original computed source <pre>\" +\n          Regex.replace \"<\" \"&lt;\" elmSourceContent +\n          \"</pre></body></html>\"\n        Ok sourcecontent -> applyDotEditor sourcecontent\n    in\n    let interpretableData =\n          case Regex.extract \"\"\"^\\s*<!DOCTYPE(?:(?!>)[\\s\\S])*>([\\s\\S]*)$\"\"\" sourcecontent of\n            Just [interpretableHtml] -> serverOwned \"begin raw tag\" \"<raw>\" + interpretableHtml + serverOwned \"end raw tag\" \"</raw>\"\n            _ ->\n          case Regex.extract \"\"\"^[\\s\\S]*?(<html\\b[\\s\\S]*)$\"\"\" sourcecontent of\n            Just [interpretableHtml] -> serverOwned \"begin raw tag\" \"<raw>\" + interpretableHtml + serverOwned \"end raw tag\" \"</raw>\"\n            _ -> serverOwned \"raw display of html - beginning\" \"\"\"<raw><html><head></head><body>\"\"\" + sourcecontent + serverOwned \"raw display of html - end\" \"\"\"</body></html></raw>\"\"\"\n    in\n    __evaluate__ preludeEnv interpretableData\n    |> Result.andThen (case of\n      [\"raw\", _, nodes] ->\n        case List.find (case of [\"html\", _, _] as n -> True; _ -> False) nodes of\n          Just n -> Ok n\n          Nothing -> Err \"\"\"No top-level HTML node found\"\"\" \n      result -> Err \"\"\"Html interpretation error: The interpretation of raw html did not work but produced @result\"\"\"\n    )\n  else if Regex.matchIn \"\"\"\\.md$\"\"\" path then\n    let markdownized = String.markdown sourcecontent in\n      case Html.parseViaEval markdownized of\n        x -> \n          let markdownstyle = fs.read \"markdown.css\" |> Maybe.withDefaultReplace defaultMarkdowncss in\n          Ok <html><head></head><body><style title=\"If you modify me, I'll create a custom markdwon.css that will override the default CSS for markdown rendering\">@markdownstyle</style><div class=\"wrapper\">@x</div></body></html>\n  else if Regex.matchIn \"\"\"\\.(elm|leo)$\"\"\" path then\n    __evaluate__ ((\"vars\", vars)::(\"path\", path)::(\"fs\", fs)::preludeEnv) sourcecontent\n  else if fs.isdir path then\n    let\n      pathprefix = if path == \"\" then path else path + \"/\"\n    in\n    Ok <html><head>\n      \n      <script>\n        var ispressed = false;\n        var whichOne = \"\";\n        //declare bool variable to be false\n        document.onkeydown = function(e) {\n          if (e.ctrlKey){\n              ispressed = true;\n          }\n        };\n        document.onkeyup = function(e) {\n          if (e.keyCode == 17){ //releasing ctrl key. doesn't set e.ctrlKey properly or would use that.\n            ispressed = false;\n          }\n        }\n        var handleFileSelect = e => {\n          e.preventDefault();\n        }\n        document.addEventListener('drop', handleFileSelect, false);\n      </script>\n      <style>\n        #menu_bar {\n          overflow: hidden;\n          background-color: #ffffff;\n          opacity:1;\n        }\n\n        #menu_bar a {\n          float: left;\n          display: block;\n          color: #f2f2f2;\n          text-align: center;\n          padding: 14px 16px;\n          text-decoration: none;\n          font-size: 17px;\n        }\n\n        #menu_bar a:hover {\n          background-color: #ddd;\n          color: black;\n        }\n\n        #menu_bar a.active {\n          background-color: #4CAF50;\n          color: white;\n        }\n        .dropdown {\n          float: left;\n          overflow: hidden;\n        }\n\n        .dropdown .dropbtn {\n          font-size: 16px;  \n          border: none;\n          outline: none;\n          color: white;\n          padding: 14px 16px;\n          background-color: inherit;\n          font-family: inherit;\n          margin: 0;\n        }\n        .dropdown .dropbtn {\n          font-size: 16px;  \n          border: none;\n          outline: none;\n          color: white;\n          padding: 14px 16px;\n          background-color: inherit;\n          font-family: inherit;\n          margin: 0;\n        }\n\n        .menu_bar a:hover, .dropdown:hover .dropbtn {\n          background-color: red;\n        }\n\n        .dropdown-content {\n          display: none;\n          position: absolute;\n          background-color: #f9f9f9;\n          min-width: 160px;\n          box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);\n          z-index: 1;\n        }\n\n        .dropdown-content a {\n          float: none;\n          color: black;\n          padding: 12px 16px;\n          text-decoration: none;\n          display: block;\n          text-align: left;\n        }\n\n        .dropdown-content a:hover {\n          background-color: #ddd;\n        }\n\n        .dropdown:hover .dropdown-content {\n          display: block;\n        }\n        .content {\n          padding: 16px;\n        }\n\n        .sticky {\n          position: fixed;\n          top: 0;\n          width: 100%;\n        }\n\n        .sticky + .content {\n          padding-top: 60px;\n        }\n        #fileListing div.file-item {\n          display: block;\n        }\n        #fileListing div.file-item input {\n          display: none;\n        }\n        #fileListing div.file-item {\n          display: table-row;\n        }\n        #fileListing div.file-item label {\n          display: table-cell;\n          vertical-align: middle;\n          padding: 0.3em;\n        }\n        #fileListing div.file-item label:hover {\n          background: rgb(229,243,255);\n        }\n        #fileListing div.file-item input:checked + label {\n          color: white;\n          outline: 1px solid rgb(153,209,255);\n          background: rgb(204,232,255);\n        }\n        #fileListing div.file-item label a {\n          text-decoration: none;\n          color: black;\n          padding: 2px;\n        }\n        #fileListing div.file-item label a:hover {\n          text-decoration: underline;\n          color: blue;\n        }\n        #fileListing div.file-item label svg {\n          vertical-align: middle;\n          transform: scale(0.5);\n        }\n        #fileListing div.file-item label svg.file-extension-icon {\n          opacity: 0.5;\n        }\n        #fileListing div.file-item label svg.file-extension-icon > path {\n          stroke:black;\n          stroke-width:2px;\n          stroke-linecap:butt;\n          fill:none;\n          -linejoin:miter;\n          stroke-opacity:1;\n        }\n        #fileListing div.file-item label svg.file-extension-icon > text {\n          font-size: 2em;\n        }\n\n      </style>\n      <div id=\"menu_bar\">\n        <button id=\"renamefs\" onClick=\"renameFs()\">Rename File(s)</button>\n        <button id=\"duplicatefs\" onClick=\"duplicateFs()\">Make a Copy</button>\n        <button id=\"movefs\" onClick=\"moveFs()\">Move File(s)</button>\n        <button id=\"createFolder\" onClick=\"createFolder()\">Create a Folder</button>\n        <button id=\"deletefs\" onClick=\"deleteFs()\">Delete File(s)</button>\n        <div id=\"forprog\"></div>\n      </div>\n      </head><body><h1><label value=path>@path</label></h1>\n      <form id=\"fileListing\"></form>\n      <script>\n      var fullListDir = (path) => JSON.parse(doReadServer(\"fullListDir\", path));\n      var thisListDir = fullListDir (\"@path\");\n      var folders = thisListDir.filter((i) => i[1] == true);\n      var getSelectedFiles = () => Array.from(document.querySelectorAll(\"input.filesBtn\")).filter((btn) => btn.checked);\n      var warnSelectFile = reason => window.alert (reason + \", please select some and click this button again\");\n      var warnDeselectFiles = reason => window.alert (reason + \", please deselect all files and folders and click this button again\");\n      var isDupInFolder = (folder, name) => folder.filter((i) => i[0] == name).length != 0;\n      var isDuplicateHere = (name) => isDupInFolder(thisListDir, name);\n      var isFolder = (name) => folders.filter((i) => i[0] == name).length != 0;\n\n      window.onscroll = function() {stickyFun()};\n      var menu_bar = document.getElementById(\"menu_bar\");\n      var sticky = menu_bar.offsetTop;\n\n      function stickyFun() {\n        if (window.pageYOffset >= sticky) {\n          menu_bar.classList.add(\"sticky\")\n        } else {\n          menu_bar.classList.remove(\"sticky\");\n        }\n      }\n      function getOneFile(reason) {\n        var selected = getSelectedFiles();\n        if (selected.length == 0) {\n          warnSelectFile(reason);\n          return 0;\n        } else if (selected.length != 1) {\n          window.alert (\"Please select only one file to rename\");\n          return 0;\n        }\n        return selected[0];\n      }\n      function renameFs() {\n        console.log (\"in rename fs\");\n        var sel = getOneFile(\"To rename files or folders\");\n        if (! sel) return;\n        if (sel.id == \"..\") {\n          window.alert(\"Can't change the up dir\");\n          return;\n        }\n        var newname = window.prompt(\"Set new name for file: \", sel.id);\n        if (newname == null) return;\n        if (newname == \"\") {\n          window.alert(\"Please specify a new name for the file.\");\n          return;\n        }\n        if (isDuplicateHere(newname)) {\n          window.alert(\"Please choose a different name so as to not overwrite an existing file. (or change the name of that file).\");\n          return;\n        }\n        var x = doWriteServer(\"rename\", \"@path\" + sel.id, \"@path\" + newname);\n        if (x) {\n          console.log (\"rename failed\");\n          window.alert(\"rename failed\");\n          return;\n        }\n        console.log (\"renamed\", sel.id, newname);\n        goodReload();\n      }\n      function deleteFs() {\n        var selected = getSelectedFiles();\n        if (selected.length == 0) {\n          warnSelectFile(\"To delete a file or a folder\"); \n          return;\n        }\n        if (selected.filter((i) => i.id == \"..\").length != 0) {\n          window.alert(\"Can't change the up dir\");\n          return;\n        }\n        var warningMsg = \"Are you sure you want to delete the following file(s)?\"\n        for (i = 0; i < selected.length; i++) {\n          warningMsg = warningMsg + \"\\n\" + selected[i].id;\n        }\n        var conf = window.confirm(warningMsg);\n        if (conf) {\n          for (i = 0; i < selected.length; i++) {\n            var isfolder = folders.filter((j) => j[0] == selected[i].id);\n            console.log (isfolder);\n            if (isfolder.length != 0) {\n              doWriteServer(\"rmdir\", \"@path\" + selected[i].id);\n              continue;\n            }\n            doWriteServer(\"unlink\", \"@path\" + selected[i].id);\n          }\n          goodReload();\n          return;\n        }\n      }\n      function duplicateFs() {\n        var sel = getOneFile(\"To duplicate files or folders\");\n        if (! sel) return;\n        if (sel.id == \"..\") {\n          window.alert(\"Can't change the up dir\");\n          return;\n        }\n        var lastdot = sel.id.lastIndexOf(\".\");\n        var nn;\n        if (isFolder(sel.id)) {\n          nn = sel.id + \"_(Copy)\";\n        } else {\n          nn = sel.id.substring(0, lastdot) + \"_(Copy)\" + sel.id.substring(lastdot);\n        }\n        var newname = window.prompt(\"Name for duplicate: \", nn);\n        var contents = doReadServer(\"read\", \"@path\" + sel.id);\n        if (contents[0] != \"1\") {\n          window.alert (\"Couldn't read the file for some reason. aborting.\");\n          console.error (\"couldn't read the file for some reason. aborting.\");\n          return;\n        }\n        contents = contents.substring(1, contents.length);\n        var resp = doWriteServer(\"create\", \"@path\" + newname, contents);\n        if (resp) {\n          console.error (\"Duplicating file failed for some reason: \", resp);\n        } \n        goodReload();\n      }\n      function createFolder() {\n        var btns = getSelectedFiles();\n        if (btns.length != 0) {\n          warnDeselectFiles(\"To create a folder\");\n          return;\n        }\n        var newname = window.prompt(\"Name for new folder: \", \"\");\n        console.log (newname);\n        if (newname == null) return;\n        if (newname == \"\") {\n          window.alert(\"Please set a name for the new folder!\");\n          return;\n        }\n        var dups = isDuplicateHere(newname);\n        if (dups) {\n          window.alert(\"There is already a file / folder with that name. Please try again.\");\n          return;\n        }\n        doWriteServer(\"mkdir\", newname, \"\");\n        goodReload();\n      }\n      function moveFs() {\n        var btn = getOneFile(\"To move files or folders\");\n        if (!btn) return;\n        if (btn.id == \"..\") {\n          window.alert(\"Can't change the up dir\");\n          return;\n        }\n        var newpath = window.prompt(\"New path to file (relative to root of server):\", \"@path\");\n        if (newpath == null) return;\n        if (newpath[newpath.length -1] != \"/\") {\n          newpath = newpath + \"/\";\n        }\n        try {\n          var nldir = fullListDir(newpath);\n          if (isDupInFolder(nldir, btn.id)) {\n            window.alert(\"There already exists a file in that folder with this name. Move cancelled.\");\n            return;\n          }\n        } catch (e) {\n          window.alert (\"The path specified does not exist. Move cancelled.\");\n          return;\n        }\n        console.log (\"move approved\");\n        var oldloc = (\"@path\" + btn.id);\n        var newloc = newpath == \"/\" ? btn.id : (newpath + btn.id);\n        console.log (\"renamimg\\n%s\\n%s\", (\"@path\" + btn.id), (newpath + btn.id));\n        doWriteServer(\"rename\", oldloc, newloc); \n        console.log (\"rename successful\");\n        goodReload();\n      }\n\n      function radPressed(){\n        var btns = document.querySelectorAll(\"input.filesBtn\");\n        if (!ispressed){\n          for(var i = 0; i < btns.length; i++){\n            if (btns[i].value == whichOne) continue;\n            btns[i].checked = false;\n          }\n        }\n      }\n      var handleFiles = (files) => {\n        var pgbr = document.getElementById(\"forprog\");\n        var progbar = document.getElementById(\"progress-bar\");\n        if (!progbar) {\n          pgbr.append(el(\"progress\", {id:\"progress-bar\", max:100, value:0, visible:true}, [], {}));\n          progbar = document.getElementById(\"progress-bar\");\n        } else {\n          progbar.visible = true;\n        }\n        initializeProgress(files.length);\n        var didUp = false;\n        ([...files]).forEach((fl) => {\n          var isgud = true;\n          thisListDir.forEach(([nm, isdir]) => {\n            if (nm == fl.name) {\n              window.alert(\"File named \" + fl.name + \" already exists in this folder. Overwrite cancelled.\", fl.name);\n              isgud = false;\n            }\n          });\n          if (isgud) {\n            editor.uploadFile(\"@path\" + fl.name, fl, (ok) => console.log (\"was ok\\n\" + ok), (err) => console.err (err), updateProgress);\n            didUp = true;\n          }\n        });\n        progbar.value = 100;\n        progbar.visible = false;\n        if (didUp) {\n          goodReload();\n          pgbr.innerHTML = \"\";\n        }\n      }\n      function preventDefaults (e) {\n        e.preventDefault()\n        e.stopPropagation()\n      }\n      function handleDrop(e) {\n        preventDefaults(e);\n        let dt = e.dataTransfer;\n        let files = dt.files;\n        handleFiles(files);\n      }\n      function loadFileList() {\n        let form = document.getElementById(\"fileListing\");\n        let path = @(jsCode.stringOf path);\n        let files = thisListDir;\n        function getRecordForCheckbox(file) {\n          var rec = {type:\"checkbox\",\n                      id:file,\n                      class:\"filesBtn\",\n                      name:\"filesBtn\",\n                      value:file,\n                      onClick:\"whichOne=value\",\n                      onChange:\"radPressed()\"};\n          return rec;\n        }\n        var dirIcon = () => {\n          var d = el(\"div\", {}, [], {innerHTML: \n          `<svg class=\"file-extension-icon\" width=\"60\" height=\"30\">\n            <path d=\"M 8,3 5,6 5,26 10,10 32,10 32,6 18,6 15,3 8,3 Z M 5,26 10,10 37,10 32,26 Z\" />`});\n          return d.childNodes[0];\n        }\n        var extensionIcon = name => {\n          let extension = name.replace(/^(?:(?!\\.(?=[^\\.]*$)).)*\\.?/, \"\");\n          if(\".\" + extension == name || extension === \"\") extension = \"-\";\n          var d = el(\"div\", {}, [], {innerHTML: \n          `<svg class=\"file-extension-icon\" width=\"60\" height=\"30\">\n            <text x=\"0\" y=\"25\">${extension}\n           `});\n          return d.childNodes[0];\n        }\n\n        var fileItemDisplay = function(link, name, isDir) {\n           return el(\"div\", {class:\"file-item\"}, [\n              el(\"input\", getRecordForCheckbox(name), \"\"),\n              el(\"label\", {for:name, value:name}, [\n                isDir ? dirIcon() : extensionIcon(name),\n                el(\"a\", {href:link}, name, {onclick: function(event) {\n                  event.preventDefault();\n                  let link = this.getAttribute(\"href\");\n                  doReloadPage(link);\n                }})])]);\n        }\n        //el(tag, attributes, children, properties)\n        if (path != \"\") {\n          var link = \"../\" + \"?ls=true&amp;edit\";\n          form.append(fileItemDisplay(link, \"..\", true));\n        }\n        // directories before files, sorted case-insensitive\n        files.sort(([name1, isDir1], [name2, isDir2]) =>\n          isDir1 && !isDir2 ? -1 : isDir2 && !isDir1 ? 1 :\n          name1.toLowerCase() < name2.toLowerCase() ? -1 : 0);\n        for (i = 0; i < files.length; i++) {\n          var [name, isDir] = files[i];\n          var link = isDir ? name + \"/?ls&\" + \"edit\" : name;\n          form.append(fileItemDisplay(link, name, isDir));\n        }\n\n        form.append(el(\"input\", {type:\"file\", id:\"fileElem\", onchange:\"handleFiles(this.files)\"}, [], {}));\n      }\n      loadFileList();\n      var goodReload = () => {\n        document.getElementById(\"fileListing\").innerHTML = \"\";\n        thisListDir = fullListDir (\"@path\");\n        loadFileList();\n      }\n    window.addEventListener('drop', handleDrop, false);\n    window.addEventListener('dragover', (e) => e.preventDefault(), false);\n    </script></body></html>\n  else \n    Ok <html><head></head><body>\n      <p>Editor cannot open file because it does not recognize the extension.</p>\n      <p>As an alternative, you can open the file in raw mode by appending <code>?raw</code> to it.</p>\n      <button onclick=\"\"\"\n        location.search = location.search + (location.search == \"\" ? \"?raw\" : \"&raw\");\n      \"\"\">Open @path in raw mode</button>\n    </body></html>  \n\n{---------------------------------------------------------------------------\n Recovers from evaluation errors\n----------------------------------------------------------------------------}\nrecoveredEvaluatedPage: Html\nrecoveredEvaluatedPage = --updatecheckpoint \"recoveredEvaluatedPage\" <|\n  case evaluatedPage of\n  Err msg -> serverOwned \"Error Report\" <|\n    <html><head></head><body style=\"color:#cc0000\"><div style=\"max-width:600px;margin-left:auto;margin-right:auto\"><h1>Error report</h1><pre style=\"white-space:pre-wrap\">@msg</pre></div></body></html>\n  Ok page -> page\n\njsEnabled = boolVar \"js\" True\n\nremoveJS node = case node of\n  [text, content] -> node\n  [tag, attrs, children] ->\n    if tag == \"script\" then [tag, [], [[\"TEXT\", \"/*Script disabled by Thaditor*/\"]]] else\n    [tag, attrs, List.map removeJS children]\n  _ -> []\n\n{---------------------------------------------------------------------------\n Instruments the resulting HTML page\n - Removes whitespace that are siblings of <head> and <body>\n - !f the page is editable:\n   * Adds the contenteditable attribute to body\n   * Adds the edition menu and the source preview area\n - Else: Adds the \"edit\" box to switch to edit mode\n - Adds the initial scripts\n - Append the edition scripts so that we can modify the page even without edit mode (that's dangerous, should we avoid this?)\n----------------------------------------------------------------------------}\nmain: Html\nmain = \n  --updatecheckpoint \"main\" <|\n  case recoveredEvaluatedPage of\n  [\"html\", htmlattrs, htmlchildren] -> [\"html\", htmlattrs, htmlchildren |>\n    List.filter (case of [_, _] -> False; _ -> True) |>\n    List.mapWithReverse identity (case of\n      [\"body\", bodyattrs, bodyChildren] ->\n        let bodyChildren = if jsEnabled then bodyChildren else List.map removeJS bodyChildren in\n        [\"body\",\n           (if canEditPage then\n             [[\"contenteditable\", \"true\"]] |> serverOwned \"contenteditable attribute of the body due to edit=true\" \n            else freeze []) ++\n           bodyattrs, insertThereInstead identity True bodyChildren ++ luca ++\n          if not varedit || varls then\n            bodyChildren\n          else \n             (if canEditPage then ((serverOwned \"edition menu\" editionmenu) sourcecontent) else\n              if not varedit && not iscloseable && not varproduction then serverOwned \"open edit box\" [openEditBox] else\n              serverOwned \"edit prelude when not in edit mode\" []) ++\n             bodyChildren ++\n             Update.sizeFreeze [[\"div\", [[\"id\", \"editor-files-to-overwrite\"]], insertThereInstead insertedElementsToWriteFile True fileOperations]] ++\n             (serverOwned \"synchronization script and placeholder\" [<div class=\"bottom-placeholder\"> </div>, <script  id=\"thaditor-lastscript\">@lastEditScript</script>] ++ insertThereInstead identity False bodyChildren -- All new nodes there are added back to bodyChildren.\n             )]\n      [\"head\", headattrs, headChildren] ->\n        let headChildren = if jsEnabled then headChildren else List.map removeJS headChildren in\n        [\"head\", headattrs,\n           insertThereInstead identity True headChildren ++  -- All new nodes added to the beginning of the head are added back to headChildren.\n           serverOwned \"initial script\" initialScript ++\n           (serverOwned \"viewport instructions\" <meta name=\"viewport\" content=\"width=device-width\"> :: \n            serverOwned \"stylesheet-of-server\" <style>/* The switch - the box around the slider */\n\n.switch {\n    position: relative;\n    display: inline-block;\n    width: 30px;\n    height: 17px;\n    vertical-align: middle;\n    margin-left: 0.6rem;\n}\n\n/* Hide default HTML checkbox */\n\n.switch input {\n    display: none;\n}\n\n/* The slider */\n\n.slider {\n    position: absolute;\n    cursor: pointer;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background-color: #ccc;\n    -webkit-transition: .4s;\n    transition: .4s;\n}\n\n.slider:before {\n    position: absolute;\n    content: \"\";\n    height: 13px;\n    width: 13px;\n    left: 2px;\n    bottom: 2px;\n    background-color: white;\n    -webkit-transition: .4s;\n    transition: .4s;\n}\n\n/* Remove all input default border and shadow in modify-menu*/\n\n#modify-menu input[type=text] {\n    outline-color: invert;\n    outline-style: none;\n    outline-width: 0px;\n    border: none;\n    border-style: none;\n    text-shadow: none;\n    -webkit-appearance: none;\n    -webkit-user-select: text;\n    outline-color: transparent;\n    box-shadow: none;\n    color: var(--context-button-color-inert);\n}\n\ninput:checked+.slider {\n    background-color: #2196F3;\n}\n\ninput:focus+.slider {\n    box-shadow: 0 0 1px #2196F3;\n}\n\ninput:checked+.slider:before {\n    -webkit-transform: translateX(13px);\n    -ms-transform: translateX(13px);\n    transform: translateX(13px);\n}\n\n.textarea {\n    color: white;\n    font-family: Arial;\n}\n.notifs {\n    background-color: #000000; /* black */\n    transform:translateX(48px);\n    position:fixed;\n    top:5px;\n    right:496px;\n    width:256px;\n    height:128px;\n}\n.logger {\n    background-color: #000000; /* black */\n    position:fixed;\n    width: 400px;\n    top:128px;\n    height:128px;\n}\n\n/* Rounded sliders */\n\n.slider.round {\n    border-radius: 17px;\n}\n\n.slider.round:before {\n    border-radius: 50%;\n}\n\n.switch+label {\n    cursor: pointer;\n    padding-top: 5px;\n    padding-bottom: 5px;\n}\n\n.filename {\n    color: #FFF;\n    padding-left: 3px;\n    vertical-align: top;\n    display: block;\n    font-weight: bold;\n    font-size: 1.2rem;\n}\n\ndiv.imgFolder {\n    text-align: center;\n    padding: 0.6em;\n}\n\ndiv.imgFolder > img {\n    max-width: 100%;\n    min-width: 2em;\n}\n\na.troubleshooter {\n    position: absolute;\n    top: 1rem;\n    /* top: calc(100% - 3em); */\n    display: inline-block;\n    right: 2em;\n    text-decoration: none;\n    color: white;\n    font-weight: bold;\n}\n\n.editor-menu {\n    display: initial !important;\n}\n\n.disabled {\n    color: #BBB;\n}\n\ninput.global-setting[type=checkbox] {\n    display: none;\n}\n\ninput.global-setting[type=checkbox]:checked+span.label-checkbox {\n    background: #bcbbff;\n}\n\nspan.label-checkbox {\n    padding: 2px;\n    border-radius: 10px;\n}\n\nspan.label-checkbox:hover {\n    background-color: rgba(0, 0, 0, 0.06);\n    cursor: pointer;\n}\n\n@keyframes spin {\n    from {\n        outline-color: #FAA;\n    }\n    33% {\n        outline-color: #AFA;\n    }\n    66% {\n        outline-color: #AAF;\n    }\n    to {\n        outline-color: #FAA;\n    }\n}\n\nspan#ambiguity-id {\n    color: #9dff00;\n    display: block;\n}\n\n.solution {\n    display: block;\n    padding: 3px;\n}\n\n.solution.selected {\n    background: rgba(255, 255, 255, 0.2);\n}\n\n.to-be-selected {\n    outline: #FCC 2px solid;\n    animation: spin 1s linear infinite;\n}\n\n.solution:not(.selected):hover {\n    background: rgba(255, 255, 255, 0.1);\n    cursor: pointer;\n}\n\n.solution.notfinal {\n    color: #f6f6aa;\n}\n\n.add {\n    background: lightgreen\n}\n\n.remove {\n    background: #f8a7a7;\n    text-decoration: line-through\n}\n\ndiv.disambiguationMenu {\n    height: 40%;\n    overflow-y: auto;\n    padding-left: 0.3em;\n    padding-top: 0.3em;\n    padding-bottom: 0.3em;\n    border: 2px solid #f6f6aa;\n}\n\n.codepreview {\n    font-family: monospace;\n    padding: 3px;\n    background: white;\n    color: black;\n    margin-left: 0.1em;\n}\n\n.solution:not(.selected) .codepreview {\n    background: rgba(255, 255, 255, 0.8);\n}\n\n#modify-menu button.modifyMenuButton {\n    background-color: var(--context-button-color);\n    min-height: var(--context-button-width);\n    color: var(--context-dom-text-color);\n    border-style: none;\n    margin-top: 5px;\n    padding: 0.4em;\n    font-weight: bold;\n    cursor: pointer;\n}\n\n#modify-menu button.modifyMenuButton:hover {\n    background-color: var(--context-button-color-hover);\n}\n\n#editor_codepreview, #manualsync-menuitem {\n    display: none;\n    z-index: 999;\n}\n\n[ghost-visible=true] {\n    display: initial !important;\n}\n\n[ghost-disabled=true] {\n    opacity: 0.5 !important;\n    cursor: initial;\n    pointer-events: none !important;\n}\n\n[ghost-disabled=false] {\n    opacity: 1 !important;\n    pointer-events: auto !important;\n}\n\n#manualsync-menuitem[ghost-disabled=false]>button {\n    cursor: pointer !important;\n    opacity: 1 !important;\n    pointer-events: auto !important;\n}\n\n#manualsync-menuitem[force-visible=true] {\n    display: initial;\n}\n\n[ghost-visible=false] {\n    display: none !important;\n}\n\n#manualsync-menuitem>button {\n    vertical-align: top;\n    opacity: 0.5;\n    cursor: initial;\n    pointer-events: none;\n}\n\n#editor_codepreview {\n    width: 100%;\n    height: 600px;\n}\n\n@media screen and (pointer: coarse) {\n    body {\n        font-size: 48px;\n    }\n    menu.edittoolbar {\n        right: 10px;\n    }\n    menuitem.filename {\n        display: none;\n    }\n    /*menuitem {\n      font-size: 2.5em;\n    }*/\n    button {\n        font-size: 1em;\n    }\n    menuitem#question-menuitem {\n        display: none;\n    }\n    menuitem#autosave-menuitem {\n        display: none;\n    }\n    #editor_codepreview {\n        width: 100%;\n        height: 600px;\n    }\n}\n\n.summary {\n    color: green;\n}\n\ndiv#modify-menu {\n    -webkit-box-shadow: 0px 0px 34px 0px rgba(0, 0, 0, 0.75);\n    -moz-box-shadow: 0px 0px 34px 0px rgba(0, 0, 0, 0.75);\n    box-shadow: 0px 0px 34px 0px rgba(0, 0, 0, 0.75);\n    position: fixed;\n    top: 0px;\n    right: 0px;\n    width: 400px;\n    height: 100%;\n    background-color: var(--context-color);\n    color: var(--context-dom-text-color);\n    padding: 5px;\n    font-size: 16px;\n    transform: translate(100%, 0px);\n    transition-property: transform;\n    transition-duration: 0.5s;\n    z-index: 100001;\n}\n\n.modify-menu-icon {\n    vertical-align: middle;\n    cursor: pointer;\n    width: var(--context-menu-button-width);\n}\n\n.modify-menu-icon:hover {\n    background-color: var(--context-button-color-hover);\n}\n\ndiv#modify-menu>div.modify-menu-icons:not(.pinned) {\n    width: 100%;\n    overflow-x: auto;\n    margin: 0.4rem;\n}\n\ndiv#modify-menu>div.modify-menu-icons.pinned {\n    width: var(--context-menu-button-width);\n    position: absolute;\n    left: calc(0px - var(--context-menu-button-width));\n}\n\ndiv#modify-menu>div.information {\n    overflow-y: auto;\n    max-height: calc(100% - var(--context-menu-height));\n    margin: 2%;\n    margin-top: 0;\n    border-radius: 0.3em;\n}\n\ndiv.#modify-menu>div.information-style {\n    padding: 0.4rem;\n}\n\n/* information part scroll bar */\n.information.information-style::-webkit-scrollbar {\n    background: transparent;\n    width: 8px;\n}\n\n.information.information-style::-webkit-scrollbar-thumb {\n    background: rgba(255, 255, 255, 0.5);\n    border-radius: 10px;\n}\n\ndiv.information>textarea {\n    font-size: 1em;\n}\n\ndiv#modify-menu.visible {\n    transform: translate(0%, 0%);\n}\n\ndiv#modify-menu h3 {\n    margin-top: 2px;\n    margin-bottom: 2px;\n}\n\ndiv#modify-menu div.keyvalues {\n    margin-top: 6px;\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue {\n    padding: 2px;\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-items: center;\n    width: 98%;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue .attribute-key-value {\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue .attribute-key {\n    width: 42%;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalueadder {\n    opacity: 0.5;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalueadder:hover {\n    opacity: 1;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalueadder .attribute-key-value{\n    display: flex;\n    flex-direction: row;\n}\n\ndiv#modify-menu input {\n    padding: 6px;\n    width: 100%;\n    color: black;\n}\n\ndiv#modify-menu .codefont {\n    font-size: 1.4em;\n    font-family: monospace;\n}\n\ndiv#modify-menu .tagname-input {\n    padding: 4px;\n    flex: 1;\n}\n\ndiv#modify-menu .tagname-input input {\n    display: inline-block;\n}\n\ndiv#modify-menu .tagname-info {\n    display: inline-block;\n    border-radius: 4px;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    background: transparent;\n    color: var(--context-dom-text-color);\n    flex: 2;\n    line-height: 3.5em;\n}\n\ndiv#modify-menu input[type=radio] {\n    width: initial;\n    font-size: 1em;\n}\n\ndiv#modify-menu span.insertOption {\n    display: block;\n}\n\ndiv.keyvalue>span>input {\n    border-radius: 4px;\n    margin: 2px;\n}\n\ndiv.tagname-summary {\n    display: flex;\n    background-color: var(--context-dom-selector-color);\n    border-radius: 0.4em;\n    padding: 4px;\n    margin: 2%;\n}\n\n.inline-input {\n    background: transparent;\n    color: var(--context-dom-text-color);\n    border: none;\n}\n\n/* dom selector css */\n\ndiv.dom-selector-style {\n    margin: 2%;\n    margin-bottom: 0;\n    border-radius: 0.4em;\n    padding: 0.4rem;\n}\n\ndiv.childrenElem {\n    display: flex;\n    height: 30px;\n    margin-top: 4px;\n}\n\ndiv.mainElemName {\n    color: var(--context-dom-text-color);\n    font-family: monospace;\n}\n\ndiv.childrenSelectorName {\n    font-family: monospace;\n}\n\ndiv.childrenSelector {\n    min-width: 50px;\n    position: relative;\n    flex: 1;\n    text-align: center;\n    overflow: hidden;\n    padding: 2px;\n    margin: 2px;\n    border-radius: 0.3rem;\n    background-color: var(--context-dom-children-selector-color);\n    transition: all 0.5s;\n    text-decoration: none;\n    cursor: pointer;\n}\n\ndiv.childrenSelector:hover {\n    -webkit-filter: contrast(125%);\n    /* Chrome, Opera */\n    -moz-filter: blur(125%);\n    -ms-filter: blur(125%);\n    filter: blur(125%);\n}\n\ndiv.mainElem {\n    height: 62px;\n    position: relative;\n    text-align: center;\n    overflow: hidden;\n    font-size: 1.3em;\n    text-overflow: ellipsis;\n}\n\ndiv.mainElemInfo {\n    font-size: 0.6em;\n    color: var(--context-dom-text-color);\n    height: 20px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\ndiv.childrenSelectorInfo {\n    text-overflow: ellipsis;\n    overflow: hidden;\n    color: var(--context-dom-text-color);\n    height: 38px;\n    font-size: 0.8em;\n}\n\ndiv.elementAttr {\n    margin-left: 6px;\n    display: inline-block;\n    font-size: 0.6em;\n    line-height: 1.02em;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    color: var(--context-dom-text-color);\n}\n\ndiv.no-children, div.no-parent {\n    background-color: transparent;\n    text-align: center;\n    text-transform: uppercase;\n    color: black;\n    border-radius: 0.3rem;\n    font-weight: bold;\n    line-height: 36px;\n    font-size: 0.8rem;\n    pointer-events: none;\n}\n\ndiv.no-children {\n    width: 100%;\n}\n\ndiv.no-sibling {\n    background-color: transparent;\n    color: black;\n    width: 20%;\n    text-transform: uppercase;\n    font-size: 0.7rem;\n    line-height: 20px;\n    font-weight: bold;\n    min-width: 50px;\n    pointer-events: none;\n}\n\n/* make button's text unselectable for better user experience */\n\n.noselect {\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -khtml-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n\n.selectedDom {\n    background-color: var(--context-dom-selector-color) !important;\n    border: none;\n}\n\n#upload-image-btn-a {\n    margin-left: 0;\n    margin-top: 10px;\n    margin-bottom: 10px;\n    height: 20px;\n    position: relative;\n    color: black;\n    background: transparent;\n    border-radius: 4px;\n    display: inline-block;\n    height: 20px;\n    width: 280px;\n}\n\n#upload-image-btn-input {\n    position: absolute;\n    top: -7px; /* alignment */\n    left: 0;\n    width: 100%;\n}\n\n/* highlight selected image */\n\ndiv.highlight-select-image {\n    border: 1px solid white;\n    border-radius: 0.76em;\n}\n\n:root {\n    --context-color: rgba(0, 128, 128, 0.8);\n    --context-color-next: rgba(0, 158, 158, 0.8);\n    --context-button-color: rgba(0, 192, 192, 0.8);\n    --context-button-color-hover: rgba(0, 232, 232, 0.8);\n    --context-button-color-inert: rgba(128, 128, 128, 0.8);\n    --context-button-color-inert-hover: rgba(150, 150, 150, 0.8);\n    --context-button-color-inert-active: rgba(182, 182, 182, 0.8);\n    --context-dom-selector-color: rgba(0, 212, 159, 0.8);\n    --context-dom-children-selector-color: rgba(0, 178, 179, 0.8);\n    --context-dom-text-color: whitesmoke;\n    --context-menu-height: 30px;\n    --context-menu-button-width: 40px;\n    --context-menu-padding-top: 0px;\n    --context-menu-padding-left: 0px;\n    --context-button-selected: rgba(0, 212, 212, 0.8);\n}\n\ndiv.tagName {\n    margin-top: 0.24rem;\n    /* padding: 4px; */\n    cursor: pointer;\n    /* background: var(--context-button-color); */\n    vertical-align: text-bottom;\n}\n\ndiv.tagName:hover {\n    background: var(--context-button-color-hover);\n}\n\n#customHTML {\n    height: 6%;\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n}\n\n[ghost-hovered=true] {\n    outline: 2px dashed var(--context-color-next);\n}\n\n[ghost-clicked=true] {\n    outline: 2px solid var(--context-color);\n}\n\ndiv#context-menu {\n    position: absolute;\n    display: none;\n    background-color: var(--context-color);\n    color: white;\n    font-weight: bold;\n    z-index: 1000000;\n}\n\ndiv#context-menu.visible {\n    display: block;\n    height: var(--context-menu-height);\n    width: 200px;\n}\n\ndiv#context-menu .context-menu-button, div#modify-menu .modify-menu-button, div#modify-menu .modify-menu-icons .context-menu-button {\n    background: var(--context-button-color);\n    display: inline-block;\n    width: var(--context-menu-button-width);\n    cursor: pointer;\n}\n\ndiv.modify-menu-icons:not(.pinned) > div.modify-menu-button {\n    background-color: transparent !important;\n    border-radius: 0.4rem;\n    margin-right: 0.2rem;\n}\n\ndiv.modify-menu-icons:not(.pinned) > div.modify-menu-button:hover {\n    background-color: var(--context-button-color) !important;\n}\n\ndiv#context-menu .context-menu-button, div#modify-menu .modify-menu-icons:not(.pinned) .modify-menu-button {\n    height: var(--context-menu-height);\n}\n\ndiv#modify-menu .modify-menu-icons.pinned .modify-menu-button {\n    border-bottom: 1px solid black;\n}\n\ndiv#modify-menu .modify-menu-icons.pinned .modify-menu-button:last-child {\n    border-bottom: none;\n}\n\ndiv#context-menu .context-menu-button.selected, div#modify-menu .modify-menu-button.selected {\n    background: var(--context-button-selected);\n}\n\ndiv#modify-menu .modify-menu-button.inert.active {\n    background: var(--context-button-color-inert-active)\n}\n\ndiv#modify-menu .modify-menu-button.disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\ndiv#modify-menu .modify-menu-icon-label {\n    display: block;\n    color: white;\n    font-size: calc(var(--context-menu-button-width) / 3);\n    text-align: center;\n}\n\ndiv#modify-menu .modify-menu-icon-label-link {\n    display: block;\n    color: white;\n    font-size: calc(var(--context-menu-button-width) / 4);\n    text-align: center;\n}\n\ndiv#context-menu .context-menu-button>svg, div#modify-menu .modify-menu-button>svg {\n    padding-left: var(--context-menu-padding-left);\n    padding-right: var(--context-menu-padding-left);\n    padding-top: var(--context-menu-padding-top);\n    padding-bottom: var(--context-menu-padding-top);\n}\n\ndiv#context-menu .context-menu-button.inert, div#modify-menu .modify-menu-icons.modify-menu-icons .modify-menu-button.inert {\n    background: var(--context-button-color-inert)\n}\n\nsvg.context-menu-icon>path {\n    fill: none;\n    stroke: #FFFFFF;\n    stroke-width: 2px;\n    stroke-linecap: butt;\n    -linejoin: miter;\n    stroke-opacity: 1;\n}\n\nsvg.context-menu-icon.fill>path {\n    fill: #FFFFFF;\n    fill-rule: evenodd;\n    stroke-width: 1px;\n}\n\ndiv#context-menu .context-menu-button:hover, div#modify-menu .modify-menu-button:hover:not(.disabled) {\n    background: var(--context-button-color-hover);\n}\n\ndiv#context-menu .context-menu-button.inert:hover, div#modify-menu .modify-menu-button.inert:hover:not(.disabled) {\n    background: var(--context-button-color-inert-hover)\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue #applyNewTagName {\n    display: none;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue #applyNewTagName.visible {\n    display: flex;\n    width: var(--context-menu-button-width);\n    padding: 4px;\n}\ndiv#modify-menu div.keyvalues>div.keyvalue #newTagName {\n    background: none;\n    color: white;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue #newTagName:focus {\n    background: white;\n    color: initial;\n}\n\n\ndiv#modify-menu div.keyvalues>div.keyvalue #applyNewTagName + div#newtagname-align-placeholder {\n  display: flex;\n  width: calc(var(--context-menu-button-width) - 8px);\n  padding: 4px;\n  margin: 2px;\n  border-radius: 4px;\n  border-width: 2px;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue #applyNewTagName.visible + div#newtagname-align-placeholder {\n  display: none;\n}\n\ntextarea#singleChildNodeContent {\n    width: 100%;\n    height: 50%;\n    border-radius: 0.4em;\n    border: 0;\n    margin-top: 6px;\n    padding: 10px;\n    color: black;\n}\n\ntextarea.templateengine {\n    width: 100%;\n    height: 100%;\n    color: black;\n    border-radius: 0.4rem;\n    border: 0;\n    padding: 0.4rem;\n    font: normal 0.84rem Consolas, Monaco, monospace;\n    resize: none;\n    opacity: 0.8;\n}\n\ntextarea.templateengine:focus {\n    outline: none;\n    opacity: 1;\n}\n\n#modify-menu span.insertOption label {\n  display: inline-block;\n}\n\n@media (pointer: coarse) {\n    div#modify-menu {\n        -webkit-box-shadow: none;\n        -moz-box-shadow: none;\n        box-shadow: none;\n        /* font-size: 48px; */\n        bottom: 0px;\n        left: 0px;\n        top: initial;\n        right: initial;\n        height: 40%;\n        width: 100%;\n        min-height: 350px;\n        transform: translate(0px, 100%);\n        padding: 0;\n        padding-bottom: 80px;\n    }\n    div#modify-menu>div.modify-menu-icons.pinned {\n        width: auto;\n        height: var(--context-menu-height);\n        position: absolute;\n        top: calc(0px - var(--context-menu-height));\n        left: 0px;\n    }\n    div#modify-menu>div.modify-menu-icons.pinned span.modify-menu-icon-label {\n        display: none;\n    }\n    div#modify-menu>div.modify-menu-icons.pinned >div.modify-menu-button {\n        height: 50px;\n    }\n    div#modify-menu>div.modify-menu-icons.pinned svg {\n        height: 50px;\n    }\n    div.bottom-placeholder {\n        width: 100%;\n        height: 30%;\n    }\n    :root {\n        --context-menu-height: 48px;\n        --context-menu-button-width: 48px;\n        --context-menu-padding-top: 9px;\n        --context-menu-padding-left: 4px;\n    }\n    /* mobile dom selector */\n    div.dom-selector-style {\n        height: 45%;\n        margin: 0.15em;\n        border-radius: 0.4em;\n        margin: 2%;\n    }\n    div.elementAttr {\n        display: none;\n    }\n    div.mainElem {\n        margin-bottom: 0;\n        height: 40%;\n    }\n    div.childrenSelector {\n        padding: 6px;\n        font-size: 1.2em;\n    }\n    div.no-sibling {\n        font-size: 1em;\n        padding-top: 20px;\n    }\n    /* mobile modify menu */\n    div.tagname-summary {\n        padding-left: 10px;\n    }\n    div.information {\n        margin: 2%;\n        margin-top: 0;\n        height: 215px;\n        overflow-y: auto;\n    }\n    div.information>textarea {\n        font-size: 1.2em;\n        border-radius: 0.3em;\n        border: none;\n        padding: 1.5%;\n    }\n    textarea.templateengine {\n        width: 100%;\n        height: 100%;\n        color: black;\n        font-size: 1.4rem;\n        border-radius: 0.4rem;\n        border: 0;\n        padding: 0.4rem;\n    }\n    div.insert-information-style {\n        max-height: 400px;\n        height: 400px;\n    }\n    div.insert-information-style>h1 {\n        margin: 0;\n    }\n}</style> :: headChildren)]\n      x -> x -- head\n    )]\n  x-> <html><head></head><body>Not a valid html page: @(\"\"\"@x\"\"\")</body></html>\n  --|> Update.debug \"main\"\n\ninsertedElementsToWriteFile = List.map <| case of\n   [_, [[\"class\", \"file-overwrite\"], [\"name\", name], [\"oldcontent\", oldcontent], [\"newcontent\", newcontent]], _] ->\n     (name, Write oldcontent newcontent (Update.diffs oldcontent newcontent |> Maybe.withDefault (VStringDiffs [])))\n   thisInstead ->\n     error \"\"\"In #editor-files-to-overwrite, you should put attributes class=\"file-overwrite\" name=\"[full path name]\" oldcontent=\"[old file content]\" newcontent=\"[new file content]\"> in this order (even call the funciton addFileToSave(name, oldContent, newContent) fo simplicity. Got @thisInstead\"\"\"\n\n-- Returns an empty list. If elements are inserted, inserts them in the given list instead.\ninsertThereInstead onInsert atBeginning list =\n  Update.lens {apply _ = [],\n    update {outputNew, input=list} =\n      Ok (InputsWithDiffs [(if atBeginning then onInsert outputNew ++ list else list ++ onInsert outputNew, Just <|\n        VListDiffs [(if atBeginning then 0 else List.length list, ListElemInsert (List.length outputNew))]\n      )])\n  } list\n\n{---------------------------------------------------------------------------\n Definitions for the pipeline above\n----------------------------------------------------------------------------}\n  \n-- Box to switch to edit mode.\nswitchEditBox toEdit = \n  let prev = if toEdit then \"false\" else \"true\"\n      next = if toEdit then \"true\" else \"false\"\n      msg = if toEdit then \"edit\" else \"x\"\n      title = if toEdit then \"Reload the page in edit mode\" else \"Reload the page without edit mode\" in\n<div id=\"editbox\" title=@title onclick=\"\"\"\n if(location.search.indexOf(\"edit=@prev\") == -1) {\n   location.search = location.search.startsWith(\"?\") ? location.search + \"&edit=@next\" : \"?edit=@next\"\n } else {\n   location.search = location.search.replace(/edit=@prev/, \"edit=@next\");\n }\n\"\"\">\n<style>#editbox {\n  @(if toEdit then \"\"\"position: fixed;\n  margin-top: 2px;\n  margin-left: 2px;\n  background: white;\n  padding: 2px;\n  border-radius: 10px;\n  transform: scale(0.6);\n  \"\"\" else \"\"\"position: absolute;\n  color: white;\n  background: black;\n  font-family: 'Helvetica', 'Arial', sans-serif;\n  font-size: 2em;\n  font-weight: bold;\n  text-align: center;\n  width: 40px;\n  height: 40px;\n  border-radius: 5px;\n  transform: translate(-0.7em, -0.7em) scale(0.3);\n  \"\"\"\n )z-index: 20000;\n  opacity: 0.5;\n  cursor: pointer;\n}\n#editbox:hover {\n  opacity: 1;\n  \n</style>@msg\n</div>\n\nopenEditBox = switchEditBox True\ncloseEditBox = switchEditBox False\n\nboolToCheck = Update.bijection (case of \"true\" -> [[\"checked\", \"\"]]; _ -> []) (case of [[\"checked\", \"\"]] -> \"true\"; _ -> \"false\")\n\n-- Everything inside the modify menu is generated and is not visible to Editor\neditionmenu thesource = [\n<div id=\"modify-menu\" list-ghost-attributes=\"style class\" sourcecontent=@thesource contenteditable=\"false\" children-are-ghosts=\"true\"></div>,\n<div id=\"context-menu\" children-are-ghosts=\"true\" list-ghost-attributes=\"style class\" contenteditable=\"false\"></div>,\nif iscloseable then <span dummy=\"\"></span> else closeEditBox]\n\ninitialScript = serverOwned \"initial script\" [\n<script>\n\n// TODO: Find a way to store a cookie containing credentials, and have this server refresh tokens.\n// https://developers.google.com/identity/sign-in/web/server-side-flow\n// https://stackoverflow.com/questions/32902734/how-to-make-google-sign-in-token-valid-for-longer-than-1-hour\n// https://www.w3schools.com/js/js_cookies.asp\nif(typeof googleAuthIdToken == \"undefined\") {\n  var googleAuthIdToken = undefined;\n}\n\nfunction isGhostNode(elem) {\n  return elem && elem.nodeType == 1 &&\n    (elem.tagName == \"GHOST\" || elem.getAttribute(\"isghost\") == \"true\");\n}\n\nfunction areChildrenGhosts(n) {\n  return n && n.getAttribute && (\n    n.getAttribute(\"children-are-ghosts\") == \"true\" ||\n    n.getAttribute(\"children-are-ghost\") == \"true\"\n  );\n}\nfunction hasGhostAncestor(htmlElem) {\n  if(htmlElem == null) return false;\n  if(isGhostNode(htmlElem)) return true;\n  return areChildrenGhosts(htmlElem.parentNode) || (htmlElem.parentNode == null && htmlElem.nodeType !== 9 /*document*/) || hasGhostAncestor(htmlElem.parentNode);\n}\nfunction isGhostAttributeKey(name) {\n  return name.startsWith(\"ghost-\");\n}\n\n// Editor's API is stored in the variable editor.\n\neditor = typeof editor === \"object\" ? editor : {};\n\n// Array of functions on nodes returning an array of attributes that should be ghosts (i.e. removed on back-propagation)\neditor.ghostAttrs = [];\neditor.ghostAttrs.push(n =>\n  ((n && n.getAttribute && n.getAttribute(\"list-ghost-attributes\")) || \"\").split(\" \").concat(\n    ((n && n.getAttribute && n.getAttribute(\"save-ghost-attributes\")) || \"\").split(\" \")).filter(a => a != \"\")\n);\neditor.ghostAttrs.push(n =>\n  n && n.tagName == \"HTML\" ? [\"class\"] : []\n);\neditor.ghostAttrs.push(n =>\n  n && n.tagName == \"BODY\" ? [\"data-gr-c-s-loaded\"] : []\n);\n// attribute of some chrome extensions\neditor.ghostAttrs.push(n => [\"bis_skin_checked\"]);\n\n// Array of functions on nodes returning an array of attributes that should be ignored (i.e. old value returned on back-propagation)\neditor.ignoredAttrs = [];\neditor.ignoredAttrs.push(n =>\n  ((n && n.getAttribute && n.getAttribute(\"list-ignored-attributes\")) || \"\").split(\" \").concat(\n    ((n && n.getAttribute && n.getAttribute(\"save-ignored-attributes\")) || \"\").split(\" \")).filter(a => a != \"\")\n)\n\nfunction isSpecificGhostAttributeKeyFromNode(n) {\n  var additionalGhostAttributes = [];\n  for(var k in editor.ghostAttrs) {\n    additionalGhostAttributes = additionalGhostAttributes.concat(editor.ghostAttrs[k](n))\n  }\n  return (a => name => a.indexOf(name) != -1)(additionalGhostAttributes);\n}\n\nfunction isIgnoredAttributeKeyFromNode(n) {\n  var additionalIgnoredAttributes = [];\n  for(var k in editor.ignoredAttrs) {\n    additionalIgnoredAttributes = additionalIgnoredAttributes.concat(editor.ignoredAttrs[k](n))\n  }\n  return ((a, n) => (name, oldValue) => {\n    let result = a.indexOf(name) != -1;\n    if(result) { // let's store the previous attribute's value\n      n.__editor__ = n.__editor__ || {};\n      n.__editor__.ignoredAttrMap = n.__editor__.ignoredAttrMap || {};\n      if(!(name in n.__editor__.ignoredAttrMap) && typeof oldValue !== \"undefined\") {\n        n.__editor__.ignoredAttrMap[name] = oldValue;\n      }\n    }\n    return result;\n  })(additionalIgnoredAttributes, n);\n}\nfunction ignoredAttributeValue(n, name) {\n  let result = n.__editor__.ignoredAttrMap[name];\n  if(typeof result === \"undefined\") {\n    return n.getAttribute(name);\n  }\n  return result;\n}\n\n// Array of predicates that, if they return true on a node, Editor will mark this node as ghost.\neditor.ghostNodes = [];\n\n// Analytics scripts\neditor.ghostNodes.push(insertedNode =>\n  insertedNode.tagName == \"SCRIPT\" && typeof insertedNode.getAttribute(\"src\") == \"string\" &&\n     (insertedNode.getAttribute(\"src\").indexOf(\"google-analytics.com/analytics.js\") != -1 ||\n      insertedNode.getAttribute(\"src\").indexOf(\"google-analytics.com/gtm/js\") != -1 ||\n      insertedNode.getAttribute(\"src\").indexOf(\"googletagmanager.com/gtm.js\") != -1)\n);\n\n// For for ace styles in header\neditor.ghostNodes.push(insertedNode => {\n    if(insertedNode.tagName == \"STYLE\" && typeof insertedNode.getAttribute(\"id\") == \"string\" &&\n     (insertedNode.getAttribute(\"id\").startsWith(\"ace-\") ||\n      insertedNode.getAttribute(\"id\").startsWith(\"ace_\"))) {\n      insertedNode.setAttribute(\"save-ghost\", \"true\"); \n      return true;\n    } else {\n      return false;\n    }\n  }\n);\n// For Google sign-in buttons and i-frames\neditor.ghostNodes.push(insertedNode =>\n  (insertedNode.tagName == \"DIV\" &&\n    insertedNode.classList.contains(\"abcRioButton\")) ||\n  (insertedNode.tagName == \"IFRAME\" &&\n    insertedNode.getAttribute(\"id\") == \"ssIFrame_google\")\n);\n// For anonymous styles inside HEAD (e.g. ace css themes and google sign-in)\n editor.ghostNodes.push(insertedNode => \n   insertedNode.tagName == \"STYLE\" && insertedNode.getAttribute(\"id\") == null && insertedNode.attributes.length == 0 &&\n   insertedNode.parentElement.tagName == \"HEAD\" && typeof insertedNode.isghost === \"undefined\"&& insertedNode.textContent.match(\"error_widget\\\\.ace_warning\")\n   && (insertedNode.setAttribute(\"save-ghost\", \"true\") || true)\n );\n// For ace script for syntax highlight\neditor.ghostNodes.push(insertedNode =>\n  insertedNode.tagName == \"SCRIPT\" && typeof insertedNode.getAttribute(\"src\") == \"string\" &&\n     insertedNode.getAttribute(\"src\").startsWith(\"https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.2/mode-j\")\n);\n// For ace script for syntax highlight\neditor.ghostNodes.push(insertedNode =>\n  insertedNode.tagName == \"ACE_OUTER\"\n);\n// For the grammarly extension\neditor.ghostNodes.push(insertedNode =>\n  insertedNode.nodeType === 1 && insertedNode.matches(\".gr-top-z-index, .gr-top-zero\")\n);\n\nfunction handleScriptInsertion(mutations) {\n  for(var i = 0; i < mutations.length; i++) {\n    // A mutation is a ghost if either\n    // -- The attribute starts with 'ghost-'\n    // -- It is the insertion of a node whose tag is \"ghost\" or that contains an attribute \"isghost=true\"\n    // -- It is the modification of a node or an attribute inside a ghost node.\n    var mutation = mutations[i];\n    if(hasGhostAncestor(mutation.target)) continue;\n    if(mutation.type == \"childList\") {\n      for(var j = 0; j < mutation.addedNodes.length; j++) {\n        var insertedNode = mutation.addedNodes[j];\n        if(!hasGhostAncestor(insertedNode) && typeof insertedNode.isghost === \"undefined\" && (insertedNode.nodeType == 1 && insertedNode.getAttribute(\"isghost\") != \"true\" || insertedNode.nodeType == 3 && !insertedNode.isghost) && editor.ghostNodes.find(pred => pred(insertedNode, mutation))) {\n         if(insertedNode.nodeType == 1) insertedNode.setAttribute(\"isghost\", \"true\");\n         insertedNode.isghost = true;\n        } else { // Record ignored attributes\n          if(insertedNode.nodeType == 1) {\n            var isIgnoredAttributeKey = isIgnoredAttributeKeyFromNode(insertedNode);\n            for(var k = 0; k < insertedNode.attributes.length; k++) {\n              var attr = insertedNode.attributes[k];\n              isIgnoredAttributeKey(attr.name, attr.value);\n            }\n          }\n        }\n      }\n    }\n    \n  }\n}\n\nif (typeof automaticGhostMarker !== \"undefined\") {\n  // console.log(\"automaticGhostMarker.disconnect()\");\n  automaticGhostMarker.disconnect();\n}\n\nautomaticGhostMarker = new MutationObserver(handleScriptInsertion);\nautomaticGhostMarker.observe\n ( document.head.parentElement\n , { attributes: false\n   , childList: true\n   , characterData: false\n   , attributeOldValue: false\n   , characterDataOldValue: false\n   , subtree: true\n   }\n )\n\n// Self-editing capabilities\nfunction getSelectionStart() {\n   var node = document.getSelection().anchorNode;\n   return (node != null && node.nodeType == 3 ? node.parentNode : node);\n}\n// Returns the closest ancestor of the selection having the given tagName\nfunction getEnclosingCaret(tagName) {\n  var w = getSelectionStart();\n  while(w != null && w.tagName.toLowerCase() != tagName.toLowerCase()) {\n    w = w.parentNode;\n  }\n  return w;\n}\n\n// Removes all the text from a node (not the text nodes themselves)\nfunction emptyTextContent(node) {\n  if(node != null) {\n    if(node.nodeType == 3) {\n      node.textContent = \"\";\n    } else {\n      for(i in node.childNodes) {\n        emptyTextContent(node.childNodes[i]);\n      }\n    }\n  }\n  return node;\n}\neditor.emptyTextContent = emptyTextContent;\n\nfunction insertBefore(parent, node, beforeNode) {\n  if(beforeNode == null) {\n    parent.append(node);\n  } else {\n    parent.insertBefore(node, beforeNode);\n  }\n}\n\nfunction duplicate(node, options) {\n  if(typeof options == \"undefined\") options = {}\n  if(typeof options.onBeforeInsert != \"function\") options.onBeforeInsert = e => e;\n  if(node != null && node.parentNode != null) {\n    var parentInsertion = options.target ? options.target.parentElement : node.parentElement;\n    var insertBeforeNode = options.after ? options.target ? options.target.nextSibling : node.nextSibling :\n                                           options.target ? options.target             : node;\n    if(node.nextSibling != null && !options.target && !options.ignoreText) {\n      var next = node.nextSibling;\n      if(next.nodeType == 3 && next.nextSibling != null &&\n         next.nextSibling.tagName == node.tagName && (node.tagName == \"TR\" || node.tagName == \"TH\" || node.tagName == \"LI\" || node.tagName == \"TD\")) {\n        var textElement = next.cloneNode(true);\n        insertBefore(node.parentNode, textElement, options.after ? node.nextSibling : node);\n        if(options.after) {\n          insertBeforeNode = textElement.nextSibling;\n        } else {\n          insertBeforeNode = textElement\n        }\n      }\n    }\n    var cloned = options.onBeforeInsert(node.cloneNode(true));\n    insertBefore(parentInsertion, cloned, insertBeforeNode);\n    return cloned;\n  }\n}\neditor.duplicate = duplicate;\n\nfunction remove(node, options) {\n  if(typeof options == \"undefined\") options = {}\n  if(node.previousSibling != null && !options.ignoreText) { // Remove whitespace as well\n    var next = node.nextSibling;\n    if(next.nodeType == 3 && next.nextSibling != null &&\n       next.nextSibling.tagName == node.tagName && (node.tagName == \"TR\" || node.tagName == \"TH\" || node.tagName == \"LI\" || node.tagName == \"TD\")) {\n      next.remove();\n    }\n  }\n  node.remove();\n}\neditor.remove = remove;\n</script>\n]\n\n-- Script added to the end of the page\nlastEditScript = \"\"\" \n    console.log(\"lastEditScript running\");\n     var onMobile = () => window.matchMedia(\"(pointer: coarse)\").matches;\n    var buttonHeight = () => onMobile() ? 48 : 30;\n    var buttonWidth  = () => onMobile() ? 48 : 40;\n    \n    // Before saving, call this function to that it eventually triggers a save action to any file.\n    function addFileToSave(path, oldcontent, newcontent) {\n      var placement = document.querySelector(\"#editor-files-to-overwrite\");\n      if(!placement) {\n        console.log(\"could not save file \" + name + \"because #editor-files-to-overwrite not found.\");\n        return;\n      }\n      placement.append(el(\"div\", {class: \"file-overwrite\", name:path, oldcontent: oldcontent, newcontent: newcontent}));\n    }\n    \n    // Save/Load ghost attributes after a page is reloaded, only if elements have an id.\n    // Same for some attributes\n    function saveGhostAttributes() {\n      var ghostModified = document.querySelectorAll(\"[ghost-visible]\");\n      var savedGhostAttributes = [];\n      for(var i = 0; i < ghostModified.length; i++) {\n        var elem = ghostModified[i];\n        savedGhostAttributes.push([editor.toTreasureMap(elem),\n            \"ghost-visible\", ghostModified[i].getAttribute(\"ghost-visible\")]);\n      }\n      function saveAttributes(name) {\n         var ghostAttributesModified = document.querySelectorAll(\"[\"+name+\"]\");\n        for(var i = 0; i < ghostAttributesModified.length; i++) {\n          var elem = ghostAttributesModified[i];\n          var toSave = elem.getAttribute(name).split(\" \");\n          for(j in toSave) {\n            var key = toSave[j];\n            savedGhostAttributes.push([editor.toTreasureMap(elem), key, elem.getAttribute(key)]);\n          }\n        }\n      }\n      saveAttributes(\"save-ghost-attributes\");\n      saveAttributes(\"save-ignored-attributes\");  \n      \n      var elemsWithAttributesToSave = document.querySelectorAll(\"[save-properties]\");\n      var savedProperties = [];\n      for(var i = 0; i < elemsWithAttributesToSave.length; i++) {\n        var elem = elemsWithAttributesToSave[i];\n        var toSave = elem.getAttribute(\"save-properties\").split(\" \");\n        for(j in toSave) {\n          var key = toSave[j];\n          savedProperties.push([dataToRecoverCaretPosition(elem), key, elem[key]])\n        }\n      }\n      var ghostElemsToReinsert = document.querySelectorAll(\"[save-ghost]\");\n      var parentsGhostNodes = [];\n      for(var i = 0; i < ghostElemsToReinsert.length; i++) {\n        var elem = ghostElemsToReinsert[i];\n        parentsGhostNodes.push({parent: editor.toTreasureMap(elem.parentNode), node: elem});\n      }\n      return [savedGhostAttributes, savedProperties, parentsGhostNodes];\n    }\n    function applyGhostAttributes(attrs) {\n      var [savedGhostAttributes, savedProperties, parentsGhostNodes] = attrs;\n      for(var i in savedGhostAttributes) {\n        var [data, key, attr] = savedGhostAttributes[i];\n        var elem = editor.fromTreasureMap(data);\n        if(elem != null) {\n          elem.setAttribute(key, attr);\n        }\n      }\n      for(var i in savedProperties) {\n        var [data, key, value] = savedProperties[i];\n        var elem = editor.fromTreasureMap(id);\n        if(elem != null) {\n          elem[key] = value;\n        }\n      }\n      for(var i in parentsGhostNodes) {\n        var {parent: data, node: elem} = parentsGhostNodes[i];\n        var parent = editor.fromTreasureMap(data);\n        if(parent != null) {\n          if(!elem.getAttribute(\"id\") || !document.getElementById(elem.getAttribute(\"id\"))) {\n            parent.appendChild(elem);\n          }\n        }\n      }\n    }\n   \n    \n    function domNodeToNativeValue(n) {\n      if(n.nodeType == 3) {\n        return [\"TEXT\", n.textContent];\n      } else if(n.nodeType == 8) {\n        return [\"COMMENT\", n.textContent];\n      } else {\n        var attributes = [];\n        var isSpecificGhostAttributeKey = isSpecificGhostAttributeKeyFromNode(n);\n        var isIgnoredAttributeKey =  isIgnoredAttributeKeyFromNode(n); // TODO recover ignored value\n        for(var i = 0; i < n.attributes.length; i++) {\n          var key = n.attributes[i].name;\n          if(!isGhostAttributeKey(key) && !isSpecificGhostAttributeKey(key)) {\n            var value = isIgnoredAttributeKey(key) ? ignoredAttributeValue(n, key) : n.attributes[i].value;\n            if(key == \"style\") {\n              value = value.split(\";\").map(x => x.split(\":\")).filter(x => x.length == 2)\n            }\n            attributes.push([key, value]);\n          }\n        }\n        var children = [];\n        var childNodes = n.childNodes;\n        if(n.tagName.toLowerCase() === \"noscript\" && n.childNodes.length === 1 && n.childNodes[0].nodeType === 3) {\n          // We'll recover the associated HTML node\n          childNodes = el(\"div\", {}, [], {innerHTML: n.childNodes[0].textContent, parentNode: n}).childNodes;\n        }\n        if(!areChildrenGhosts(n)) {\n          for(i = 0; i < childNodes.length; i++) {\n            if(!isGhostNode(childNodes[i])) {\n              children.push(domNodeToNativeValue(childNodes[i]));\n            }\n          }\n        }\n        return [n.tagName.toLowerCase(), attributes, children];\n      }\n    }\n    function saveDisplayProperties() {\n      let singleChildNodeContent = document.querySelector(\"textarea#singleChildNodeContent\");\n      if(singleChildNodeContent) {\n        editor_model.textareaScroll = singleChildNodeContent.scrollTop;\n        editor_model.textareaSelectionStart = singleChildNodeContent.selectionStart;\n        editor_model.textareaSelectionEnd = singleChildNodeContent.selectionEnd;\n      }\n    }\n    function replaceContent(NC) {\n      saveDisplayProperties();\n      if(editor_model.caretPosition) {\n        editor_model.caretPosition = dataToRecoverCaretPosition(editor_model.caretPosition);\n      }\n      if(editor_model.selectionRange) {\n        editor_model.selectionRange = dataToRecoverSelectionRange(editor_model.selectionRange);\n      }\n      if(editor_model.clickedElem) {\n        editor_model.clickedElem = editor.toTreasureMap(editor_model.clickedElem);\n      }\n      writeDocument(NC);\n    }\n    \n    var t = undefined;\n    \n    onResponse = (xmlhttp) => function() {\n      if(xmlhttp.readyState == XMLHttpRequest.DONE) {\n        replaceContent(xmlhttp.responseText);\n      }\n    }\n    \n    handleServerPOSTResponse = (xmlhttp, onBeforeUpdate) => function () {\n        if (xmlhttp.readyState == XMLHttpRequest.DONE) {\n          editor_model.isSaving = false;\n          if(typeof onBeforeUpdate !== \"undefined\") onBeforeUpdate();\n          var saved = saveGhostAttributes();\n          \n          //source of the editing menu disappearing after reloading\n          replaceContent(xmlhttp.responseText);\n          \n          applyGhostAttributes(saved);\n          var newLocalURL = xmlhttp.getResponseHeader(\"New-Local-URL\");\n          var newQueryStr = xmlhttp.getResponseHeader(\"New-Query\");\n          var ambiguityKey = xmlhttp.getResponseHeader(\"Ambiguity-Key\");\n          var ambiguityNumber = xmlhttp.getResponseHeader(\"Ambiguity-Number\");\n          var ambiguitySelected = xmlhttp.getResponseHeader(\"Ambiguity-Selected\");\n          var ambiguityEnd = xmlhttp.getResponseHeader(\"Ambiguity-End\");\n          var ambiguitySummaries = xmlhttp.getResponseHeader(\"Ambiguity-Summaries\");\n          if(ambiguityKey !== null && typeof ambiguityKey != \"undefined\" &&\n             ambiguityNumber !== null && typeof ambiguityNumber != \"undefined\" &&\n             ambiguitySelected !== null && typeof ambiguitySelected != \"undefined\") {\n            var n = JSON.parse(ambiguityNumber);\n            console.log (\"handleServerPOSTResponse ambiguity\");\n            var selected = JSON.parse(ambiguitySelected);\n            var summaries = JSON.parse(ambiguitySummaries);\n            \n            var disambiguationMenuContent = [];\n            disambiguationMenuContent.push(el(\"span#ambiguity-id\", {v: ambiguityKey}, \"Choose the update you prefer, and click the save button:\"));\n            // Find the common path of all files so that we don't need to repeat its name or path.\n            var fileOf = x => x.replace(/^(.*): *\\n[\\s\\S]*$/, \"$1\")\n            var commonPrefix = fileOf(summaries[1]);\n            for(var i = 1; i <= n; i++) {\n              while(!fileOf(summaries[i - 1]).startsWith(commonPrefix)) {\n                let n = commonPrefix.replace(/^(.*)(?:\\/|\\\\).*$/, \"$1\");\n                commonPrefix = n === commonPrefix ? \"\" : n;\n              }\n            }\n            if(commonPrefix) {\n              disambiguationMenuContent.push(el(\"span#ambiguity-prefix\", {}, commonPrefix + \":\"));\n            }\n            for(var i = 1; i <= n; i++) {\n              var summary = summaries[i-1].substring(commonPrefix.length).\n                    replace(/\"/g,'&quot;').\n                    replace(/</g, \"&lt;\").\n                    replace(/---\\)|\\+\\+\\+\\)/g, \"</span>\").\n                    replace(/\\(---/g, \"<span class='remove'>\").\n                    replace(/\\(\\+\\+\\+/g, \"<span class='add'>\").\n                    replace(/(\\nL\\d+C\\d+:)(.*)/, \"$1<span class='codepreview'>$2</span>\");\n              disambiguationMenuContent.push(el(\"span.solution\" + (i == selected ? \".selected\" : \"\") + (i == n && ambiguityEnd != 'true' ? '.notfinal' : ''), {\n              title: i == selected ? \"Currently displaying this solution\" : \"Select this solution\" + (i == n && ambiguityEnd != 'true' ? \" (compute further solutions after if any)\" : \"\"), onclick: i == selected ? `` : `this.classList.add('to-be-selected'); selectAmbiguity('${ambiguityKey}', ${i})`}, \"\", {innerHTML: \"#\" + i + \" \" + summary}));\n            }\n            //disambiguationMenuContent.push(el(\"button.modifyMenuButton#cancelAmbiguity\", {title: \"Revert to the original version\", onclick: `cancelAmbiguity(\"${ambiguityKey}\", ${selected})`}, \"Cancel\"));\n            editor_model.disambiguationMenu = el(\"div.disambiguationMenu\", {}, disambiguationMenuContent);\n            editor_model.disambiguationMenu.ambiguityKey = ambiguityKey;\n            editor_model.disambiguationMenu.selected = selected;\n            editor_model.clickedElem = undefined;\n            editor_model.displayClickedElemAsMainElem = true;\n            editor_model.notextselection = false;\n            editor_model.caretPosition = undefined;\n            editor_model.link = undefined;\n            editor_model.advanced = true; // Opens advanced mode.\n            editor_model.visible = true;\n            //editor_model.displaySource: false, // Keep source opened or closed\n            // TODO: Disable click or change in DOM until ambiguity is resolved.\n          } else { //no ambiguity\n            editor_model.disambiguationMenu = undefined;\n            let opSummaryEncoded = xmlhttp.getResponseHeader(\"Operations-Summary\");\n            if(opSummaryEncoded) {\n              var opSummary = decodeURI(opSummaryEncoded);\n              let newMenu = el(\"menuitem#lastaction\", {},\n                  el(\"span.summary\", {}, \"Last action: \" + opSummary)) \n              editor_model.feedback = newMenu;\n              var newmenutimeout = setTimeout(function() { editor_model.feedback = undefined; newMenu.remove(); }, 2000);\n              newMenu.onclick = ((n) => () => clearTimeout(n))(newmenutimeout);\n            }\n          } // /noambiguity\n          var strQuery = \"\";\n          if(newQueryStr != null) { //newQueryStr = undefined ==> (newQueryStr !== null) ==> false;\n            var newQuery = JSON.parse(newQueryStr);\n            for(var i = 0; i < newQuery.length; i++) {\n              var {_1: key, _2: value} = newQuery[i];\n              strQuery = strQuery + (i == 0 ? \"?\" : \"&\") + key + (value === \"\" && key == \"edit\" ? \"\" : \"=\" + value)\n            } \n          }\n          if(newLocalURL) { // Overrides query parameters\n            window.history[xmlhttp.replaceState ? \"replaceState\" : \"pushState\"]({localURL: newLocalURL}, \"Nav. to \" + newLocalURL, newLocalURL);\n          } else if(strQuery) {\n            window.history.replaceState({}, \"Current page\", strQuery);\n          }\n          updateInteractionDiv(); \n        } //xhr.onreadystatechange == done\n    } //handleServerPOSTResponse\n    \n    window.onpopstate = function(e){\n        console.log(\"onpopstate\", e);\n        if(e.state && e.state.localURL) {\n          navigateLocal(location, true);\n        } else {\n          navigateLocal(location.pathname + location.search, true);\n        }\n    };\n    \n    notifyServer = callback => {\n      var xmlhttp = new XHRequest();\n      xmlhttp.onreadystatechange = handleServerPOSTResponse(xmlhttp);\n      xmlhttp.open(\"POST\", location.pathname + location.search);\n      xmlhttp.setRequestHeader(\"Content-Type\", \"application/json\");\n      if(googleAuthIdToken) {\n        xmlhttp.setRequestHeader(\"id-token\", googleAuthIdToken)\n      }\n      var result = callback(xmlhttp);\n      xmlhttp.send(result || \"{\\\"a\\\":1}\");\n    }\n    \n    function reloadPage() { // Use this only after a successful login\n      notifyServer(xmlhttp => {\n        xmlhttp.setRequestHeader(\"reload\", \"true\");\n      })\n    }\n    function relativeToAbsolute(url) {\n      if(isAbsolute(url) || url && url.length && url[0] == \"/\") return url;\n      let u =  new URL(location.href);\n      if(url[0] === \"#\") {\n        return u.pathname + url; \n      }\n      else {\n        return u.pathname.replace(/[^\\/]*$/, \"\") + url;\n      }\n    }\n    function navigateLocal(url, replaceState) {\n      notifyServer(xmlhttp => {\n        xmlhttp.setRequestHeader(\"reload\", \"true\");\n        xmlhttp.setRequestHeader(\"url\", url);\n        console.log(\"setting url to \", url);\n        xmlhttp.replaceState = replaceState;\n      });\n    }\n    \n    function selectAmbiguity(key, num) {\n      notifyServer(xmlhttp => {\n        xmlhttp.setRequestHeader(\"ambiguity-key\", key);\n        xmlhttp.setRequestHeader(\"select-ambiguity\", JSON.stringify(num));\n        xmlhttp.setRequestHeader(\"question\", \"true\");\n      });\n    }\n    \n    function acceptAmbiguity(key, num) {\n      notifyServer(xmlhttp => {\n        xmlhttp.setRequestHeader(\"ambiguity-key\", key);\n        xmlhttp.setRequestHeader(\"accept-ambiguity\", JSON.stringify(num));\n      });\n    }\n    \n    function cancelAmbiguity(key, num) {\n      notifyServer(xmlhttp => {\n        xmlhttp.setRequestHeader(\"ambiguity-key\", key);\n        xmlhttp.setRequestHeader(\"cancel-ambiguity\", JSON.stringify(num));\n      });\n    }\n    \n    function sendModificationsToServer() {\n      \n      if(document.getElementById(\"notification-menu\") != null) {\n        //document.getElementById(\"notification-menu\").innerHTML = `cannot send the server more modifications until it resolves these ones. Refresh the page?`\n        // TODO: Listen and gather subsequent modifications when it is loading\n        return;\n      }\n      editor_model.isSaving = true;\n      var newMenu = el(\"menuitem#notification-menu.to-be-selected\", {isghost: true});\n      if(document.getElementById('lastaction')) {\n        document.getElementById('lastaction').remove();\n      }\n      if(document.getElementById(\"modify-menu\")) {\n        document.getElementById(\"modify-menu\").append(newMenu);\n      }\n      editor_model.actionsDuringSave = [];\n      updateInteractionDiv();\n      sendNotification(\"Beginning save!\");\n      /*\n        Spawn new worker thread to \n          (1) read SERVER_CONTENT. \n            set up xmlhttp request over in a worker thread and wait for the promise to be fullfilled.\n          (2) save - also on worker thread\n            on message over here will be notified when the save it complete and will be given the new \n            page content within the xmlhttp response. We need to rewrite the page with these data.\n      */\n      \n      let serverWorker = new Worker(\"/Thaditor/editor.js\");\n      const tosend = JSON.stringify(domNodeToNativeValue(document.body.parentElement));\n      let data = {action:\"sendMods\", \n                      toSend:tosend,\n                      gaidt:googleAuthIdToken,\n                      aq:editor_model.askQuestions,\n                      loc:location.pathname + location.search,\n                      server_content:(typeof SERVER_CONTENT == \"undefined\" ? undefined : SERVER_CONTENT)};\n      serverWorker.onmessage = function(e) {\n        //handle confirmDone\n        if (e.data.action == \"confirmDone\") {\n          let xmlhttp = new XHRequest();\n          xmlhttp.response.setHeader(\"newLocalURL\", e.data.newLocalURL);\n          xmlhttp.response.setHeader(\"newQueryStr\", e.data.newQueryStr);\n          xmlhttp.response.setHeader(\"ambiguityKey\", e.data.ambiguityKey);\n          xmlhttp.response.setHeader(\"ambiguityNumber\", e.data.ambiguityNumber);\n          xmlhttp.response.setHeader(\"ambiguitySelected\", e.data.ambiguitySelected);\n          xmlhttp.response.setHeader(\"ambiguityEnd\", e.data.ambiguityEnd);\n          xmlhttp.response.setHeader(\"ambiguitySummaries\", e.data.ambiguitySummaries);\n          xmlhttp.response.setHeader(\"opSummaryEncoded\", e.data.opSummaryEncoded);\n          xmlhttp.response.text = e.data.text;\n          /*\n            We want to undo everything in the undo stack that has been done since the save began.\n            In the process of vanilla undoing this (using mark's function), the items will be\n            pushed onto the redoStack in the normal way, s.t. we can redo them in a moment.\n            Once we're at the state we were at when we began to save, we re-write the page\n            with the confirmed content that the worker gave us.\n            Once the confirmed content has been rewritten, we have undo/redo stacks that point,\n            as the undo/redo stacks are an array of array of MutationRecords, all of whose target\n            has just been erased and replaced with a new object. \n            So we need to convert the old UR stacks to be pointing to the right objects.\n            We solve this in the undo()/redo() functions, by checking to see if the object\n            pointed to in the mutationrecord is still connected to the active DOM. if not,\n            we use the inactive node to record the path up the tree, and search for the\n            corresponding node in the newly active tree, replacing the MR.target with the active one.\n            Once we have the UR stacks set up, we just need to vanilla undo/redo to get back to\n            the state pre-update & post-save.\n          */\n          const ads = editor_model.actionsDuringSave;\n          const adsLen = editor_model.actionsDuringSave.length;\n          editor_model.isAfterSave = true;\n          ads.forEach((action) => {\n            if (action == \"undo\") {\n              undo();\n            } else if (action == \"redo\") {\n              redo();\n            } else {\n              throw new Error(\"Unidentified action in restoring post-save state post-save\");\n            }\n          });\n          \n          editor_model.outputObserver.disconnect();\n          xmlhttp.onreadystatechange = handleServerPOSTResponse(xmlhttp, () => {});\n          xmlhttp.readyState = XMLHttpRequest.DONE\n          xmlhttp.onreadystatechange();\n          const newAds = editor_model.actionsDuringSave;\n          const newAdsLen = newAds.length;\n          for (let i = 0; i < adsLen; i++) {\n            if (newAds[i] == \"undo\") {\n              undo();\n            } else if (newAds[i] == \"redo\") {\n              redo();\n            } else {\n              throw new Error(\"unidentified action in actionsduringsave\");\n            }\n          }\n          editor_model.isAfterSave = false;\n          sendNotification(\"Save completed!\");\n\n        }\n      }\n      serverWorker.postMessage(data);\n    } //sendModificationsToServer\n\n\n    //other possible approaches\n    //add writable property (for oldValue) to mutation object\n    //create array with necessary properties/attributes\n    /*\n     * adds writiable properties to the MutationRecord objects so the undo/redo functions\n     * will actually function later on\n     */\n     //sends info over to the undostack\n    function sendToUndo(m, time) {\n      //for childLists, add mutable next/previous sibling properties\n      if(m.type === \"childList\") {\n          /*Object.defineProperty(m, 'rePrevSib', {value: m.previousSibling /*&& !(m.previousSibling.nodeType == 1)) ? \n                                                m.previousSibling.previousElementSibling : m.previousSibling, \n                                                writable: true});\n          Object.defineProperty(m, 'reNextSib', {value: m.nextSibling /*&& !(m.nextSibling.nodeType == 1)) ? \n                                                m.nextSibling.nextElementSibling : m.nextSibling,\n                                                writable: true});*/\n      }\n        //for attributes/characterData, add alternative mutable oldValue\n      else {\n        Object.defineProperty(m, 'URValue', {value: m.oldValue, writable: true});\n      }\n      //Object.defineProperty(m, 'timestamp', {value: time})\n      m.timestamp = time;\n      //check if the last element on currently on the stack is operating on the same \"information\", i.e. oldValue or nodelists\n      //and should be combined together when undoing/redoing\n      \n      let lastUndo = editor_model.undoStack[editor_model.undoStack.length-1];\n      //makes single actions that are recorded as multiple mutations a single action\n      //true here ==> mutation is separate action\n      if(!lastUndo || (lastUndo[0].timestamp < (time - 10))) {  \n        if (editor_model.isSaving) {\n          editor_model.actionsDuringSave.unshift(\"undo\");\n        }\n        editor_model.undoStack.push([m]);\n        editor_model.redoStack = [];\n      }\n      //false here ==> mutation is same action as last mutation\n      //makes no sense for somethign that is first added then removed for those actions to be grouped together \n      //i.e. if i add text then get rid of it, it makes no sense for undo to revert the removal and addition direclty in sequence\n      else {\n        lastUndo = editor_model.undoStack.pop();\n        lastUndo.push(m);\n        editor_model.undoStack.push(lastUndo);\n      }     \n    } //sendToUndo\n    \n    function handleMutations(mutations, observer) {\n      var onlyGhosts = true;\n      let cur_date = new Date();\n      let cur_time = cur_date.getTime();\n      for(var i = 0; i < mutations.length; i++) {\n        // A mutation is a ghost if either\n        // -- The attribute starts with 'ghost-'\n        // -- It is the insertion of a node whose tag is \"ghost\" or that contains an attribute \"isghost=true\"\n        // -- It is the modification of a node or an attribute inside a ghost node.\n        /*  \n         * Add mutations to undo list if they are not ghosts and if they are really doing something.\n         */\n        let mutation = mutations[i];\n        if(hasGhostAncestor(mutation.target)) {\n          continue;\n        }\n        if(mutation.type == \"attributes\") {\n          var isSpecificGhostAttributeKey = isSpecificGhostAttributeKeyFromNode(mutation.target);\n          var isIgnoredAttributeKey = isIgnoredAttributeKeyFromNode(mutation.target);\n          if(isGhostAttributeKey(mutation.attributeName) || isSpecificGhostAttributeKey(mutation.attributeName) ||\n             mutation.target.getAttribute(mutation.attributeName) === mutation.oldValue ||\n             isIgnoredAttributeKey(mutation.attributeName)\n              ) {\n          } else {\n            onlyGhosts = false;\n            sendToUndo(mutation, cur_time);\n            console.log(\"Attribute is not ghost\", mutation);\n          }\n        } else if(mutation.type == \"childList\") {\n          if(!areChildrenGhosts(mutation.target)) {\n            for(var j = 0; j < mutation.addedNodes.length; j++) {\n              if(!hasGhostAncestor(mutation.addedNodes[j])) {\n                onlyGhosts = false;\n                sendToUndo(mutation, cur_time);\n                console.log(`Added node ${j} does not have a ghost ancestor`, mutation);\n              }\n            }\n            for(var j = 0; j < mutation.removedNodes.length; j++) {\n              if(!isGhostNode(mutation.removedNodes[j])) {\n                onlyGhosts = false;\n                sendToUndo(mutation, cur_time);\n                console.log(`Removed node ${j} was not a ghost`, mutation);\n              }\n            }\n          }\n        } else {\n          onlyGhosts = false;\n          sendToUndo(mutation, cur_time);\n          console.log(\"mutations other than attributes, childList and characterData are not ghosts\", mutations);\n        }\n      }\n      if(onlyGhosts) {\n        return;\n      } // Send in post the new HTML along with the URL\n      \n      if(!editor_model.autosave) {\n        if(editor_model.undoStack.length)\n        {\n          editor_model.canSave = true;\n        }\n        var saveButtons = document.querySelectorAll(\".saveButton\");\n        // TODO: Can we regenerate the whole interface for consistency?\n        for(let sb of saveButtons) {\n          sb.classList.toggle(\"disabled\", false);\n        }\n        return;\n      } \n      //autosave is on\n      if(typeof t !== \"undefined\") {\n        clearTimeout(t);\n      }\n      t = setTimeout(function() {\n        t = undefined;\n        \n        sendModificationsToServer();\n      }, @editdelay)\n    } //handleMutations\n  \n    //debugging function for printing both teh undo and redo stacks.\n    function printstacks() {\n      console.log(\"-----------------------------\");\n      let i, j;\n      console.log(\"UNDO STACK:\");\n      for(i = 0; i < editor_model.undoStack.length; i++) {\n        console.log(i + \".\");\n        for(j = 0; j < editor_model.undoStack[i].length; j++) {\n          console.log(editor_model.undoStack[i][j]);\n        }\n      }\n      console.log(\"REDO STACK:\");\n      for(i = 0; i < editor_model.redoStack.length; i++) {\n        console.log(i + \".\"); \n        for(j = 0; j < editor_model.redoStack[i].length; j++) {\n          console.log(editor_model.redoStack[i][j]);\n        }\n      }\n      console.log(\"-----------------------------\");\n    }\n\n    //undo function: handles undo feature\n    function undo() {\n      let undoElem = editor_model.undoStack.pop();\n      //need to check if undoStack is empty s.t. we can set the \"savability\" of the document accurately\n      if(undoElem == undefined) {\n        editor_model.canSave = false;\n        return 0;\n      }\n      else if (!editor_model.undoStack.length) {\n        editor_model.canSave = false;\n      }\n      //TODO prevent pressing the undo button while save underway while letting Editor use the undo function. (just not the user);\n      //need to disconnect the MutationObserver such that our undo does not get recorded as a mutation\n      editor_model.outputObserver.disconnect();\n      const quicker = node => recoverElementFromData(dataToRecoverElement(node));\n      let k;\n      for(k = undoElem.length - 1; k >= 0; k--) {\n        let mutType = undoElem[k].type; \n        let qk = quicker(undoElem[k].target);\n        \n        let target = (undoElem[k].target.isConnected ? \n                        undoElem[k].target :\n                        (qk == undefined ? undoElem[k].target : qk));\n        //in each case, we reverse the change, setting the URValue/oldValue as the current value\n        //at the target, and replacing the URValue/oldValue with the current value present in target\n        if(mutType == \"attributes\") {\n          let cur_attr = target.getAttribute(undoElem[k].attributeName);\n          if(undoElem[k].URValue === null) {\n            target.removeAttribute(undoElem[k].attributeName); \n          }       \n          else { \n            target.setAttribute(undoElem[k].attributeName, undoElem[k].URValue);\n          }\n          undoElem[k].URValue = cur_attr; \n        }\n        else if(mutType == \"characterData\") {\n          const cur_data = target.data;\n          target.data = undoElem[k].URValue;\n          undoElem[k].URValue = cur_data;\n          //undoElem[k].isConnected ? undoElem[k].URValue : quicker(undoElem[k]).URValue = cur_data;\n        }\n        else {\n          let uRemNodes = undoElem[k].removedNodes;\n          let uAddNodes = undoElem[k].addedNodes;\n          //readding the removed nodes\n          // -in this case, we loop through the childNodes and add them in the appropriate spot \n          // or remove them \n          // NOTE: we only change the nextSib property of the undoElem, and alternate between adding/removing from the \n          //       addedNodes & removedNodes lists depending on whether we are undoing (in which case we will add)\n          // NOTE: Since there is only one nextSibling/prevSibling property, and based off the fact that MutationObserver\n          //       should take into account every mutation, we should only have elements in one of uRemNodes and uAddNodes\n          //       at once.\n          let kidNodes = target.childNodes;\n          let i, j;\n          if(uRemNodes.length) {\n            if(kidNodes.length === 0) {            \n              if(undoElem[k].nextSibling == null && undoElem[k].previousSibling == null) {\n                for(i = 0; i < uRemNodes.length; i++) { \n                  if(hasGhostAncestor(uRemNodes.item(i))) {\n                    continue;\n                  }\n                  target.appendChild(uRemNodes.item(i)); \n                }\n              }\n            }\n            for(j = 0; j < kidNodes.length; j++) {  \n              let ns = undoElem[k].nextSibling && undoElem[k].nextSibling.isConnected ? undoElem[k].nextSibling : quicker(undoElem[k].nextSibling);\n              let ps = undoElem[k].previousSibling && undoElem[k].previousSibling.isConnected ? undoElem[k].previousSibling : quicker(undoElem[k].previousSibling);\n\n              let knode = kidNodes.item(j);\n              let knode_may = quicker(knode);\n              //if(kidNodes.item(j) === undoElem[k].nextSibling && kidNodes.item(j).previousSibling === undoElem[k].previousSibling) {\n              if ((knode == ns || knode_may == ns || ns == undefined) &&\n                  (knode.previousSibling == ps || knode_may.previousSibling == ps || ps == undefined)){\n                for(i = 0; i < uRemNodes.length; i++) { \n                  if(hasGhostAncestor(uRemNodes.item(i))) {\n                    continue;\n                  }\n                  let uremnode = uRemNodes.item(i);\n                  let urn = quicker(uremnode);\n                  target.insertBefore(urn == undefined ? uremnode : urn, knode_may == undefined ? knode : knode_may); \n                }\n              }\n            }\n          }\n          for(i = 0; i < uAddNodes.length; i++) {\n            if(hasGhostAncestor(uAddNodes.item(i))) {\n              continue;\n            }\n            else if(!target.contains(uAddNodes.item(i))) {\n              console.log(\"The item you are trying to undo doesn't exist in the parent node.\");\n            }\n            else {\n              target.removeChild(uAddNodes.item(i));\n              \n            }\n          }\n        }\n      } //mutation looper\n      editor_model.redoStack.push(undoElem);\n      if (editor_model.isSaving) {\n        editor_model.actionsDuringSave.unshift(\"redo\");\n      }\n      //TODO make sure save button access is accurate (i.e. we should ony be able to save if there are thigns to undo)\n      //turn MutationObserver back on\n      editor_model.outputObserver.observe\n       ( document.body.parentElement\n       , { attributes: true\n         , childList: true\n         , characterData: true\n         , attributeOldValue: true\n         , characterDataOldValue: true\n         , subtree: true\n         }\n       );\n      updateInteractionDiv();\n      return 1;\n    } //undo\n\n    \n\n    function redo() {\n      let redoElem = editor_model.redoStack.pop();\n      if(redoElem === undefined) {\n        return 0;\n      }\n      editor_model.outputObserver.disconnect();\n      const quicker = node => recoverElementFromData(dataToRecoverElement(node));\n      let k;\n      for(k = 0; k < redoElem.length; k++) {\n        let mutType = redoElem[k].type;\n        let qk = quicker(redoElem[k].target);\n        let target = (redoElem[k].target.isConnected ? \n                        redoElem[k].target : \n                        (qk == undefined ? redoElem[k].target : qk));\n        if(mutType == \"attributes\") {\n          let cur_attr = target.getAttribute(redoElem[k].attributeName);\n          if (redoElem[k].URValue === null) {\n            target.removeAttribute(redoElem[k].attributeName); \n          } else { \n            target.setAttribute(redoElem[k].attributeName, redoElem[k].URValue);\n          }\n          redoElem[k].URValue = cur_attr;\n        } else if(mutType == \"characterData\") {\n          let cur_data = target.data;\n          target.data = redoElem[k].URValue;  \n          redoElem[k].URValue = cur_data;\n          //redoElem[k].isConnected ? redoElem[k].URValue : quicker(redoElem[k]).URValue = cur_data;\n        } else {\n          let rRemNodes = redoElem[k].removedNodes;\n          let rAddNodes = redoElem[k].addedNodes;\n          let i, j;\n          let kidNodes = target.childNodes;\n          if(rAddNodes.length) {\n            for(j = 0; j < kidNodes.length; j++) {\n              let knode = kidNodes.item(j);\n              let raddnode = rAddNodes.item(i);\n              let ran = quicker(raddnode);\n              let knode_may = quicker(knode);\n              //if(kidNodes.item(j) === redoElem[k].nextSibling && kidNodes.item(j).previousSibling === redoElem[k].previousSibling)\n              let ns = redoElem[k].nextSibling && redoElem[k].nextSibling.isConnected ? redoElem[k].nextSibling : quicker(redoElem[k].nextSibling);\n              let ps = redoElem[k].previousSibling && redoElem[k].previousSibling.isConnected ? redoElem[k].previousSibling : quicker(redoElem[k].previousSibling);\n              \n              if ((knode == ns || knode_may == ns || ns == undefined) &&\n                  (knode.previousSibling == ps || knode_may.previousSibling == ps || ps == undefined)) {\n                for(i = 0; i < rAddNodes.length; i++) {\n                  if(hasGhostAncestor(rAddNodes.item(i))) {\n                    continue;\n                  }\n                  target.insertBefore(ran == undefined ? rAddNodes.item(i) : ran, knode_may == undefined ? knode : knode_may);\n                }\n              }\n            }\n          }\n          for(i = 0; i < rRemNodes.length; i++) {\n            if(hasGhostAncestor(rRemNodes.item(i))) {\n              continue;\n            } else if(!target.parentElement.contains(quicker(rRemNodes.item(i)))) { //bc the node in rRemNodes isn't necessarily connected, we need to rewrite this.\n              console.log(\"The item you are trying to redo doesn't exist in the parent node.\");\n            } else {\n              target.removeChild(quicker(rRemNodes.item(i)));\n            }\n          }\n        }\n      } //mut looper\n      editor_model.undoStack.push(redoElem);\n      if (editor_model.isSaving) {\n        editor_model.actionsDuringSave.unshift(\"undo\");\n      }\n      editor_model.canSave = true;\n      editor_model.outputObserver.observe\n       ( document.body.parentElement\n       , { attributes: true\n         , childList: true\n         , characterData: true\n         , attributeOldValue: true\n         , characterDataOldValue: true\n         , subtree: true\n         }\n       );\n       updateInteractionDiv();\n       return 1;\n    } //end of redo\n\n    \n    \n    function pasteHtmlAtCaret(html) {\n      var sel, range;\n      if (window.getSelection) {\n          // IE9 and non-IE\n          sel = window.getSelection();\n          // do not paste html into modify menu\n          if (sel.anchorNode.offsetParent && sel.anchorNode.offsetParent.id === \"modify-menu\") {\n            return;\n          }\n          if (sel.getRangeAt && sel.rangeCount) {\n              range = sel.getRangeAt(0);\n              range.deleteContents();\n              // Range.createContextualFragment() would be useful here but is\n              // only relatively recently standardized and is not supported in\n              // some browsers (IE9, for one)\n              var div = document.createElement(\"div\");\n              div.innerHTML = html;\n              var frag = document.createDocumentFragment(), node, lastNode;\n              while ( (node = div.firstChild) ) {\n                  lastNode = frag.appendChild(node);\n              }\n              range.insertNode(frag);\n              // Preserve the selection\n              if (lastNode) {\n                  range = range.cloneRange();\n                  range.setStartAfter(lastNode);\n                  range.collapse(true);\n                  sel.removeAllRanges();\n                  sel.addRange(range);\n              }\n          }\n      } else if (document.selection && document.selection.type != \"Control\") {\n          // IE < 9\n          document.selection.createRange().pasteHTML(html);\n      }\n    }\n    \n    function handleFileSelect(evt) {\n      evt.stopPropagation();\n      evt.preventDefault();\n      var files = evt.dataTransfer.files; // FileList object\n      uploadFilesAtCursor(files);\n    }\n    \n    function uploadFilesAtCursor(files) { \n      // files is a FileList of File objects. List some properties.\n      for (var i = 0, file; file = files[i]; i++) {\n        var targetPathName =  editor.getStorageFolder(file) + file.name;\n        // if(file.size < 30000000)\n        editor.uploadFile(targetPathName, file, (targetPathName, file) => {\n          @(    \n            if folderView then \n            \"\"\"\n            reloadPage();\n            \"\"\"\n            else\n            \"\"\"\n            if(file.type.indexOf(\"image\") == 0) {\n              pasteHtmlAtCaret(`<img src=\"${targetPathName}\" alt=\"${file.name}\">`);\n            } else {\n              pasteHtmlAtCaret(`<a href=\"${path}\">${path}</a>`); \n            }\n            \"\"\"\n          )\n        });\n      }\n    }\n    function handleDragOver(evt) {\n      evt.stopPropagation();\n      evt.preventDefault();\n      evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.\n    }\n    if(@(if varedit then \"true\" else \"false\")) {\n      var dropZone = document.body;\n      dropZone.addEventListener('dragover', handleDragOver, false);\n      dropZone.addEventListener('drop', handleFileSelect, false);\n    \n      var lastclick = 0;\n      // Shortcuts\n      document.onkeydown = function(e) {\n        var key = e.which || e.keyCode;\n        if (e.which == 83 && (e.ctrlKey || e.metaKey)) { // CTRL+S or CMD+S: Save\n          if(document.getElementById(\"savebutton\") && document.getElementById(\"savebutton\").onclick) {\n            document.getElementById(\"savebutton\").onclick();\n          }\n          e.preventDefault();\n        }\n        if(e.which == 75 && (e.ctrlKey || e.metaKey)) { // CTRL+K: Insert link\n          if(new Date().valueOf() - lastclick > 100) {\n            document.execCommand('createLink', false, 'http://');\n            e.preventDefault();\n            var s = getSelection();\n            s = s ? s.anchorNode : s;\n            s = s ? s.parentNode : s;\n            lastclick = new Date().valueOf();\n            onClickGlobal({target: s, modify: true});\n          }\n          // Open link.\n        }\n        if(e.which == 90 && (e.ctrlKey || e.metaKey)) {\n          e.preventDefault();\n          if(!undo()) sendNotification(\"Nothing to undo!\");\n        }\n        if(e.which == 89 && (e.ctrlKey || e.metaKey)) {\n          e.preventDefault();\n          if(!redo()) sendNotification(\"Nothing to redo!\");\n        }\n        //in link select mode, escape on the keyboard can be\n        //used to exit the link select mode (same as escape button)\n        if(editor_model.linkSelectMode) {\n          if(e.which == 27) {\n            escapeLinkMode();\n          }\n        }\n      };\n      \n      var bodyeditable = document.querySelector(\"body[contenteditable=true]\");\n      var onKeypress = e => {\n        if(e.keyCode==13 && !e.shiftKey){ // [Enter] key\n            // If we are inside a paragraph, we split the paragraph.\n            // If we are directly inside a div, we add a paragraph separator.\n            // We delete everything between anchorNode and focusNode\n            // TODO: Handle ul and li\n            var caretSelection = document.getSelection();\n            var x = caretSelection.anchorNode;\n            if(x && x.nodeType == 3 && caretSelection.rangeCount) { // text node\n              if(x.parentNode && getComputedStyle(x.parentNode).display == \"block\") {\n                e.preventDefault(); //Prevent default browser\n                var range = caretSelection.getRangeAt(0);\n                range.deleteContents();\n                caretSelection = document.getSelection();\n                x = caretSelection.anchorNode;\n                if(x.parentNode.tagName == \"p\") { // Split the p\n                  var newPar = document.createElement(\"p\");\n                  \n                  var fo = caretSelection.anchorOffset;\n                  if(fo < x.text.length) {\n                    newPar.append(document.createTextNode(x.text.substring(fo)));\n                    x.deleteData(fo,x.text.length - fo);\n                  }\n                  var y = x.nextSibling;\n                  while(y) {\n                    var yy = y;\n                    y = y.nextSibling;\n                    newPar.append(yy); // Moves yy\n                  }\n                  x.parentNode.insertAdjacentElement(\"afterend\", newPar);\n                } else { // insert br\n                  range.insertNode(document.createElement(\"br\"))\n                }\n              }\n            }\n        }\n      }\n      if(bodyeditable && !bodyeditable.configured) {\n        bodyeditable.configured = true;\n        bodyeditable.addEventListener(\"keypress\", onKeypress, true);\n      }\n    }\n    \n    var observeTargetA = null;\n    \n    var addEditEqualToUrl = function(href, what) {\n      if(href.indexOf(\"://\") == -1) { // Instrument the relative link so that it is edit=true\n        if(href.indexOf(\"?\") >= 0) {\n          if(href.endsWith(\"?\")) {\n            href = href + \"edit=\" + what\n          } else {\n            href = href + \"&edit=\" + what\n          }\n        } else {\n          href = href + \"?edit=\" + what\n        }\n      }\n      return href;\n    }\n    \n    // Prevent mouse down on modify-menu that end outside modify-menu to trigger onclick\n    var onMouseDownGlobal = function(event) {\n      var tmp = event.target;\n      while(tmp) {\n        if(tmp.getAttribute && tmp.getAttribute(\"id\") == \"modify-menu\") {\n          editor_model.dismissNextClick = true;\n          return;\n        }\n        tmp = tmp.parentElement;\n      }\n    }    \n    var onClickGlobal = function (event) {\n\t\tif(editor_model.dismissNextClick) {\n\t        editor_model.dismissNextClick = false;\n\t        return;\n      \t}\n      var clickedElem = event.target;\n      console.log(typeof event.target);\n      var editorSelectOptions = document.querySelectorAll(\"meta[editor-noselect],meta[editor-doselect]\");\n      var matchOptions = function(clickedElem) {\n        var result = true;\n        for(let i = 0; i < editorSelectOptions.length; i++) {\n          let negativeSelector = editorSelectOptions[i].getAttribute(\"editor-noselect\"),\n              positiveSelector = editorSelectOptions[i].getAttribute(\"editor-doselect\");\n          if(result && negativeSelector) {\n            result = !clickedElem.matches(negativeSelector);\n          }\n          if(!result && positiveSelector) {\n            result = clickedElem.matches(positiveSelector);\n          }\n        }\n        return result;\n      }\n      while(clickedElem && editorSelectOptions && !matchOptions(clickedElem)) {\n        clickedElem = clickedElem.parentElement;\n      }                           \n      var ancestors = [];\n      var tmp = clickedElem;\n      var aElement;\n      var ancestorIsModifyBox = false;\n      var ancestorIsContextMenu = false;\n      var link = undefined;\n      while(tmp) {\n        ancestors.push(tmp);\n        if(tmp.getAttribute && tmp.getAttribute(\"id\") == \"modify-menu\") {\n          ancestorIsModifyBox = true;\n        }\n        if(tmp.getAttribute && tmp.getAttribute(\"id\") == \"context-menu\") {\n          ancestorIsContextMenu = true;\n        }\n        if(!aElement && tmp.tagName === \"A\") { // First link.\n          aElement = tmp;\n          link = aElement.getAttribute(\"href\");\n        }\n        tmp = tmp.parentElement;\n      }\n      document.querySelectorAll(\"[ghost-hovered=true]\").forEach(e => e.removeAttribute(\"ghost-hovered\"));\n      if(ancestorIsModifyBox || ancestorIsContextMenu || ancestors[ancestors.length - 1].tagName != \"HTML\") return;\n      //console.log(\"not modify box\", ancestors)\n      document.querySelector(\"#context-menu\").classList.remove(\"visible\");\n      \n      editor_model.clickedElem = clickedElem;\n      editor_model.link = link;\n      editor_model.link_href_source = aElement; // So that we can modify it\n      editor_model.insertElement = false;\n      editor_model.advanced = false;\n      editor_model.notextselection = false;\n      updateInteractionDiv();\n      // Check if the event.target matches some selector, and do things...\n    }\n    function mkSvg(path, fill) {\n      return `<svg class=\"context-menu-icon${fill ? \" fill\": \"\"}\" width=\"40\" height=\"30\">\n            <path d=\"${path}\" /></svg>`\n    }\n    var arrowDown = mkSvg(\"M 10,17 13,14 17,18 17,4 23,4 23,18 27,14 30,17 20,27 Z\", true);\n    var arrowRight = mkSvg(\"M 21,25 18,22 22,18 8,18 8,12 22,12 18,8 21,5 31,15 Z\", true);\n    var arrowUp = mkSvg(\"M 10,14 13,17 17,13 17,27 23,27 23,13 27,17 30,14 20,4 Z\", true);\n    var arrowLeft = mkSvg(\"M 19,25 22,22 18,18 32,18 32,12 18,12 22,8 19,5 9,15 Z\", true);\n    var cloneSVG = mkSvg(\"M 19,8 31,8 31,26 19,26 Z M 11,4 23,4 23,8 19,8 19,22 11,22 Z\");\n    var saveSVG = mkSvg(\"M 10,5 10,25 30,25 30,9 26,5 13,5 Z M 13,6 25,6 25,12 13,12 Z M 22,7 22,11 24,11 24,7 Z M 13,15 27,15 27,24 13,24 Z M 11,23 12,23 12,24 11,24 Z M 28,23 29,23 29,24 28,24 Z\", true);\n    var openLeftSVG = mkSvg(\"M 27.5,4 22.5,4 12.5,15 22.5,25 27.5,25 17.5,15 Z\", true);\n    var closeRightSVG = mkSvg(\"M 12.5,4 17.5,4 27.5,15 17.5,25 12.5,25 22.5,15 Z\", true);\n    var openTopSVG = mkSvg(\"M 9.5,22 9.5,17 20.5,7 30.5,17 30.5,22 20.5,12 Z\", true);\n    var closeBottomSVG = mkSvg(\"M 9.5,7 9.5,12 20.5,22 30.5,12 30.5,7 20.5,17 Z\", true);\n    var wasteBasketSVG = mkSvg(\"m 24,11.5 0,11 m -4,-11 0,11 m -4,-11 0,11 M 17,7 c 0,-4.5 6,-4.5 6,0 m -11,0.5 0,14 c 0,3 1,4 3,4 l 10,0 c 2,0 3,-1 3,-3.5 L 28,8 M 9,7.5 l 22,0\");\n    var plusSVG = mkSvg(\"M 18,5 22,5 22,13 30,13 30,17 22,17 22,25 18,25 18,17 10,17 10,13 18,13 Z\", true);\n    var liveLinkSVG = link => `<a class=\"livelink\" href=\"javascript:navigateLocal(relativeToAbsolute('${link}'))\">${mkSvg(\"M 23,10 21,12 10,12 10,23 25,23 25,18 27,16 27,24 26,25 9,25 8,24 8,11 9,10 Z M 21,5 33,5 33,17 31,19 31,9 21,19 19,17 29,7 19,7 Z\", true)}</a>`;\n    var gearSVG = mkSvg(\"M 17.88,2.979 14.84,3.938 15.28,7.588 13.52,9.063 10,8 8.529,10.83 11.42,13.1 11.22,15.38 7.979,17.12 8.938,20.16 12.59,19.72 14.06,21.48 13,25 15.83,26.47 18.1,23.58 20.38,23.78 22.12,27.02 25.16,26.06 24.72,22.41 26.48,20.94 30,22 31.47,19.17 28.58,16.9 28.78,14.62 32.02,12.88 31.06,9.84 27.41,10.28 25.94,8.52 27,5 24.17,3.529 21.9,6.42 19.62,6.219 17.88,2.979 Z M 20,11 A 4,4 0 0 1 24,15 4,4 0 0 1 20,19 4,4 0 0 1 16,15 4,4 0 0 1 20,11 Z\", true);\n    var folderSVG = mkSvg(\"M 8,3 5,6 5,26 10,10 32,10 32,6 18,6 15,3 8,3 Z M 5,26 10,10 37,10 32,26 Z\");\n    var reloadSVG = mkSvg(\"M 32.5,8.625 30.25,15.25 24.75,11.125 M 6.75,20 9.875,14.5 15.125,19 M 29.5,18 C 28.25,22.125 24.375,25 20,25 14.5,25 10,20.5 10,15 M 10.5,12 C 11.75,7.875 15.625,5 20,5 25.5,5 30,9.5 30,15\");\n    var logSVG = mkSvg(\"M 17.24,16 A 1.24,2 0 0 1 16,18 1.24,2 0 0 1 14.76,16 1.24,2 0 0 1 16,14 1.24,2 0 0 1 17.24,16 Z M 20,16 21.24,16 21.24,16 A 1.24,2 0 0 1 20,18 1.24,2 0 0 1 18.76,16 1.24,2 0 0 1 20,14 1.33,2.16 0 0 1 21,15 M 12,14 12,18 14,18 M 10,12 23,12 23,20 10,20 Z M 23,6 23,11 28,11 M 14,6 14,12 10,12 10,20 14,20 14,25 28,25 28,11 23,6 14,6 Z\");\n    var sourceSVG = mkSvg(\"M 22.215125,2 25,3 18.01572,27 15,26 Z M 12,19 12,25 2,14 12,4 12,9 7,14 Z M 28,9 28,4 38,15 28,25 28,20 33,15 Z\", true);\n    var isAbsolute = url => url.match(/^https?:\\/\\/|^www\\.|^\\/\\//);\n    var linkToEdit = @(if defaultVarEdit then \"link => link\" else \n     \"\"\"link => link && !isAbsolute(link) ? link.match(/\\?/) ? link + \"&edit\" : link + \"?edit\" : link;\"\"\");\n    var undoSVG = mkSvg(\"M 9.5,12.625 11.75,19.25 17.25,15.125 M 31.5,16 C 30.25,11.875 26.375,9 22,9 16.5,9 12,13.5 12,19\");\n    var redoSVG = mkSvg(\"M 31.5,12.625 29.25,19.25 23.75,15.125 M 9.5,16 C 10.75,11.875 14.625,9 19,9 24.5,9 29,13.5 29,19\");\n    var escapeSVG = mkSvg(\"M 7.5 4 L 17.5 15 L 7.5 25 L 12.5 25 L 20 17.5 L 27.5 25 L 32.5 25 L 22.5 15 L 32.5 4 L 27.5 4 L 20 12.25 L 12.5 4 L 7.5 4 z\", true);\n    var linkModeSVG = mkSvg(\"M 14,3 14,23 19,19 22,27 25,26 22,18 28,18 Z\");\n    var checkSVG = mkSvg(\"M 10,13 13,13 18,21 30,3 33,3 18,26 Z\", true);\n    var ifAlreadyRunning = typeof editor_model === \"object\";\n    \n    //hover mode functions for linkSelectMode\n    function escapeLinkMode() {\n      document.body.removeEventListener('mouseover', linkModeHover1, false);\n      document.body.removeEventListener('mouseout', linkModeHover2, false);\n      //removing the hovered element (which is retained if the escape key is hit)\n      document.querySelectorAll(\"[ghost-hovered=true]\").forEach(e => e.removeAttribute(\"ghost-hovered\"));\n      //editor_model.clickedElem = editor_model.linkFrom;\n      editor_model.visible = false;\n      editor_model.linkSelectMode = false;\n      editor_model.linkSelectCallback = undefined;\n      editor_model.linkSelectOtherMenus = undefined;\n      updateInteractionDiv();\n    }\n    function noGhostHover (node) {\n      curClass = node.getAttribute(\"class\")\n      if(curClass === \"modify-menu-icon-label-link\" ||\n        curClass === \"context-menu-icon\" ||\n        curClass === \"context-menu-icon fill\") {\n          return false;\n        }\n      else if(node.tagName === \"path\" || node.tagName === \"PATH\") {\n        return false;\n      }\n      return true;\n    }\n    function linkModeHover1(event) {\n      //console.log(event.target);\n      //console.log(event.target.tagName);\n      //console.log(event.target.getAttribute(\"class\"));\n      if(noGhostHover(event.target)) { \n        event.target.setAttribute(\"ghost-hovered\", true);\n        updateInteractionDiv();\n        //console.log(\"hey!\");\n      }\n    }\n    function linkModeHover2(event) {\n      if(noGhostHover(event.target)) {\n        event.target.removeAttribute(\"ghost-hovered\");\n        updateInteractionDiv();\n      }\n    }\n\n    function dataToRecoverElement(oldNode) {\n      if(!oldNode) return undefined;\n      if(oldNode.nodeType == 1 && oldNode.getAttribute(\"id\") && document.getElementById(oldNode.getAttribute(\"id\"))) {\n        return {id: oldNode.getAttribute(\"id\")};\n      }\n      let tentativeSelector = [];\n      let t = oldNode;\n      let isText = false, textIndex = 0;\n      while(t && t.parentNode) {\n        let index = Array.prototype.slice.call( t.parentNode.children ).indexOf(t);\n        if(t.nodeType === 1) {\n          tentativeSelector.unshift(t.tagName + \":nth-child(\" + (index + 1) + \")\" );\n        } else {\n          isText = true;\n          textIndex = Array.prototype.slice.call( t.parentNode.childNodes ).indexOf(t);\n        }\n        t = t.parentNode;\n      }\n      return {tentativeSelector: tentativeSelector, isText: isText, textIndex: textIndex};\n    }\n    \n    // Returns the new node that matches the old node the closest.\n    // For text nodes, try to recover the text node, if not, returns the parent node;\n    function recoverElementFromData(data) {\n      if(!data) return undefined;\n      if(typeof data === \"object\" && data.id) {\n        return document.getElementById(data.id);\n      }\n      if(typeof data == \"object\" && Array.isArray(data.tentativeSelector)) {\n        let tentativeSelector = data.tentativeSelector;\n        while(tentativeSelector.length >= 1) {\n          let newNode = document.querySelector(tentativeSelector.join(\" \"));\n          if(newNode) {\n            return data.isText && newNode.childNodes && newNode.childNodes[data.textIndex] || newNode;\n          }\n          tentativeSelector.shift();\n        }\n        return undefined;\n      }\n    }\n    function setCaretPositionIn(node, position) {\n      position = Math.min(position, node.textContent.length);\n      if (node.nodeType == 3) {\n        let sel  = window.getSelection()\n        setTimeout( () => sel.collapse(node, position), 0);\n      } else {\n        let p = position\n        let n = node.firstChild\n        while(n != null && p > n.textContent.length) {\n          p = p - n.textContent.length\n          n = n.nextSibling\n        }\n        if(n != null) {\n          setCaretPositionIn(n, p)\n        } else {\n          console.log(\"Could not find position. Reached node and position \", [n, p])\n        }\n      }\n    }\n    function dataToRecoverCaretPosition(caretPosition) {\n      if(!caretPosition) return undefined;\n      return {target: editor.toTreasureMap(caretPosition.startContainer), startOffset: caretPosition.startOffset};\n    }\n    function recoverCaretPositionFromData(data) {\n      if(!data) return;\n      let newTextNodeOrParent = editor.fromTreasureMap(data.target);\n      if(newTextNodeOrParent) setCaretPositionIn(newTextNodeOrParent, data.startOffset)\n    }\n    function dataToRecoverSelectionRange(selectionRange) { // TODO\n      if(!selectionRange) return undefined;\n      return undefined;\n    }\n    function recoverSelectionRangeFromData(data) { // TODO\n      if(!data) return;\n      return undefined;\n    }\n    \n    var editor_model = { // Change this and call updateInteractionDiv() to get something consistent.\n      //makes visibility of editor model consistent throughout reloads\n      visible: ifAlreadyRunning ? editor_model.visible : false,\n      clickedElem: ifAlreadyRunning ? editor.fromTreasureMap(editor_model.clickedElem) : undefined,\n      displayClickedElemAsMainElem: true, // Dom selector status switch signal\n      previousVisitedElem: [], // stack<DOM node> which helps showing previous selected child in the dom selector\n      notextselection: false, // When using the relative DOM selector, set to true to avoid considering the caret (e.g. for insertions and deletions)\n      selectionRange: ifAlreadyRunning ? recoverSelectionRangeFromData(editor_model.selectionRange) : undefined,\n      caretPosition: ifAlreadyRunning ? recoverCaretPositionFromData(editor_model.caretPosition) : undefined,\n      link: undefined,\n      advanced: ifAlreadyRunning ? editor_model.advanced : false,\n      displaySource: ifAlreadyRunning ? editor_model.displaySource : false,\n      disambiguationMenu: undefined,\n      isSaving: false,\n      //data structures to represent undo/redo \"stack\"\n      undoStack: ifAlreadyRunning ? editor_model.undoStack : [],\n      redoStack: ifAlreadyRunning ? editor_model.redoStack : [],\n      actionsDuringSave: ifAlreadyRunning ? editor_model.actionsDuringSave : [],\n      uStackSaving: [],\n      rStackSaving: [],\n      isAfterSave: ifAlreadyRunning ? editor_model.isAferSave : false,\n      //observer to listen for muts\n      outputObserver: ifAlreadyRunning ? editor_model.outputObserver : undefined,\n      //editor log\n      editor_log: ifAlreadyRunning ? editor_model.editor_log : [],\n      show_log: ifAlreadyRunning ? editor_model.show_log : false,\n      linkSelectMode: false,\n      linkSelectCallback: undefined, // Callback that is going to be called with the selected node.\n      idNum: ifAlreadyRunning ? editor_model.idNum : 1,\n      //new attribute to keep menu state after reload\n      curScrollPos: ifAlreadyRunning ? editor_model.curScrollPos : 0,\n      textareaScroll: ifAlreadyRunning ? editor_model.textareaScroll : 0,\n      textareaSelectionStart: ifAlreadyRunning ? editor_model.textareaSelectionStart : 0,\n      textareaSelectionEnd: ifAlreadyRunning ? editor_model.textareaSelectionEnd: 0,\n      askQuestions: ifAlreadyRunning ? editor_model.askQuestions :\n                    @(case listDict.get \"question\" vars of\n                       Just questionattr -> \"true\"\n                       _ -> if boolVar \"question\" True then \"true\" else 'false'),\n      autosave: ifAlreadyRunning ? editor_model.autosave :\n                    @(case listDict.get \"autosave\" vars of\n                      Just autosaveattr -> \"true\"\n                      _ -> if boolVar \"autosave\" True then \"true\" else \"false\"),\n      path: ifAlreadyRunning ? editor_model.path : @(path |> jsCode.stringOf)\n    }\n    function reorderCompatible (node1, node2){\n      let topLevelOrderableTags = {TABLE:1, P:1, LI:1, UL:1, OL:1, H1:1, H2:1, H3:1, H4:1, H5:1, H6:1, DIV:1};\n      return node1.tagName === node2.tagName && node1.tagName !== \"TD\" && node1.tagName !== \"TH\" ||\n        topLevelOrderableTags[node1.tagName] && topLevelOrderableTags[node2.tagName]\n        ; \n    }\n    function preventTextDeselection(e){\n      e = e || window.event;\n      e.preventDefault();\n    }\n    function restoreCaretPosition() {\n      if(typeof editor_model.caretPosition != \"undefined\") {\n        var sel = window.getSelection();\n        sel.removeAllRanges();\n        var range = document.createRange();\n        range.setStart(editor_model.caretPosition.startContainer, editor_model.caretPosition.startOffset);\n        range.setEnd(editor_model.caretPosition.endContainer, editor_model.caretPosition.endOffset);\n        sel.addRange(range);\n      }\n    }\n    // This function activates the node selection mode, in which one DOM node can be selected,\n    // After clicking on confirm, the callback is called with the selected node.\n    // callbackUI is invoked to render other buttons along with the confirmation button.\n    function activateNodeSelectionMode(msg, callback, callbackUI) {\n      editor_model.visible = false;\n      editor_model.linkSelectMode = true;\n      editor_model.clickedElem = document.body; //\"center\" clicked element on document body\n      //removes all context menu stuff \n      document.querySelector(\"#context-menu\").classList.remove(\"visible\");\n      editor_model.linkSelectCallback = callback;\n      editor_model.linkSelectMsg = \"Confirm \" + msg;\n      editor_model.linkSelectOtherMenus = callbackUI;\n      updateInteractionDiv();\n      sendNotification(editor_model.linkSelectMsg);\n      document.body.addEventListener('mouseover', linkModeHover1, false);\n      document.body.addEventListener('mouseout', linkModeHover2, false);\n    }\n      \n    updateInteractionDiv();\n\n    function updateInteractionDiv() {\n      let model = editor_model;\n      var clickedElem = model.clickedElem;\n      var contextMenu = document.querySelector(\"#context-menu\");\n      var modifyMenuDiv = document.querySelector(\"#modify-menu\");\n      //if both are closed, just return \n      if(!modifyMenuDiv || !contextMenu) return;\n      modifyMenuDiv.classList.toggle(\"visible\", editor_model.visible);\n      document.querySelectorAll(\"[ghost-clicked=true]\").forEach(e => e.removeAttribute(\"ghost-clicked\"));\n      if(clickedElem && clickedElem.nodeType === 1) {\n        clickedElem.setAttribute(\"ghost-clicked\", \"true\");\n      }\n      model.selectionRange = model.notextselection ? undefined : (() => {\n        let selection = window.getSelection();\n        if(!selection || !selection.rangeCount) return;\n        let f = selection.getRangeAt(0); \n        if(!f || !f.getBoundingClientRect ||\n            f.startOffset === f.endOffset && f.startContainer === f.endContainer) return;\n        return f;\n      })();\n      model.caretPosition = model.notextselection || clickedElem && clickedElem.tagName === \"HEAD\" ? undefined : (() => {\n        let selection = window.getSelection();\n        if(!selection || !selection.rangeCount) return;\n        let f = selection.getRangeAt(0);\n        if(!f || f.startOffset !== f.endOffset && f.startContainer !== f.endContainer) return;\n        return f;\n      })();\n      function textPreview(element, maxLength) {\n        let x = element.innerText;\n        let result = \"'\" + x + \"'\";\n        if(typeof maxLength !== \"undefined\" && result.length > maxLength) {\n          return result.substring(0, maxLength) + \"...'\";\n        }\n        return result;\n      }\n      function summary(element, idAndClasses, maxLength) {\n        var summary = element.tagName.toLowerCase();\n        if(idAndClasses && element.getAttribute(\"id\")) {\n          summary += \"#\" + element.getAttribute(\"id\");\n        }\n        var elemClass = element.getAttribute(\"class\");\n        if(idAndClasses && elemClass && elemClass.trim().length) {\n          summary += \".\" + elemClass.split(/\\s+/g).join(\".\");\n        }\n        summary += \" \" + textPreview(element);\n        maxLength = maxLength || 80;\n        summary = summary.substring(0, maxLength || 80) + (summary.length > 80 ? \"...\" : \"\");\n        return summary;\n      }\n      modifyMenuDiv.innerHTML = \"\";\n      let modifyMenuPinnedIconsDiv = el(\"div\", {\"class\":\"modify-menu-icons pinned\"});\n      let modifyMenuIconsDiv = el(\"div\", {\"class\":\"modify-menu-icons\"});\n      let interactionDiv = el(\"div\", {\"class\": \"information\"});\n      modifyMenuDiv.append(modifyMenuPinnedIconsDiv);\n      let domSelector = el(\"div\", {\"class\": \"dom-selector noselect\"}); // create dom selector interface\n      modifyMenuDiv.append(domSelector);\n      modifyMenuDiv.append(modifyMenuIconsDiv);\n      modifyMenuDiv.append(interactionDiv);\n      let createButton = function(innerHTML, attributes, properties) {\n        let button = el(\"div\", attributes, [], properties);\n        button.onmousedown = button.onmousedown ? button.onmousedown : preventTextDeselection;\n        button.classList.add(\"modify-menu-button\");\n        button.innerHTML = innerHTML;\n        return button;\n      }\n      let addModifyMenuIcon = function(innerHTML, attributes, properties) {\n        modifyMenuIconsDiv.append(createButton(innerHTML, attributes, properties));\n      }\n      let addPinnedModifyMenuIcon = function(innerHTML, attributes, properties) {\n        modifyMenuPinnedIconsDiv.append(createButton(innerHTML, attributes, properties));\n      }\n      var panelOpenCloseIcon = function() {\n        return document.querySelector(\"#modify-menu\").classList.contains(\"visible\") ?\n            onMobile() ? closeBottomSVG : closeRightSVG + \"<span class='modify-menu-icon-label'>Close</span>\"\n          : onMobile() ? openTopSVG : openLeftSVG + \"<span class='modify-menu-icon-label'>Open</span>\";\n      }\n      var alwaysVisibleButtonIndex = 0;\n      function nextVisibleBarButtonPosStyle() {\n        let result = \"position: absolute;\" +\n          (onMobile() ? \"top:-\"+buttonHeight()+\"px;left:\"+alwaysVisibleButtonIndex*buttonWidth()+\"px\" :\n                        \"left:-\"+buttonWidth()+\"px;top:\"+alwaysVisibleButtonIndex*buttonHeight()+\"px\")\n        alwaysVisibleButtonIndex++;\n        return result;\n      }\n      if(!editor_model.linkSelectMode) {\n        addPinnedModifyMenuIcon(\n          panelOpenCloseIcon(),\n          {title: \"Open/close settings tab\", \"class\": \"inert\" },\n          {onclick: function(event) {\n              document.querySelector(\"#modify-menu\").classList.toggle(\"visible\");\n              editor_model.visible = !editor_model.visible;\n              setTimeout(maybeRepositionContextMenu, 500);\n              this.innerHTML = panelOpenCloseIcon();\n            }\n        });\n        addPinnedModifyMenuIcon(\n          gearSVG + \"<span class='modify-menu-icon-label'>Misc.</span>\",\n          {title: \"Advanced\", \"class\": \"inert\" + (editor_model.advanced ? \" active\": \"\")\n          },\n          {onclick: (c => function(event) {\n            //defaults to turning on advanced menu if the editor model is already visible, otherwise toggles advanced menu.\n            if(editor_model.visible) {\n              editor_model.advanced = !editor_model.advanced;\n            }\n            else {\n              editor_model.advanced = true;\n            }\n            editor_model.visible = true;\n            updateInteractionDiv();\n          })(clickedElem)}\n        )\n        addPinnedModifyMenuIcon(saveSVG + \"<span class='modify-menu-icon-label'>Save</span>\",\n        {title: editor_model.disambiguationMenu ? \"Accept proposed solution\" : \"Save\", \"class\": \"saveButton\" + (editor_model.canSave || editor_model.disambiguationMenu ? \"\" : \" disabled\") + (editor_model.isSaving ? \" to-be-selected\" : \"\"),\n          id: \"savebutton\"  \n        },\n          {onclick: editor_model.disambiguationMenu ? \n            ((ambiguityKey, selected) => () => acceptAmbiguity(ambiguityKey, selected))(\n              editor_model.disambiguationMenu.ambiguityKey, editor_model.disambiguationMenu.selected)\n            : function(event) {\n              if (editor_model.isSaving) {\n                sendNotification(\"Can't save while save is being undertaken\");\n              }else {\n                if(!this.classList.contains(\"disabled\")) {\n                  sendModificationsToServer();\n                }\n              }\n            }\n          }\n        )\n        addPinnedModifyMenuIcon(undoSVG + \"<span class='modify-menu-icon-label'>Undo</span>\", \n          {\"class\": \"inert\", title: \"Undo most recent change\",\n            id: \"undobutton\"\n          },\n          {onclick: function(event) {\n            if(!undo()) sendNotification(\"Nothing to undo!\");\n            }\n          }   \n        );\n        addPinnedModifyMenuIcon(redoSVG + \"<span class='modify-menu-icon-label'>Redo</span>\",\n          {\"class\": \"inert\", title: \"Redo most recent undo\",\n            id: \"redobutton\"\n          },\n        \t{onclick: function(event) {\n        \t if(!redo()) sendNotification(\"Nothing to redo!\");\n            }\n          }\n        );\n      }\n      else {\n        addPinnedModifyMenuIcon(escapeSVG + \"<span class='modify-menu-icon-label-link'>Cancel</span>\", \n          {\"class\": \"link-select-button\", title: \"Go back to original screen\",\n            id: \"escapebutton\"\n          },\n          {onclick: function(event) {\n              escapeLinkMode();\n            }\n          }\n        );\n        addPinnedModifyMenuIcon(checkSVG + \"<span class='modify-menu-icon-label-link'>Select</span>\", \n          {\"class\": \"link-select-button\", title: editor_model.linkSelectMsg || \"Select target\",\n            id: \"selectbutton\"\n          },\n          {onclick: function(event) {\n              editor_model.linkSelectCallback(editor_model.clickedElem);\n              escapeLinkMode();\n            }\n          }\n        );\n        if(editor_model.linkSelectOtherMenus) {\n          editor_model.linkSelectOtherMenus(addPinnedModifyMenuIcon)\n        }\n      }\n      if(model.advanced || model.disambiguationMenu) {\n        modifyMenuDiv.append(\n          el(\"a\", { class:\"troubleshooter\", href: \"https://github.com/MikaelMayer/Editor/issues\"}, \"Help\"));\n        modifyMenuIconsDiv.append(\n          el(\"span\", { class:'filename', title:\"the path of the file you are currently viewing\"}, \n            editor_model.path ? editor_model.path : \"[root folder]\"));\n        // TODO: Ambiguity interaction (should be stored in the model)\n        // TODO: Current URL (can be changed) + reload button (double circular arrow) + list files button (folder icon)\n        // TODO: Stage/create draft (clone and save icon)\n        // TODO: Source code (expandable - can use Ace Editor)\n        // TODO: Options: Ask questions, Autosave.\n        // TODO: Report issue. About.\n        addModifyMenuIcon(sourceSVG,\n          {\"class\": \"tagName\" + (model.displaySource ? \" selected\" : \"\"), title: model.displaySource ? \"Hide source\" : \"Show Source\"},\n            {onclick: function(event) { editor_model.displaySource = !editor_model.displaySource; updateInteractionDiv(); } }\n        );\n        //when we click reload, it will save the current scroll position as the one it was at the beginning of the run\n        addModifyMenuIcon(reloadSVG,\n          {\"class\": \"tagName\", title: \"Reload the current page\"},\n            {onclick: function(event) { editor_model.curScrollPos = (editor_model.displaySource ? document.getElementById(\"sourcecontentmodifier\").scrollTop : 0);\n              reloadPage(); } }\n        );\n        addModifyMenuIcon(folderSVG,\n          {\"class\": \"tagName\", title: \"List files in current directory\"},\n            {onclick: function(event) {\n              let u =  new URL(location.href);\n              u.pathname = u.pathname.replace(/[^\\/]*$/, \"\");\n              u.searchParams.set(\"ls\", \"true\");\n              navigateLocal(u.href);\n            }\n          }\n        );\n        const flog = () => el(\"textarea\", {id:\"fullLog\", class:\"textarea logger\", visibility:false, readonly:true, isghost:true}, [], {});\n        function toggleEditorLog() {\n          //function el(tag, attributes, children, properties) \n          let log = document.getElementById(\"fullLog\");\n          if (!log) {\n            log = flog();\n            log.style.zIndex = 100;\n            log.style.display = 'none';\n            modifyMenuDiv.append(log);\n          }\n          let logtxt = \"\";\n          const elog = editor_model.editor_log;\n          for (let i = 0; i < elog.length; i++) {\n            const l = elog[i];\n            logtxt = logtxt + l + \"\\n\";\n          }\n          logtxt == \"\" ? log.value = \"(no log)\" : log.value = logtxt;\n          if (log.style.display == 'block') {\n            editor_model.show_log = false;\n            log.style.visibility = false;\n            log.style.display = 'none';\n          } else {\n            editor_model.show_log = true;\n            log.style.visibility = true;\n            log.style.display = 'block';\n          }\n        }\n        addModifyMenuIcon(logSVG,\n          {\"class\": \"tagName\", title: \"Display the full log\"},\n            {onclick: function(e) {\n              toggleEditorLog();\n            }});\n        const isfulog = editor_model.show_log;\n        if (editor_model.show_log) {\n          let log = document.getElementById(\"fullLog\");\n          if (!log) {\n            log = flog();\n            modifyMenuDiv.append(log);\n          }\n          let logtxt = \"\";\n          const elog = editor_model.editor_log;\n          for (let i = 0; i < elog.length; i++) {\n            const l = elog[i];\n            logtxt = logtxt + l + \"\\n\";\n          }\n          logtxt == \"\" ? log.value = \"(no log)\" : log.value = logtxt;\n          editor_model.show_log = true;\n          log.style.visibility = true;\n          log.style.display = 'block';\n        }\n  \n        if(editor_model.disambiguationMenu) {\n          interactionDiv.append(editor_model.disambiguationMenu);\n        \tinteractionDiv.append(el(\"button.modifyMenuButton#cancelAmbiguity\", \n        \t\t{title: \"Revert to the original version\"}, \"Cancel\",\n        \t\t{onclick: function(event) {cancelAmbiguity(editor_model.disambiguationMenu.ambiguityKey, editor_model.disambiguationMenu.selected)}}));\n        }\n        if(editor_model.feedback) {\n          interactionDiv.append(editor_model.feedback);\n        }\n        if(model.displaySource) {\n          let source = document.querySelector(\"#modify-menu\").getAttribute(\"sourcecontent\");\n          interactionDiv.append(el(\"div\", {\"class\": \"tagName\"},\n             [el(\"textarea\",\n                  {style: \"width:100%; height: 100%\",\n                   id: \"sourcecontentmodifier\", placeholder: \"Source of the page, before evaluation\", \"class\": \"templateengine\"}, [], {\n                onkeyup: function() {\n                  if(document.querySelector(\"#modify-menu\").getAttribute('sourcecontent') !== this.value)\n                    document.querySelector(\"#modify-menu\").setAttribute('sourcecontent', this.value);\n                  },\n                value: source\n               })])); \n          let sourceEdit = document.getElementById(\"sourcecontentmodifier\");\n          sourceEdit.scrollTop = editor_model.curScrollPos;\n        }\n        modifyMenuDiv.append(\n          el(\"label\", {class:\"switch\", title: \"If off, ambiguities are resolved automatically. Does not apply for HTML pages\"},\n            [el(\"input\", {class: \"global-setting\", id: \"input-question\", type: \"checkbox\"}, [], {\n              onchange: function() { editor_model.askQuestions = this.checked; },\n              checked: editor_model.askQuestions}),\n             el(\"span\", {class:\"slider round\"})]));\n        modifyMenuDiv.append(\n          el(\"label\", {\"for\": \"input-question\", class: \"label-checkbox\"}, \"Ask questions\"));\n        modifyMenuDiv.append(el(\"br\"));\n        modifyMenuDiv.append(\n          el(\"label\", {class:\"switch\", title: \"If on, changes are automatically propagated 1 second after the last edit\"}, [\n            el(\"input\", {class: \"global-setting\", id: \"input-autosave\", type:\"checkbox\"}, [], {\n              onchange: function() { editor_model.autosave = this.checked; },\n            checked: editor_model.autosave}),\n             el(\"span\", {class:\"slider round\"})])\n        )\n        modifyMenuDiv.append(\n          el(\"label\", {\"for\": \"input-autosave\", class: \"label-checkbox\"}, \"Auto-save\"));\n      } else if(model.insertElement)  {\n        interactionDiv.classList.add(\"insert-information-style\");\n        interactionDiv.classList.add(\"information-style\");\n        interactionDiv.append(el(\"h1\", {}, \"Insert\"));\n        interactionDiv.append(el(\"div\", {id: \"insertionPlace\"}, [\n          clickedElem.tagName === \"BODY\" || clickedElem.tagName === \"HTML\" || clickedElem.tagName === \"HEAD\" ? undefined :\n            el(\"span\", {class: \"insertOption\"}, [\n              el(\"input\", {type: \"radio\", id: \"radioInsertBeforeNode\", name: \"insertionPlace\", value: \"before\"}),\n              el(\"label\", {\"for\": \"radioInsertBeforeNode\"}, \"Before node\")]),\n          clickedElem.tagName === \"HTML\" || !model.caretPosition ? undefined :\n            el(\"span\", {class: \"insertOption\"}, [\n              el(\"input\", {type: \"radio\", id: \"radioInsertAsFirstChild\", name: \"insertionPlace\", value: \"first-child\"}, [], {checked: clickedElem.tagName === \"BODY\" || clickedElem.tagName === \"HEAD\" }),\n              el(\"label\", {\"for\": \"radioInsertAsFirstChild\"}, \"As first child\")], {onclick: restoreCaretPosition}),\n          clickedElem.tagName === \"HTML\" || !model.caretPosition ? undefined :\n            el(\"span\", {class: \"insertOption\"}, [\n              el(\"input\", {type: \"radio\", id: \"radioInsertAtCaret\", name: \"insertionPlace\", value: \"caret\"}, [], {checked: clickedElem.tagName === \"BODY\" || clickedElem.tagName === \"HEAD\" }),\n              el(\"label\", {\"for\": \"radioInsertAtCaret\"}, \"At caret\")], {onclick: restoreCaretPosition}),\n          clickedElem.tagName === \"HTML\" || !model.caretPosition ? undefined :\n            el(\"span\", {class: \"insertOption\"}, [\n              el(\"input\", {type: \"radio\", id: \"radioInsertAsLastChild\", name: \"insertionPlace\", value: \"last-child\"}, [], {checked: clickedElem.tagName === \"BODY\" || clickedElem.tagName === \"HEAD\" }),\n              el(\"label\", {\"for\": \"radioInsertAsLastChild\"}, \"As last child\")], {onclick: restoreCaretPosition}),\n          clickedElem.tagName === \"BODY\" || clickedElem.tagName === \"HTML\" || clickedElem.tagName === \"HEAD\" ? undefined :\n            el(\"span\", {class: \"insertOption\"}, [\n              el(\"input\", {type: \"radio\", id: \"radioInsertAfterNode\", name: \"insertionPlace\", value: \"after\"}, [], {checked: clickedElem.tagName !== \"BODY\" && clickedElem.tagName !== \"HEAD\"  }),\n              el(\"label\", {\"for\": \"radioInsertAfterNode\"}, \"After node\")]),\n          clickedElem.tagName === \"BODY\" || clickedElem.tagName === \"HTML\" || clickedElem.tagName === \"HEAD\" ? undefined :\n            el(\"span\", {class: \"insertOption\"}, [\n              el(\"input\", {type: \"radio\", id: \"radioInsertWrapNode\", name: \"insertionPlace\", value: \"wrap\"}),\n              el(\"label\", {\"for\": \"radioInsertWrapNode\", title: \"Put the selected node inside the newly inserted node\"}, \"Wrap node\")]),\n        ]));\n        let insertTag = function(event, newElement) {\n          newElement = newElement || (() => {\n            let parent = this;\n            while(parent && !parent.classList.contains(\"tagName\")) parent = parent.parentElement;\n            let m = parent.querySelector(\".templateengine\");\n            if(typeof m.innerHTMLCreate === \"string\") return m.innerHTMLCreate;\n            return el(m.createParams.tag, m.createParams.attrs, m.createParams.children, m.createParams.props);\n          })();\n          var insertionStyle = (() => {\n            let radios = document.querySelectorAll('#insertionPlace input[name=insertionPlace]');\n            let defaultValue = \"after\";\n            for (let i = 0, length = radios.length; i < length; i++) {\n              if (radios[i].checked) return radios[i].getAttribute(\"value\");\n              defaultValue = radios[i].getAttribute(\"value\");\n            } \n            return defaultValue;\n          })();\n          if(insertionStyle === \"after\") {\n            if(typeof newElement === \"string\") {\n              clickedElem.insertAdjacentHTML(\"afterend\", newElement);\n            } else {\n              clickedElem.parentElement.insertBefore(newElement, clickedElem.nextSibling);\n            }\n          } else if(insertionStyle === \"before\") {\n            if(typeof newElement === \"string\") {\n              clickedElem.insertAdjacentHTML(\"beforebegin\", newElement);\n            } else {\n              clickedElem.parentElement.insertBefore(newElement, clickedElem);\n            }\n          } else if(insertionStyle === \"wrap\") {\n            if(typeof newElement === \"string\") {\n              clickedElem.insertAdjacentHTML(\"beforebegin\", newElement);\n              newElement = clickedElem.previousElementSibling;\n            } else {\n              newElement.innerHTML = \"\";\n              clickedElem.parentElement.insertBefore(newElement, clickedElem);\n              console.log(\"newElement's parent HTML\", newElement.parentElement.outerHTML);\n            }\n            newElement.appendChild(clickedElem);\n            console.log(\"newElement's parent HTML\", newElement.parentElement.outerHTML);\n          } else if(insertionStyle === \"caret\") {\n            let s = model.caretPosition;\n            let txt = s.startContainer;\n            if(txt.textContent.length > s.startOffset && s.startOffset > 0) { // split\n              // Need to split the text node.\n              txt.parentElement.insertBefore(document.createTextNode(txt.textContent.substring(s.startOffset)), txt.nextSibling);\n              txt.textContent = txt.textContent.substring(0, s.startOffset);\n            }\n            if(typeof newElement === \"string\") {\n              let tmpSpan = el(\"span\");\n              clickedElem.insertBefore(tmpSpan, txt.nextSibling)\n              tmpSpan.insertAdjacentHTML(\"afterend\", newElement);\n              tmpSpan.remove();\n            } else {\n              clickedElem.insertBefore(newElement, txt.nextSibling)\n            }\n          } else if(insertionStyle === \"last-child\") { // Insert at the end of the selected element, inside.\n            if(typeof newElement === \"string\") {\n              let tmpSpan = el(\"span\");\n              clickedElem.insertBefore(tmpSpan, null);\n              tmpSpan.insertAdjacentHTML(\"beforeend\", newElement);\n              tmpSpan.remove();\n            } else {\n              // Insert at the end.\n              clickedElem.insertBefore(newElement, null);\n            }\n          } else if(insertionStyle === \"first-child\") { // Insert at the end of the selected element, inside.\n            if(typeof newElement === \"string\") {\n              let tmpSpan = el(\"span\");\n              clickedElem.insertBefore(tmpSpan, null);\n              tmpSpan.insertAdjacentHTML(\"afterbegin\", newElement);\n              tmpSpan.remove();\n            } else {\n              // Insert at the beginning.\n              clickedElem.prepend(newElement);\n            }\n          }\n          editor_model.insertElement = false;\n          editor_model.visible = true;\n          if(typeof newElement !== \"string\") {\n            editor_model.clickedElem = newElement;\n            updateInteractionDiv();\n          } else {\n            editor_model.clickedElem = clickedElem;\n            updateInteractionDiv();\n          }\n        }\n        let addElem = function(name, createParams) {\n          interactionDiv.append(\n            el(\"div\", {\"class\": \"tagName\"},\n              el(\"span\", { \"class\": \"templateengine\"}, name, createParams), { onclick: insertTag }\n            )\n          );\n        }\n        if(clickedElem.tagName === \"HEAD\") {\n          addElem(\"Title\", {tag:\"title\", children: \"Page_title\"});\n          addElem(\"Style\", {tag:\"style\", children: \"/*Your CSS there*/\"});\n          addElem(\"Script\", {tag:\"script\", children: \"/*Your CSS below*/\"});\n        } else {\n          interactionDiv.append(\n            el(\"div\", {\"class\":\"modify-menu-icon\", id: \"selectExistingNodeToMove\", title: \"Select an existing node to move\"}, [], {\n                innerHTML: linkModeSVG,\n                onclick: function(event) {\n                  editor_model.insertElement = false;\n                  activateNodeSelectionMode(\n                    \"to move\",\n                    node => insertTag.call(this, event, node),\n                    addPinnedModifyMenuIcon => {\n                      addPinnedModifyMenuIcon(cloneSVG + \"<span class='modify-menu-icon-label-link'>Clone</span>\", \n                        {\"class\": \"link-select-button\", title: \"Confirm to clone\",\n                          id: \"selectbutton\"\n                        },\n                        {onclick: function(event) {\n                          let node = editor_model.clickedElem;\n                          let clonedNode = editor.duplicate(node, {ignoreText: true});\n                          insertTag.call(this, event, clonedNode);\n                          escapeLinkMode();\n                          editor_model.clickedElem = clonedNode;\n                          }\n                        }\n                      );\n                    }\n                  )\n                }\n              })\n          )\n          interactionDiv.append(el(\"input\", {\"type\": \"file\", multiple: \"\", value: \"Images or files...\"}, [], {\n            onchange: function(evt) { uploadFilesAtCursor(evt.target.files); }})\n          );\n          // TODO: Filter and sort which one we can add\n          console.log(\"got here!\");\n          addElem(\"List item\", {tag:\"li\", props: { innerHTML: \"<br>\" }});\n          addElem(\"Bulleted list\", {tag:\"ul\", props: { innerHTML: \"<ul>\\n<li><br></li>\\n</ul>\" }});\n          addElem(\"Numbered list\", {tag:\"ol\", props: { innerHTML: \"<ol>\\n<li><br></li>\\n</ol>\" }});\n          addElem(\"Button\", {tag: \"button\", props: {innerHTML: \"Name_your_button\" }});\n          // something is wrong with creating link and paragraph using childCreate\n          // addElem(\"Link\", {tag:\"a\", childCreate: \"Name_your_link\"});\n          // addElem(\"Paragraph\", {tag:\"p\", childCreate: \"Inserted paragraph\"});\n          addElem(\"Link\", {tag: \"a\", props: { innerHTML: \"Name_your_link\", href: \"\" }});\n          addElem(\"Paragraph\", {tag: \"p\", props: { innerHTML: \"Insert_paragraph\" }});\n          for(let i = 1; i <= 6; i++) {\n            addElem(\"Header \" + i, {tag:\"h\" + i, props: { innerHTML: \"Title\" + i }});\n          }\n        }\n        interactionDiv.append(\n          el(\"div\", {\"class\": \"tagName\", id: \"customHTML\"}, [\n            el(\"textarea\", {id: \"customHTMLToInsert\", placeholder: \"Custom HTML here...\", \"class\": \"templateengine\", onkeyup: \"this.innerHTMLCreate = this.value\"}),\n            el(\"div\", {\"class\":\"modify-menu-icon\", title: \"Insert HTML\", style: \"display: inline-block\"}, [], {\n                innerHTML: plusSVG, \n                onclick: insertTag\n              }\n            )\n          ])\n        );\n        document.querySelector(\"#modify-menu\").classList.toggle(\"visible\", true);\n      } else {\n      if(clickedElem) {\n        interactionDiv.classList.add(\"information-style\");\n        /*\n          Build the DOM node selector:\n          Two parts:\n          |-----------------------|\n          |      main element     |\n          |-----------------------|\n          |  children / siblings  |\n          |-----------------------|\n          Two status:\n          editor_model.displayClickedElemAsMainElem = true\n          Status 1 (default). Show current clicked element as main element on the top:\n          |-----------------------|\n          |    clicked element*   |\n          |-----------------------|\n          |   children elements   |\n          |-----------------------|\n          Status 2. Show current clicked element's parent element as main element on the top:\n          |-----------------------------------------------------|\n          |                  parent element                     |\n          |-----------------------------------------------------|  \n          | previous sibling | clicked element* | next sibling  |\n          |-----------------------------------------------------|\n          All the HTML elements (except empty parts) in the selector can be clicked.\n          Check parent: When the clicked element in status 1 is clicked in selector, the selector switches to status 2 (display its parent as main element in first level).\n          Check parent: When the parent element in status 2 is clicked in selector, the selector remains status 2 while the parent element becomes current clicked element.\n          \n          Check children: When the children element in status 1 is clicked in selector, it will become clicked element in status 1.\n          Check children: When the clicked elements in status 2 is clicked in selector, the selector switches to status 1 (only if it has children).\n          \n          Check siblings: When the siblings in status 2 is clicked in selector, the sibling will become 'clicked element' but the selector won't switch status 1. \n          The siblings will be in the middle of second level of status 2. This is because we want user switching siblings in second level easily.\n          When other elements in selector are clicked, change 'clicked element' to it. And it also follow rules above.\n          Bonus feature (Memoization):\n            When user select DOM nodes along DOM tree from bottom to top continuously, the selector will remember its traverse path.\n            When user tries to traverse back through DOM tree from top to bottom, the selector will show previous visited children element with its parent element.\n            img -> div -> body\n            body -> div -> img\n            The main point is to decide which child should be displayed in the middle of second part (children element part) of selector in status 1.\n            Implementation:\n              editor_model.previousVisitedElem = [], as a stack storing DOM node path\n              \n              When user tries to visit siblings, clear the stack because previous path is broken, should restart memorizing\n              When user tries to visit parent element:\n                if the stack is empty, store current element and the parent element into stack;\n                if the stack contains sth.: if the top element of stack is the child of the parent element, then stores the parent element, otherwise clear the stack \n              \n              When user tries to visit children element (traverse back):\n              if the stack is empty, show first 3 children of clicked element\n                if current clicked element is the top element of stack, pop the top element then show the top element of stack as middle children\n                otherwise clear the stack, then follow first rule\n        */\n        domSelector.classList.add(\"dom-selector-style\");\n        domSelector.append(\n          el(\"div\", {\"class\": \"mainElem\"}, []),\n          el(\"div\", {\"class\": \"childrenElem\"}, [])\n        );\n        let displayMainElem = function(elem) {\n          let mainElemDiv = document.querySelector(\".dom-selector > .mainElem\");\n          mainElemDiv.append(\n            el(\"div\", {\"class\":\"mainElemName\", \"type\":\"text\", value: elem.tagName.toLowerCase()}, \"<\" + elem.tagName.toLowerCase() + \">\", {\n              onmouseenter: (c => () => { c.setAttribute(\"ghost-hovered\", \"true\") })(elem),\n              onmouseleave: (c => () => { c.removeAttribute(\"ghost-hovered\") })(elem)\n            }),\n            el(\"div\", {\"class\": \"mainElemInfo\"}, textPreview(elem, 50))\n          );\n        }\n        let displayChildrenElem = function(elem) {\n          let childrenElemDiv = document.querySelector(\".dom-selector > .childrenElem\");\n          childrenElemDiv.append(\n            el(\"div\", {\"class\": \"childrenSelector\"},\n              [\n                el(\"div\", {\"class\": \"childrenSelectorName\"}, \"<\" + elem.tagName.toLowerCase() + \">\", {}),\n                // el(\"div\", {\"class\": \"childrenSelectorInfo\"}, textPreview(elem, 20))\n              ], \n              {\n                onmouseenter: (c => () => { c.setAttribute(\"ghost-hovered\", \"true\") })(elem),\n                onmouseleave: (c => () => { c.removeAttribute(\"ghost-hovered\") })(elem)\n              }\n            )\n          );\n        }\n        // show attributes of element on the dom selector\n        let displayElemAttr = function(targetDiv, elem) {\n          for (let i = 0; elem && elem.attributes && i < elem.attributes.length; i++) {\n            let name = elem.attributes[i].name;\n            let value = elem.attributes[i].value;\n            if (name === \"ghost-clicked\" || name === \"ghost-hovered\") continue;\n            targetDiv.append(\n              el(\"div\", { \"class\": \"elementAttr\" },\n                [\n                  el(\"span\", { title: \"This element has attribute name '\" + name + \"'\" }, name + \": \"),\n                  el(\"span\", { title: \"This element has attribute value '\" + value + \"'\" }, value)\n                ]\n              )\n            );\n          }\n        }\n        // display children and siblings in the second part of selector\n        let displayChildrenSiblings = function(middleChild, selectMiddleChild) {\n          // display clicked element's previous sibling, clicked element, clicked element's next sibling\n          let cnt = 0;\n          // display previous sibling\n          if (middleChild.previousElementSibling && \n              (middleChild.previousElementSibling.id !== \"context-menu\" || middleChild.previousElementSibling.id !== \"modify-menu\" || middleChild.previousElementSibling.id !== \"editbox\")) {\n            displayChildrenElem(middleChild.previousElementSibling);\n            document.querySelectorAll(\".childrenElem > .childrenSelector\")[cnt].onclick = function () {\n              let c = middleChild.previousElementSibling;\n              if ((c.tagName && c.tagName === \"HTML\") || !c.tagName) {\n                return;\n              }\n              // still in status 2, but clicked element change to previous sibling\n              editor_model.displayClickedElemAsMainElem = false;\n              editor_model.previousVisitedElem = []; // clear the stack\n              editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\n              editor_model.clickedElem = c;\n              editor_model.notextselection = true;\n              updateInteractionDiv();\n            }\n          } else {\n            let childrenElemDiv = document.querySelector(\".dom-selector > .childrenElem\");\n            childrenElemDiv.append(\n              el(\"div\", {\"class\": \"childrenSelector no-sibling\"}, \"no sibling\")\n            );\n          }\n          cnt++;\n          // display certain child in the middle\n          displayChildrenElem(middleChild);\n          document.querySelectorAll(\".childrenElem > .childrenSelector\")[cnt].onclick = function () {\n            let c = middleChild;\n            if (!c.tagName) {\n              return;\n            }\n\n            if (!c.hasChildNodes() || (clickedElem.childNodes.length == 1 && clickedElem.childNodes[0].nodeType === 3)) {\n               // still in status 2\n              editor_model.displayClickedElemAsMainElem = false;\n            } else {\n              // switch to status 1\n              editor_model.displayClickedElemAsMainElem = true;\n            }\n            editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\n            editor_model.clickedElem = c;\n            editor_model.notextselection = true;\n            updateInteractionDiv();\n          }\n          if (selectMiddleChild) {\n            document.querySelectorAll(\".childrenElem > .childrenSelector\")[cnt].classList.add(\"selectedDom\");\n          }\n          cnt++;\n          // display next sibling\n          if (middleChild.nextElementSibling && \n             (middleChild.nextElementSibling.id !== \"context-menu\" || middleChild.nextElementSibling.id !== \"modify-menu\" || middleChild.nextElementSibling.id !== \"editbox\")) {\n            displayChildrenElem(middleChild.nextElementSibling);\n            document.querySelectorAll(\".childrenElem > .childrenSelector\")[cnt].onclick = function () {\n              let c = middleChild.nextElementSibling;\n              if ((c.tagName && c.tagName === \"HTML\") || !c.tagName) {\n                return;\n              }\n              // still in status 2, but clicked element change to next sibling\n              editor_model.displayClickedElemAsMainElem = false;\n              editor_model.previousVisitedElem = []; // clear the stack\n              editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\n              editor_model.clickedElem = c;\n              editor_model.notextselection = true;\n              updateInteractionDiv();\n            }\n          } else {\n            let childrenElemDiv = document.querySelector(\".dom-selector > .childrenElem\");\n            childrenElemDiv.append(\n              el(\"div\", {\"class\": \"childrenSelector no-sibling\"}, \"no sibling\")\n            );\n          }\n        }\n        // editor itself should be invisible\n        if (clickedElem.id !== \"context-menu\" || clickedElem.id !== \"modify-menu\" || clickedElem.id !== \"editbox\") {\n          if (!clickedElem.hasChildNodes() || (clickedElem.childNodes.length == 1 && clickedElem.childNodes[0].nodeType === 3)) {\n            editor_model.displayClickedElemAsMainElem = false;\n          }\n          // status 1. display clicked element in main part\n          if (editor_model.displayClickedElemAsMainElem) {\n            let mainElemDiv = document.querySelector(\".dom-selector > .mainElem\");\n            displayMainElem(clickedElem);\n            domSelector.classList.add(\"selectedDom\");\n            mainElemDiv.onclick = function () {\n              if (!clickedElem.tagName) {\n                return;\n              }\n              // When the main element in selector is clicked, selector switch to status 2 so that user can see its parent element\n              editor_model.displayClickedElemAsMainElem = false;\n              editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\n              editor_model.clickedElem = clickedElem;\n              editor_model.notextselection = true;\n              updateInteractionDiv();\n            }\n            displayElemAttr(mainElemDiv, clickedElem);\n            // display children, if no previous selected child, display first 3 children elements in second part of selector\n            if (editor_model.previousVisitedElem.length < 2 ||\n                (editor_model.previousVisitedElem[editor_model.previousVisitedElem.length - 1] != clickedElem)) {\n              if (editor_model.previousVisitedElem.length !== 0) {\n                editor_model.previousVisitedElem = [];\n              }\n              if (clickedElem.children.length > 0) {\n                // only display first 3 children elements\n                let childrenElem = clickedElem.children;\n                for (let i = 0, cnt = 0; i < childrenElem.length && cnt < 3; ++i) {\n                  // prevent displaying editor itself\n                  if (childrenElem[i].id === \"context-menu\" || childrenElem[i].id === \"modify-menu\" || childrenElem[i].id === \"editbox\") {\n                    continue;\n                  }\n                  displayChildrenElem(childrenElem[i]);\n                  document.querySelectorAll(\".childrenElem > .childrenSelector\")[cnt].onclick = function () {\n                    let c = childrenElem[i];\n                    if (!c.tagName) {\n                      return;\n                    }\n\n                    if (!c.hasChildNodes() || (clickedElem.childNodes.length == 1 && clickedElem.childNodes[0].nodeType === 3)) {\n                      editor_model.displayClickedElemAsMainElem = false;\n                    } else {\n                      // still in status 1\n                      editor_model.displayClickedElemAsMainElem = true;\n                    }\n                    editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\n                    editor_model.clickedElem = c;\n                    editor_model.notextselection = true;\n                    updateInteractionDiv();\n                  }\n                  cnt++;\n                }\n              } else {\n                // document.querySelector(\".childrenElem\").append(\n                //     el(\"div\", {\"class\": \"no-children\"}, \"No Children\")\n                // );\n              }\n            } else {\n              editor_model.previousVisitedElem.pop();\n              let middleChild = editor_model.previousVisitedElem[editor_model.previousVisitedElem.length - 1];\n              displayChildrenSiblings(middleChild, false);\n            }\n          } else {\n            // status 2. display clicked element's parent element in main part\n            let mainElemDiv = document.querySelector(\".dom-selector > .mainElem\");\n            // <html> has no parent element\n            if (clickedElem.parentElement) {\n              displayMainElem(clickedElem.parentElement);\n              mainElemDiv.onclick = function () {\n                if (!clickedElem.parentElement.tagName) {\n                  return;\n                }\n                // still in status 2 while current clicked element's parent element becomes clicked element so that user can see grandparent element\n                editor_model.displayClickedElemAsMainElem = false;\n                // memoization. when user click parent element:\n                if (editor_model.previousVisitedElem.length === 0) {\n                  editor_model.previousVisitedElem.push(clickedElem);\n                  editor_model.previousVisitedElem.push(clickedElem.parentElement);\n                } else {\n                  if (editor_model.previousVisitedElem[editor_model.previousVisitedElem.length - 1] == clickedElem) {\n                    editor_model.previousVisitedElem.push(clickedElem.parentElement);   // continuous storing path\n                  } else {\n                    editor_model.previousVisitedElem = []; // clear the stack\n                  }\n                }\n                editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\n                editor_model.clickedElem = clickedElem.parentElement;\n                editor_model.notextselection = true;\n                updateInteractionDiv();\n              }\n              displayElemAttr(mainElemDiv, clickedElem.parentElement);\n            } else {\n              document.querySelector(\".mainElem\").append(\n                  el(\"div\", {\"class\": \"no-parent\"}, \"No Parent\")\n              );\n            }\n            displayChildrenSiblings(clickedElem, true);\n          }\n        }\n      }\n      \n        // _______ .__   __.  _______  \n        // |   ____||  \\ |  | |       \\ \n        // |  |__   |   \\|  | |  .--.  |\n        // |   __|  |  . `  | |  |  |  |  of DOM SELECTOR\n        // |  |____ |  |\\   | |  '--'  |\n        // |_______||__| \\__| |_______/ \n\n      var linkSelect = function() {\n        activateNodeSelectionMode(\"to link to\",\n          (linkFrom => linkTo => {\n            let targetID = linkTo.getAttribute(\"id\");\n            if(!targetID) {\n              targetID = \"ID\" + editor_model.idNum\n              linkTo.setAttribute(\"id\", targetID);\n              editor_model.idNum += 1;\n            }\n            else if(targetID.length > 100) {\n              targetID = targetID.trim();\n              linkTo.setAttribute(\"id\", targetID);\n            }\n            linkFrom.setAttribute(\"href\", \"#\" + targetID);\n          })(editor_model.clickedElem)\n        );\n      }\n\n      \n      let keyvalues = el(\"div\", {\"class\":\"keyvalues\"});\n      if (clickedElem) {\n        // modify tagname\n          keyvalues.append(\n            el(\"div\", {\"class\": \"keyvalue\"}, [\n              el(\"span\", {title: \"This element has tag name '\" + clickedElem.tagName.toLowerCase() + \"'\"}, \"tag: \"),\n              el(\"span\", {class:\"attribute-key-value\"}, [\n                el(\"input\", {\"type\": \"text\", value: clickedElem.tagName.toLowerCase(), \"id\": \"newTagName\"}, \n                  [], {\n                    onkeyup() {\n                       document.querySelector(\"#applyNewTagName\").classList.toggle(\"visible\", this.value !== this.getAttribute(\"value\") && this.value.match(/^\\w+$/));\n                    }\n                  }),\n                  el(\"input\", {\"type\": \"button\", id: \"applyNewTagName\", value: \"Set\", title: \"Apply new tag name\"}, [], {onclick() {\n                        let newel = el(document.querySelector(\"#newTagName\").value);\n                        let elements = clickedElem.childNodes;\n                        while(elements.length) {\n                          newel.append(elements[0]);\n                        }\n                        for(let i = 0; i < clickedElem.attributes.length; i++) {\n                          newel.setAttribute(clickedElem.attributes[i].name, clickedElem.attributes[i].value);\n                        }\n                        clickedElem.parentElement.insertBefore(newel, clickedElem);\n                        clickedElem.remove();\n                        editor_model.clickedElem = newel;\n                        updateInteractionDiv();\n                      }\n                    }\n                  ),\n                  el(\"div\", {id:\"newtagname-align-placeholder\"}, \" \")\n                ]\n              )\n            ])\n          );\n      }\n      for(let i = 0; clickedElem && clickedElem.attributes && i < clickedElem.attributes.length; i++) {\n        let name = clickedElem.attributes[i].name;\n        if(name === \"ghost-clicked\" || name === \"ghost-hovered\") continue;\n        let value = clickedElem.attributes[i].value;\n        if(false /*name == \"style\"*/) {\n          // Do something special for styles.\n        } else {\n          let isHref = name === \"href\" && clickedElem.tagName === \"A\";\n          keyvalues.append(\n            el(\"div\", {\"class\": \"keyvalue\"}, [\n              el(\"span\", {title: \"This element has attribute name '\" + name + \"'\"}, name + \": \"),\n              el(\"span\", {class: \"attribute-key-value\"}, [\n                el(\"input\", {\"type\": \"text\", value: value, \"id\": (\"dom-attr-\" + name)}, [], {\n                    onkeyup: ((name, isHref) => function () {\n                        clickedElem.setAttribute(name, this.value);\n                        if(isHref) {\n                          let livelinks = document.querySelectorAll(\".livelink\");\n                          for(let livelink of livelinks) {\n                            let finalLink = livelink.matches(\"#context-menu *\") ?\n                              `javascript:navigateLocal(relativeToAbsolute('${linkToEdit(this.value)}'))` : this.value;\n                            livelink.setAttribute(\"href\", finalLink);\n                            livelink.setAttribute(\"title\", \"Go to \" + this.value);\n                          }\n                        }\n                    })(name, isHref)\n                  }),\n                isHref ? el(\"div\", {title: \"Go to \" + model.link, \"class\": \"modify-menu-icon inert\"}, [], {\n                  innerHTML: liveLinkSVG(model.link)\n                }) : undefined,\n                isHref ? el(\"div\", {title: \"Select a node on the page to refer to\", \"class\": \"modify-menu-icon inert\"}, [], { \n                  innerHTML: linkModeSVG,\n                  onclick: linkSelect\n                }) : undefined,\n                el(\"div\", {\"class\":\"modify-menu-icon\", title: \"Delete attribute '\" + name + \"'\"}, [], {\n                  innerHTML: wasteBasketSVG,\n                  onclick: ((name) => function() {\n                    clickedElem.removeAttribute(name);\n                    editor_model.clickedElem = clickedElem;\n                    updateInteractionDiv();\n                    })(name)\n                  })\n                ]\n              )\n            ]\n          ));\n        }\n      }\n      let highlightsubmit = function() {\n        let attrName = this.parentElement.parentElement.querySelector(\"[name=name]\").value;\n        this.parentElement.parentElement.querySelector(\"div.modify-menu-icon\").disabled =\n          attrName === \"\" || attrName.trim() !== attrName\n      }\n\n\n      if(clickedElem && clickedElem.nodeType === 1) {\n        keyvalues.append(\n          el(\"div\", {\"class\": \"keyvalue keyvalueadder\"}, [\n            el(\"span\", {class: \"attribute-key\"}, el(\"input\", {\"type\": \"text\", placeholder: \"key\", value: \"\", name: \"name\"}, [], {onkeyup: highlightsubmit})),\n            el(\"span\", {class: \"attribute-key-value\"}, [\n              el(\"span\", {}, el(\"input\", {\"type\": \"text\", placeholder: \"value\", value: \"\", name: \"value\"}, [], {\n                onfocus: function() {\n                  let keyInput = document.querySelector(\"div.keyvalueadder input[name=name]\");\n                  if(keyInput && keyInput.value != \"\") {\n                    let name = document.querySelector(\"div.keyvalueadder input[name=name]\").value;\n                    clickedElem.setAttribute(\n                      name,\n                      document.querySelector(\"div.keyvalueadder input[name=value]\").value\n                    );\n                    updateInteractionDiv();\n                    let d=  document.querySelector(\"div.keyvalue input#dom-attr-\" + name);\n                    if(d) d.focus();\n                  }\n                },\n                onkeyup: highlightsubmit})),\n              el(\"div\", {\"class\":\"modify-menu-icon\", title: \"Add this name/value attribute\"}, [], {innerHTML: plusSVG,\n                disabled: true,\n                onclick() {\n                  clickedElem.setAttribute(\n                    this.parentElement.querySelector(\"[name=name]\").value,\n                    this.parentElement.querySelector(\"[name=value]\").value\n                  );\n                  updateInteractionDiv();\n                },\n                onkeyup: highlightsubmit })])\n          ])\n        );\n      }\n\n      function uploadImagesAtCursor(files) {\n        for (var i = 0, file; file = files[i]; i++) {\n          var targetPathName =  editor.getStorageFolder(file) + file.name;\n          editor.uploadFile(targetPathName, file, (targetPathName, file) => {\n            if(clickedElem.style.backgroundImage) {\n              clickedElem.style.backgroundImage = \"url(\" + targetPathName + \")\";\n            }\n            else {\n              document.getElementById(\"dom-attr-src\").setAttribute(\"value\", file.name);\n              clickedElem.setAttribute(\"src\", targetPathName);\n            }\n            // adapt to HTML5 new attribute 'srcset'\n            // IF website use 'srcset', we force to set this attribute to null then replace image using 'src'\n            if (clickedElem.getAttribute(\"srcset\") != undefined) {\n              clickedElem.setAttribute(\"srcset\", \"\");\n            }\n          });\n        }\n        // refresh images list\n        showListsImages(targetPathName);  // targetPathName is the last file of files array, but it seems that user can only upload one file once\n        // automatically select upload image\n        let selectedImage = document.querySelectorAll(\".imgFolder > img\");\n        for (let i = 0; i < selectedImage.length; ++i) {\n          let imgName = selectedImage[i].getAttribute(\"src\").split(\"/\").pop();\n          if (imgName === files[files.length - 1].name) {\n            selectedImage[i].parentElement.classList.add(\"highlight-select-image\");\n          } else {\n            selectedImage[i].parentElement.classList.remove(\"highlight-select-image\");\n          }\n        }\n      }\n      \n      function showListsImages(srcName) {\n        srcName = relativeToAbsolute(srcName);\n        let dir = \"\";\n        for(let i = 0, arr = srcName.split(/\\\\|\\//); i < arr.length - 1; ++i) {\n          dir += (arr[i] + \"/\");\n        }\n        files = editor.fs.listdir(dir);\n        \n        let images = [];\n        let currentSelectedImage;\n        files.forEach(file => {\n          let ext = file.split('.').pop().toLowerCase();\n          if (ext == 'jpeg' || ext == 'jpg' || ext == 'png' || ext == 'gif' || ext == 'svg' || ext == 'bmp') {\n            if (file.split('/').pop() === srcName.split(\"/\").pop().split(\"?\")[0]) {   // note that srcName maybe \"/1.jpg?raw=true\"\n              currentSelectedImage = file;\n            } else {\n              images.push(file);\n            }\n          }\n        });\n        // sometimes website use 'srcset' as the url of image, we cannot find currentSelectedImage precisely\n        if (currentSelectedImage != null) {\n          images.unshift(currentSelectedImage);   // currentSelectedImage should be placed as the first one\n        }\n\n        // init: clear image list\n        let selectedImage = document.querySelectorAll(\".imgFolder\");\n        selectedImage.forEach(e => e.remove());\n\n        let imgDiv = el(\"div\", { \"id\": \"imgGallery\" });\n        if (!document.getElementById(\"imgGallery\")) {\n          interactionDiv.append(imgDiv);\n        } else {\n          imgDiv = document.getElementById(\"imgGallery\");\n        }\n\n        for (let i = 0; i < images.length; ++i) {\n          imgDiv.append(\n            el(\"div\", { \"class\": \"imgFolder\" }, el(\"img\", { \"src\": dir + images[i], \"title\": images[i], \"alt\": images[i] },  [], {}), {\n              onclick() {\n                // highlight the selected image\n                let otherImages = document.querySelectorAll(\".imgFolder\");\n                for (let i = 0; i < otherImages.length; ++i) {\n                  otherImages[i].classList.remove(\"highlight-select-image\");\n                }\n                // replace image\n                // adapt to HTML5 new attribute 'srcset'\n                // IF website use 'srcset', we force to set this attribute to null then make image replacemenet\n                if (clickedElem.getAttribute(\"srcset\") != undefined) {\n                  clickedElem.setAttribute(\"srcset\", \"\");\n                }\n                if(!clickedElem.style.backgroundImage) {\n                  clickedElem.setAttribute(\"src\", this.children[0].getAttribute(\"src\"));\n                  document.getElementById(\"dom-attr-src\").setAttribute(\"value\", this.children[0].getAttribute(\"src\"));\n                }\n                else {\n                  clickedElem.style.backgroundImage = \"url('\" + this.children[0].getAttribute(\"src\") + \"')\"\n                  console.log(this.children[0].getAttribute(\"src\"));\n                }\n                this.classList.add(\"highlight-select-image\");\n              }\n            })\n          );\n        }\n        if (currentSelectedImage != null) {\n          document.querySelectorAll(\".imgFolder\")[0].classList.add(\"highlight-select-image\");\n        }\n      }\n      \n      interactionDiv.append(keyvalues);\n      if (clickedElem && (clickedElem.tagName === \"IMG\" || clickedElem.style.backgroundImage)) {\n        var backgroundImgURL = clickedElem.style.backgroundImage;\n        let srcName =  backgroundImgURL ? backgroundImgURL.match(/\\((.*?)\\)/)[1].replace(/('|\")/g,'') : clickedElem.getAttribute(\"src\");\n        \n        clickedElem.ondragover = function (e) {\n          e.preventDefault();\n        }\n        clickedElem.ondrop = function (e) {\n          // upload and replace the image\n          e.stopPropagation();\n          e.preventDefault();\n          var files = e.dataTransfer.files; // FileList object\n          if (files && files[0]) {\n            uploadImagesAtCursor(files);\n          }\n        }\n        // upload image button\n        interactionDiv.append(\n          el(\"a\", \n            { \"id\": \"upload-image-btn-a\" }, \n            el(\n              \"input\", {\"id\": \"upload-image-btn-input\", \"type\": \"file\", value: \"Please upload images...\"}, \n              [], \n              { onchange: function(evt) { uploadImagesAtCursor(evt.target.files); }}\n            ), \n            {}\n          )\n        );\n        \n        // show lists of images in selected image's folder\n        showListsImages(srcName);\n      }\n\n      let voidTags = {AREA: true, BASE: true, BR: true, COL: true, COMMANd: true, EMBED: true, HR: true, IMG: true, INPUT: true, KEYGEN: true, LINK: true, META: true, PARAM: true, SOURCE: true, TRACK: true, WBR: true};\n      //interactionDiv.append(el(\"hr\"));\n      // Nodes only with 1 text child\n      if(clickedElem && clickedElem.children.length === 0 && !voidTags[clickedElem.tagname]) {\n        // interactionDiv.append(el(\"hr\"));\n        let txt = el(\"textarea\", {id:\"singleChildNodeContent\"},\n          [], {\n            value: clickedElem.innerText,\n            onkeyup: function () { clickedElem.textContent = this.value; },\n            onscroll: function() { editor_model.textareaScroll = this.scrollTop },\n          });\n        interactionDiv.append(txt);\n        setTimeout((txt => () => {\n          txt.scrollTop = editor_model.textareaScroll;\n          txt.selectionEnd = editor_model.textareaSelectionEnd;\n          txt.selectionStart = editor_model.textareaSelectionStart;\n        })(txt), 0);\n      }\n      // let user modify button content\n      if(clickedElem && (clickedElem.tagName === \"BUTTON\")) {\n        // provide the onclick attribute to users so user can modify it in modify-menu\n        if (!clickedElem.hasAttribute(\"onclick\")) {\n          clickedElem.setAttribute(\"onclick\", \"\");\n          updateInteractionDiv();\n        }\n        if (!clickedElem.hasAttribute(\"type\")) {\n          clickedElem.setAttribute(\"type\", \"\");\n          updateInteractionDiv();\n        }\n      }\n    }\n    \n      if(!editor_model.linkSelectMode) {\n        contextMenu.innerHTML = \"\";\n        var whereToAddContextButtons = contextMenu;\n        var noContextMenu = false;\n        // What to put in context menu?\n        if(onMobile() || (editor_model.clickedElem && editor_model.clickedElem.matches(\"html, head, head *, body\"))) {\n          whereToAddContextButtons = modifyMenuIconsDiv;\n          noContextMenu = true;\n        }\n        let numButtons = 0;\n        let addContextMenuButton = function(innerHTML, attributes, properties) {\n          let button = el(\"div\", attributes, [], properties);\n          button.onmousedown = button.onmousedown ? button.onmousedown : preventTextDeselection;\n          button.classList.add(\"context-menu-button\");\n          button.innerHTML = innerHTML;\n          whereToAddContextButtons.append(button);\n          numButtons++;\n        }\n        if(model.link) {\n          addContextMenuButton(liveLinkSVG(linkToEdit(model.link)),\n            {title: \"Go to \" + model.link, \"class\": \"inert\"});\n        }\n        var computedStyle = clickedElem && window.getComputedStyle(clickedElem);\n        var isDisplayInline = computedStyle && computedStyle.display.startsWith(\"inline\");\n        if(!model.selectionRange && clickedElem && clickedElem.previousElementSibling && reorderCompatible(clickedElem.previousElementSibling, clickedElem)) {\n          addContextMenuButton(isDisplayInline ? arrowLeft : arrowUp,\n          {title: \"Move selected element \" + (isDisplayInline ? \"to the left\" : \"up\")},\n          {onclick: (c => event => {\n              let wsTxtNode = c.previousSibling && c.previousSibling.nodeType == 3 &&\n                c.previousSibling.textContent.trim() === \"\" ? c.previousSibling : undefined;\n              // There is whitespace before this element, we try to reinsert\n              c.parentElement.insertBefore(c, c.previousElementSibling);\n              if(wsTxtNode) { // We move the whitespace as well.\n                c.parentElement.insertBefore(wsTxtNode, c.previousElementSibling);\n              }\n              editor_model.clickedElem = c;\n              updateInteractionDiv();\n            })(clickedElem)\n          });\n        }\n        if(!model.selectionRange && clickedElem && clickedElem.nextElementSibling && reorderCompatible(clickedElem, clickedElem.nextElementSibling)) {\n          addContextMenuButton(isDisplayInline ? arrowRight : arrowDown,\n          {title: \"Move selected element \" + (isDisplayInline ? \"to the right\" : \"down\")},\n          {onclick: (c => (event) => {\n              let wsTxtNode = c.nextSibling && c.nextSibling.nodeType == 3 && \n                c.nextSibling.textContent.trim() === \"\" ? c.nextSibling : undefined;\n              let nodeToInsertAfter = c.nextElementSibling;\n              nodeToInsertAfter.insertAdjacentElement(\"afterend\", c);\n              if(wsTxtNode) { // We move the whitespace as well\n                nodeToInsertAfter.parentElement.insertBefore(wsTxtNode, nodeToInsertAfter.nextSibling);\n              }\n              editor_model.clickedElem = c;\n              updateInteractionDiv();\n            })(clickedElem)\n          });\n        }\n        if(!model.selectionRange && clickedElem && clickedElem.tagName !== \"HTML\" && clickedElem.tagName !== \"BODY\" && clickedElem.tagName !== \"HEAD\") {\n          addContextMenuButton(cloneSVG,\n            {title: \"Clone selected element\"},\n            {onclick: ((c, contextMenu) => event => {\n                c.removeAttribute(\"ghost-clicked\");\n                let cloned = duplicate(c);\n                if(cloned) {\n                  editor_model.clickedElem = cloned;\n                  updateInteractionDiv();\n                } else contextMenu.classList.remove(\"visible\");\n              })(clickedElem, contextMenu)\n            });\n          addContextMenuButton(wasteBasketSVG,\n            {title: \"Delete selected element\"},\n            {onclick: (c => event => {\n                c.remove();\n                editor_model.clickedElem = undefined;\n                updateInteractionDiv();\n              })(clickedElem)\n            });\n        }\n        if(model.selectionRange && (model.selectionRange.startContainer === model.selectionRange.endContainer || model.selectionRange.startContainer.parentElement === model.selectionRange.commonAncestorContainer && model.selectionRange.endContainer.parentElement === model.selectionRange.commonAncestorContainer)) {\n          addContextMenuButton(plusSVG,\n              {title: \"Wrap selection\"},\n              {onclick: (s => event => {\n                let elements = [];\n                let tmp = s.startContainer;\n                let nodeToInsertAfter = s.startContainer;\n                let parent = nodeToInsertAfter.parentElement;\n                while(tmp && tmp !== s.endContainer.nextSibling) {\n                  if(tmp.nodeType === 3) {\n                    elements.push(tmp === s.startContainer ? tmp === s.endContainer ? tmp.textContent.substring(s.startOffset, s.endOffset) : tmp.textContent.substring(s.startOffset) :\n                      tmp === s.endContainer ? tmp.textContent.substring(0, s.endOffset) :\n                      tmp.textContent);\n                    if(tmp === s.startContainer) {\n                      if(tmp === s.endContainer && tmp.textContent.length > s.endOffset) {\n                        // Need to split the text node.\n                        tmp.parentElement.insertBefore(document.createTextNode(tmp.textContent.substring(s.endOffset)), tmp.nextSibling);\n                      }\n                      if(s.startOffset === 0) {\n                        nodeToInsertAfter = nodeToInsertAfter.previousSibling;\n                        tmp.remove();\n                      } else {\n                        tmp.textContent = tmp.textContent.substring(0, s.startOffset);\n                      }\n                    } else if(tmp === s.endContainer) {\n                      if(s.endOffset === s.endContainer.textContent.length) {\n                        tmp.remove();\n                      } else {\n                        tmp.textContent = tmp.textContent.substring(s.endOffset);\n                      }\n                    } else {\n                      tmp.remove();\n                    }\n                  } else {\n                    elements.push(tmp);\n                    tmp.remove();\n                  }\n                  tmp = tmp.nextSibling;\n                }\n                let insertedNode = el(\"span\", {\"ghost-clicked\": \"true\"});\n                for(let k of elements) {\n                  insertedNode.append(k);\n                }\n                let nodeToInsertBefore = nodeToInsertAfter ? nodeToInsertAfter.nextSibling : parent.childNodes[0];\n                parent.insertBefore(insertedNode, nodeToInsertBefore);\n                document.querySelector(\"#modify-menu\").classList.toggle(\"visible\", true);\n                editor_model.visible = true;\n                editor_model.clickedElem = insertedNode;\n                updateInteractionDiv();\n              })(model.selectionRange)}\n              )\n        }\n        if(!model.selectionRange) {\n          addContextMenuButton(plusSVG,\n              {title: \"Insert element\", contenteditable: false},\n              {onclick: event => {\n                editor_model.clickedElem = clickedElem;\n                editor_model.displayClickedElemAsMainElem = true;\n                editor_model.insertElement = true;\n                updateInteractionDiv();\n                restoreCaretPosition();\n              }});\n        }\n\n        let baseElem = clickedElem;\n        while(baseElem && (baseElem.tagName == \"SCRIPT\" || baseElem.tagName == \"STYLE\")) {\n          baseElem = baseElem.nextElementSibling;\n        }\n        baseElem = model.selectionRange || baseElem || clickedElem;\n      \n        if(baseElem && !noContextMenu) {\n          let clientRect = baseElem.getBoundingClientRect();\n          // Find out where to place context menu.\n          let clickedElemLeft = window.scrollX + clientRect.left;\n          let clickedElemTop = window.scrollY + clientRect.top;\n          let clickedElemBottom = window.scrollY + clientRect.bottom;\n          let clickedElemRight = window.scrollX + clientRect.right;\n          let desiredWidth = numButtons * buttonWidth();\n          let desiredLeft = (clickedElemLeft + clickedElemRight) / 2 - desiredWidth;\n          if(desiredLeft < clickedElemLeft) desiredLeft = clickedElemLeft;\n          let desiredTop = clickedElemTop - buttonHeight(); \n          if(desiredTop - window.scrollY < 9) {\n            desiredTop = clickedElemBottom;\n            if(desiredTop + buttonHeight() > window.innerHeight) {\n              desiredTop = window.innerHeight - buttonHeight(); \n            }\n          }\n          if(desiredLeft < 0) desiredLeft = 0;\n          if(desiredTop < 0) desiredTop = 0;\n          contextMenu.style.left = desiredLeft + \"px\";\n          contextMenu.style.top = desiredTop + \"px\";\n          contextMenu.style.width = desiredWidth + \"px\";\n          contextMenu.classList.add(\"visible\");\n          setTimeout(maybeRepositionContextMenu, 0);\n        }\n        if(noContextMenu) {\n          contextMenu.classList.remove(\"visible\");\n        }\n      }\n      return true;\n\n    } //end of updateInteractionDiv\n\n    function maybeRepositionContextMenu() {\n      //move the context menu if overlaps with modify-menu\n       let contextMenu = document.querySelector(\"#context-menu\");\n       let modifyMenuDiv = document.querySelector(\"#modify-menu\");\n       let pinnedIcons = document.querySelector(\".modify-menu-icons.pinned\")\n       let pcr = pinnedIcons.getBoundingClientRect();\n       let ccr = contextMenu.getBoundingClientRect();\n       let mcr = modifyMenuDiv.getBoundingClientRect();\n       if(onMobile()) {\n         if(ccr.bottom > pcr.top) {\n           contextMenu.style.top = (ccr.y - (ccr.bottom - pcr.top)) + \"px\"\n         } else if(ccr.bottom > mcr.top) {\n           contextMenu.style.top = (ccr.y - (ccr.bottom - mcr.top)) + \"px\"\n         }\n       } else {\n         if(ccr.right > pcr.left && ccr.top < pcr.bottom) { // Overlap with icons.\n           contextMenu.style.left = (ccr.x - (ccr.right - pcr.left)) + \"px\"\n         } else if(ccr.right > mcr.left) {\n           contextMenu.style.left = (ccr.x - (ccr.right - mcr.left)) + \"px\"\n         }\n       }\n    }\n\n    \n    @(if varedit == False && (listDict.get \"edit\" defaultOptions |> Maybe.withDefault False) == True then\n      -- Special case when ?edit=false but the default behavior is edit=true if nothing is set.\n      \"\"\"document.onclick = function (e) {\n          e = e ||  window.event;\n          var node = e.target || e.srcElement;\n          while(node) {\n            if(node.tagName == \"A\" && node.getAttribute(\"href\") && !node.onclick && !node.getAttribute(\"onclick\")) {\n             var newLocation = addEditEqualToUrl(node.getAttribute(\"href\"), \"false\");\n             console.log(newLocation);\n             window.location.href = newLocation;\n             e.stopPropagation();\n             return false;\n            } else {\n              node = node.parentNode;\n            }\n          }\n        }\"\"\"\n    else if varedit then\n      \"\"\"document.addEventListener('click', onClickGlobal, false);\n         document.addEventListener('mousedown', onMouseDownGlobal, false);\n      \"\"\"\n    else \"\")\n@(if iscloseable then \"\"\"\nwindow.onbeforeunload = function (e) {\n    e = e || window.event;\n\n    var askConfirmation = document.getElementById(\"manualsync-menuitem\") &&\n         document.getElementById(\"manualsync-menuitem\").getAttribute(\"ghost-disabled\") == \"false\";\n    const confirmation = 'You have unsaved modifications. Do you still want to exit?';\n\n    // For IE and Firefox prior to version 4\n    if (e) {\n      if(askConfirmation) {\n        e.returnValue = confirmation;\n      }\n    }\n    if(askConfirmation) {\n      // For Safari\n      return confirmation;\n    } else {\n      var xmlhttp = new XHRequest();\n      xmlhttp.onreadystatechange = handleServerPOSTResponse(xmlhttp);\n      xmlhttp.open(\"POST\", location.pathname + location.search, false); // Async\n      xmlhttp.setRequestHeader(\"close\", \"true\");\n      xmlhttp.send(\"{\\\"a\\\":1}\");\n    }\n}; //end of window.onbeforeload\n\"\"\" else \"\")\n    if (typeof editor_model === \"object\" && typeof editor_model.outputObserver !== \"undefined\") {\n      editor_model.outputObserver.disconnect();\n    }\n\n    editor_model.outputObserver = new MutationObserver(handleMutations);\n    editor_model.outputObserver.observe\n      ( document.body.parentElement\n      , { attributes: true\n        , childList: true\n        , characterData: true\n        , attributeOldValue: true\n        , characterDataOldValue: true\n        , subtree: true\n        }\n      );\n\"\"\"--end of lastEditionScript\n\ngooglesigninbutton = serverOwned \"the google sign-in button\" [\n<style>\na.closeGoogleSignIn {\n  margin-left: 2px;\n  padding-left: 4px;\n  padding-right: 5px;\n}\na.closeGoogleSignIn:hover {\n  background: #AAA;\n  color: white;\n  border-radius: 10px;\n}\n</style>,\n<div class=\"g-signin2\" data-onsuccess=\"onGoogleSignIn\" list-ghost-attributes=\"data-gapiscan data-onload\" children-are-ghosts=\"true\"></div>,\n<script>\nfunction onGoogleSignIn(googleUser) {\n  var profile = googleUser.getBasicProfile();\n  \n  var wasSignedIn = googleAuthIdToken ? true : false;\n  // When set, will be used throughout \n  googleAuthIdToken = googleUser.getAuthResponse().id_token;\n  var addSignout = (name) => {\n    var signin = document.querySelector(\".abcRioButtonContents\").children[1];\n    signin.setAttribute(\"title\", \"Signed in as \" + name);\n    var signout = document.createElement(\"a\");\n    signout.classList.add(\"closeGoogleSignIn\");\n    signout.setAttribute(\"title\", \"Sign out\");\n    signout.innerText = \"x\";\n    signout.onclick = () => {\n      var auth2 = gapi.auth2.getAuthInstance();\n      auth2.signOut().then(() => {\n        auth2.disconnect();\n        googleAuthIdToken = undefined;\n        console.log('User signed out.');\n      });\n    }\n    signin.append(signout);\n  }\n  addSignout(profile.getName());\n  if(!wasSignedIn) { // Necessary to ensure that we don't reload the page the second time it is loaded.\n    reloadPage();\n  }\n}\n</script>,\n<script id=\"googlesigninscript\" src=\"https://apis.google.com/js/platform.js\" async defer save-ghost-attributes=\"gapi_processed\"></script>\n]\n\ndefaultMarkdowncss = \"\"\"img {\n  max-width: 100%;\n}\npre {\n  padding: 10px 0 10px 30px;\n  color: cornflowerblue;\n}\na {\n  text-decoration: none;\n  font-weight: bold;\n  color: #0268cd;\n}\np {\n  margin: 1.0em 0 1.0em 0;\n}\nbody {\n  text-align: justify;\n  font-family: Geneva, Verdana, sans-serif;\n  line-height: 1.75em;\n  background-color: #C9CFCD;\n}\nh1, h2, h3, h4 {\n  letter-spacing: -1px;\n  font-weight: normal;\n  color: #171717;\n}\nh2 {\n\tfont-size: 2.25em;\n}\nh3 {\n  padding: 25px 0 0 0;\n\tfont-size: 1.75em;\n}\nh4 {\n\tfont-size: 1.25em;\n  margin-top: 1.25em;\n}\n.wrapper {\n  margin-left: auto;\n  margin-right: auto;\n  margin-top: 10px;\n  max-width: 900px;\n  padding-left: 20px;\n  padding-right: 20px;\n  padding-top: 20px;\n  background-color: white;\n}\"\"\"\n\nmain";

const defaultHtAccessFileContent = `if Regex.matchIn """\\.\\.(?:/|\\\\)|(?:/|\\\\)\\.\\.|^\\.\\.$""" path then False else
    not (Regex.matchIn """.*\\.pem""" path)`

function readServerFile() {
  if(fs.existsSync(serverFile)) {
    return fs.readFileSync(serverFile, "utf8");
  } else
    return defaultServerContent;
}

function readHtAccessFile() {
  if(fs.existsSync(htaccessFile)) {
    return fs.readFileSync(htaccessFile, "utf8");
  } else
    return defaultHtAccessFileContent;
}

const sns = require("sketch-n-sketch");

function evaluateToHtml(path, env, serverFileContent) {
  var result = sns.objEnv.string.evaluate(env)(serverFileContent);
  if(result.ctor == "Ok") {
    var out = sns.valToHTMLSource(result._0)
    if(out.ctor == "Ok") {
      return out;
    } else {
      return { ctor: "Err", _0: "Error while converting the result to HTML source file: " + out._0}
    }
  } else {
    return { ctor: "Err", _0: `Error while interpreting ${path}: ` + result._0}
  }
}

function lazyListToList(ll) {
  var x = [];
  while(sns.lazyList.nonEmpty(ll)) {
    x.push(sns.lazyList.head(ll));
    ll = sns.lazyList.tail(ll);
  }
  return x;
}

cachedSolutions = {
  key: {
     timestamp: 0,
     computed: [["html page", "environment vars", "fileOperations"],
                ["html page 2", "environment vars 2", "fileOperations 2..."]],
     remaining: "false, or a LazyList whose head element is last computed solution. Call getOneSolution(this.path, this.serverFileContent, sns.lazyList.tail(remaining)) on it to get one more solution if it exists",
     path: "The path that is being computed",
     serverFileContent: "The original source file of the server. Maybe be overwritten in fileOperations"
  }
}

// Retrieves the given solution by 1-based index from the set of solutions
// If the solution is the last computed, computes remaining solutions
function getSolutionByNum(solutionSet, num) {
  if(solutionSet.computed.length >= num && num >= 1) {
    if(solutionSet.computed.length == num) { // If we select the last computed solution, we checked if we can compute more solutions.
      if(solutionSet.remaining !== false) {
        console.log("Checking for ambiguity #" + (num + 1));
        var lt = sns.lazyList.tail(solutionSet.remaining);
        var newSolution = getOneSolution(solutionSet.path, solutionSet.serverFileContent, lt);
        if(newSolution === false) {
          console.log("No more ambiguity");
          solutionSet.remaining = false;
        } else {
          console.log("Ambiguity #" + (num + 1) + " found");
          solutionSet.remaining = lt;
          solutionSet.computed.push(newSolution);
        }
      }
    }
    return solutionSet.computed[num - 1];
  } else {
    console.log(`Requested invalid solution number ${num}. Returning the first`)
    return solutionSet.computed[0];
  }
}

function uniqueKey() {
  var potentialkey = +(new Date());
  while(typeof cachedSolutions["" + potentialkey] != "undefined") {
    potentialkey++;
  }
  return "" + potentialkey;
}

function envToVars(env) { return env.vars; }

function getOneSolution(path, serverFileContent, allSolutions) {
  if(sns.lazyList.isEmpty(allSolutions)) return false;
  var {_0: newEnv, _1: newServerFileContent} = sns.lazyList.head(allSolutions);
  if(newServerFileContent != serverFileContent) { // server file itself modified from the update method
    var d =
      sns.process(sns.objEnv.string.evaluate({x: serverFileContent, y: newServerFileContent})(`__diff__ x y`))(sns.valToNative)
    var diffsServerFileContent = 
      d.ctor == "Ok" ? d._0 ? d._0.args ? d._0.args._1 ? d._0.args._1.args ? d._0.args._1.args._1 ? d._0.args._1.args._1 :
        false : false : false : false : false : false;

    newEnv.fileOperations.unshift(
      leo.Tuple2(
       serverFile,
       leo.data("Write")(serverFileContent, newServerFileContent,diffsServerFileContent)
       ));
  }
  var fo = newEnv.fileOperations;
  var evaluated = evaluateToHtml(path, newEnv, newServerFileContent);
  return [evaluated, envToVars(newEnv), fo]; 
  // Evaluates everything given the temporary context of writing the files.
}

// Apply the given operations to the file system. TODO: Merge different writes to a single file.
function applyOperations(operations) {
  for(var i = 0; i < operations.length; i++) {
    var {_1: path, _2: action} = operations[i];
    if(action["$d_ctor"] == "Write") {
      fs.writeFileSync(path, action.args._2, "utf8");
    } else if(action["$d_ctor"] == "Create") {
      // TODO: Create the path if necessary
      fs.writeFileSync(path, action.args._1, "utf8");
    } else if(action["$d_ctor"] == "Rename") {
      if(path.startsWith("/")) path = path.substring(1);
      var newName = action.args._1;
      if(newName.startsWith("/")) newName = newName.substring(1);
      fs.renameSync(path, newName);
    } else if(action["$d_ctor"] == "Delete") {
      fs.unlinkSync(path);
    } else {
      console.log("unrecognized action:", action);
    }
  }
}

function stringDiffSummary(oldString, newString, stringDiffs) {
  if(stringDiffs["$d_ctor"] == "Nothing") return "[No change observed]";
  if(stringDiffs["$d_ctor"] == "Just") stringDiffs = stringDiffs.args._1;
  var listStringDiffs = stringDiffs.args._1; // It's a VStringDiffs
  var offset = 0;
  var summary = "";
  var lastLineNumber = -1;
  var lastEnd = -1;
  var lastLine = "";
  var lastLineAfterRemoved = "";
  for(var i = 0; i < listStringDiffs.length; i++) {
    var {args: {_1: start, _2: end, _3: replaced}} = listStringDiffs[i];
    var removed = oldString.substring(start, end);
    var inserted = newString.substring(start + offset, start + offset + replaced);
    var beforeRemoved = oldString.substring(0, start);
    var afterRemoved = oldString.substring(end);
    var linesBeforeRemoved = beforeRemoved.split(/\r?\n/);
    var lineNumber = linesBeforeRemoved.length;
    var charNumber = linesBeforeRemoved[linesBeforeRemoved.length - 1].length + 1;
    var lineBeforeRemoved = linesBeforeRemoved[linesBeforeRemoved.length - 1];
    var lineAfterRemoved = afterRemoved.split(/\r?\n/)[0];
    if(lineNumber === lastLineNumber) {
      summary += oldString.substring(lastEnd, start);
    } else {
      summary += lastLineAfterRemoved + "\nL" + lineNumber + "C" + charNumber + ":" +
        lineBeforeRemoved;
    }
    summary +=
          (removed === "" ? "" : "(---" + removed + "---)") +
          (inserted === "" ? "" : "(+++" + inserted + "+++)");
    lastEnd = end;
    lastLineAfterRemoved = lineAfterRemoved;
    offset += replaced - (end - start);
    lastLineNumber = lineNumber;
  }
  summary += lastLineAfterRemoved;
  return summary;
}

function relativePath(filepath) {
  return filepath.substring(path.length);
}

function fileOperationSummary(operations) {
  if(operations == null) return "";
  var summary = "";
  for(var i = 0; i < operations.length; i++) {
    var {_1: filepath, _2: action} = operations[i];
    if(summary != "") summary += "\n";
    if(action["$d_ctor"] == "Write") {
      summary += relativePath(filepath) + ": " + stringDiffSummary(action.args._1, action.args._2, action.args._3);
    } else if(action["$d_ctor"] == "Create") {
      summary += "Created " + relativePath(filepath);
    } else if(action["$d_ctor"] == "Rename") {
      summary += "Renamed " + relativePath(filepath) + " to " + action.args._1;
    } else if(action["$d_ctor"] == "Delete") {
      summary += "Deleted " + relativePath(filepath);
    } else {
      console.log("unrecognized action:", action);
    }
  }
  return summary;
}

function detectHydefile($name) {
  if($name.length > 0 && $name.substring($name.length - 1,  $name.length) === "/") {
    $name = $name.substring(0, $name.length - 1);
  }
  let $hydefile = null, $result;
  while($name.length > 0) {
    $namex = $name == "" ? "" : `${$name}/`;
    if(fs.existsSync($namex+"hydefile.leo")) {
      $hydefile = $namex+"hydefile.leo"; break;
    }
    if(fs.existsSync($namex+"hydefile.elm")) {
      $hydefile = $namex+"hydefile.elm"; break;
    }
    if(fs.existsSync($namex+"hydefile")) {
      $hydefile = $namex+"hydefile"; break;
    }
    $newname = $name.replace(/\/[^\/]*$/,"");
    if($newname === $name) { // No more slashes
      $name = "";
    } else {
      $name = $newname;
    }
  }
  if($hydefile != null) {
    $result = {file : $hydefile};
    if(fs.existsSync($namex+".hydecache")) {
      $result["cache"] = fs.readFileSync($namex+".hydecache", "utf8");
      $result["cachefile"] = $namex+".hydecache";
    }
  } else {
    $result = {};
  }
  return $result;
}

function pushResultOn(array) {
  return name => { array.push(name); return 0 }
}

// Returns a [Result of string containing the requested page, new overrides]
// If newvalue is defined, performs an update before returning the page.
function loadpage(path, vars, user, newvalue) {
  // __dirname = path.resolve(); // If in the REPL
  if(typeof vars != "object") vars = {};
  var serverFileContent = readServerFile();
  var hydefilecache = defaultOptions.hyde ? detectHydefile(path) : undefined;
  console.log("hydefilecache", hydefilecache)
  var filesToWatch = [];
  var foldersToWatch = [];
  var generatedFiles = [];
  var writtenFiles = [];
  var env = {
      googleClientId: googleClientId,
      vars: vars,
      user: toLeoQuery(user || {}),
      defaultOptions: toLeoQuery(defaultOptions).concat(
          hydefilecache ? [leo.Tuple2("hydefilecache", hydefilecache)] : []),
      path: path,
      fileOperations: [] };
  if(hydefilecache) {
    env["recordFileRead"] = pushResultOn(filesToWatch);
    env["recordFolderList"] = pushResultOn(foldersToWatch);
    env["recordOutputFiles"] = tuplesToWrite => {
      writtenFiles = tuplesToWrite.map(({_1}) => _1);
      alwaysWriteAll(tuplesToWrite);
      return 0;
    }
  }
  if(typeof newvalue == "undefined") {
    let result = [evaluateToHtml(path, env, serverFileContent), vars];
    if(hydefilecache.cache) {
      console.log("overriding cache", [filesToWatch, foldersToWatch, writtenFiles, hydefilecache.cachefile]);
      let newCacheContent =
            sns.valToNative(sns.objEnv.string.evaluate(
              {a: {inputFiles: filesToWatch,
                   inputFolders: foldersToWatch,
                   outputFiles: writtenFiles
               }})("toString a")._0)._0;
      console.log("set cache to write");
      alwaysWrite(hydefilecache.cachefile, newCacheContent);
    }
    return result;
  } else { // We update the page and re-render it.
    var newVal = sns.nativeToVal(newvalue);
    console.log("Started to update...");
    var result = sns.objEnv.string.update(env)(serverFileContent)(newVal);
    console.log("Update finished (first solution)");
    if(result.ctor == "Ok") {
      var allSolutions = result._0;
      // Instead of iterating through all the solutions, just detect if there is an ambiguity.
      var solution = getOneSolution(path, serverFileContent, allSolutions);
      if(solution === false) {
        return [{ctor: "Err", _0: "Empty list of solutions"}];
      } else {
        console.log("Checking for ambiguities");
        var allSolutionsTail = sns.lazyList.tail(allSolutions);
        var solution2 = getOneSolution(path, serverFileContent, allSolutionsTail);
        if(solution2 === false) { // No ambiguity, we can immediately process the change.
          console.log("No ambiguity");
          return solution;
        } else {
          console.log("Ambiguity found");
          var solutionKey = uniqueKey();
          var cachedSolution = {
              timestamp: (+ new Date()),
              computed: [solution, solution2],
              remaining: allSolutionsTail,
              path: path,
              serverFileContent: serverFileContent
          }
          cachedSolutions[solutionKey] = cachedSolution;
          return solution.concat(solutionKey);
        }
      }
    } else return [result];
  }
}

function toLeoQuery(query) {
  var result = [];
  for(key in query) {
    result.push(leo.Tuple2(key, query[key]));
  }
  return result;
}

var willkill = undefined;

var key = fs.existsSync(defaultOptions.key) ? fs.readFileSync(defaultOptions.key) : null;
var cert = fs.existsSync(defaultOptions.cert) ? fs.readFileSync(defaultOptions.cert) : null;
var httpsOptions = { key: key, cert: cert };
var protocol = key && cert ? "https" : "http";
var httpOrHttps = require(protocol);
if(protocol == "http") {
  console.log(`${defaultOptions.key} (--key) and/or ${defaultOptions.cert} (--cert) files missing. Starting http server instead of https.`);
}

function combinePath(prefix, path) {
  return (prefix == "" ? "." : prefix) + "/" + (path && path.length && path[0] === "/" ? path.substring(1) : path);
}

function alwaysWrite($name, $content) {
  if (!fs.lstatSync($name).isDirectory(fspath.dirname($name))) {
    fs.mkdirSync(fspath.dirname($name), { recursive: true });
  }
  fs.writeFileSync($name, $content, "utf8");
}

function alwaysWriteAll($toWrite, callback) {
  for(let $nameContent of $toWrite) {
      alwaysWrite($nameContent._1, $nameContent._2);
      if(callback) callback($nameContent);
  }
}

const server = httpOrHttps.createServer(httpsOptions, (request, response) => {
  var requestURL = request.headers["url"] ? request.headers["url"] : request.url; // Possibility to override the URL.
  var urlParts = url.parse(requestURL, parseQueryString=true);
  var query = toLeoQuery(urlParts.query);
  var pn = urlParts.pathname;
  var path = decodeURIComponent(pn.length && pn[0] == "/" ? pn.substring(1) : pn); // Without the slash.
  var accessResult = sns.objEnv.string.evaluate({path:path,method:request.method})(readHtAccessFile());
  var access = sns.process(accessResult)(sns.valToNative);
  var header = 'text/html; charset=utf-8';
  if(access.ctor == "Err") {
    console.log("Error in htaccess", access._0);
    response.setHeader('Content-Type', header);
    response.statusCode = 500;
    response.end(`<html><body style="color:#cc0000"><div   style="max-width:600px;margin-left:auto;margin-right:auto"><h1>htaccess.elm internal Error report</h1><pre style="white-space:pre-wrap">${access._0}</pre></div></body></html>`);
  } else if(access._0) {
    if(typeof willkill != "undefined") {
      clearTimeout(willkill);
      willkill = undefined;
    }
    if(request.method == "GET") {
      let $action = request.headers["action"];
      let $name = request.headers["name"];
      if(typeof $action != "undefined" && typeof $name != "undefined") { // AJAX requests to read info from the file system
        if($name.substring(0, 1) === "/") {
          $name = $name.substring(1);
        }
        if($action == "isdir") {
          response.statusCode = 200;
          if($name == "") $name = ".";
          response.end(fs.existsSync($name) && fs.lstatSync($name).isDirectory() || $name == "." || $name == ""  ? "true" : "false");
          return;
        } else if($action == "isfile") {
          response.statusCode = 200;
          response.end(fs.existsSync($name) && fs.lstatSync($name).isFile() ? "true" : "false");
          return;
        } else if($action == "listdir") {
          response.statusCode = 200;
          if($name == "") $name = ".";
          response.end(JSON.stringify((fs.readdirSync($name) || []).filter(i => i != "." && i != "..")));
          return;
        } else if($action == "read") {
          response.statusCode = 200;
          if(fs.existsSync($name)) {
            response.end("1" + fs.readFileSync($name));
          } else {
            response.end("0");
          }
          return;
        } else if ($action=="fullListDir") {
          if($name == "") $name = ".";
          let $result =
            (fs.readdirSync($name, {withFileTypes: true}) || [])
            .filter(f => f.name != "." && f.name != "..")
            .map(f => [f.name, f.isDirectory()]);
          response.statusCode = 200
          response.end(JSON.stringify($result));
          return;
        } else {
          response.statusCode = 500;
          response.end("Unsupported read action for this user: $action, $userId"); 
          return;
        }
      }
      var header = path.endsWith(".ico") ? "image/ico" : header;
      var header = path.endsWith(".jpg") ? "image/jpg" : header;
      var header = path.endsWith(".gif") ? "image/gif" : header;
      var header = path.endsWith(".png") ? "image/png" : header;
      var header = path.endsWith(".svg") ? "image/svg+xml" : header;
      var header = path.endsWith(".css") ? "text/css; charset=utf-8" : header;
      if(!header.startsWith("image/") && !header.startsWith("text/css")) {
        var [htmlContent] = loadpage(path, query, undefined);
        response.setHeader('Content-Type', header);
        response.statusCode = 200;
        if(htmlContent.ctor == "Err") {
          response.end(`<html><body style="color:#cc0000"><div   style="max-width:600px;margin-left:auto;margin-right:auto"><h1>Internal Error report</h1><pre style="white-space:pre-wrap">${htmlContent._0}</pre></div></body></html>`);
        } else {
          response.end(htmlContent._0);
        }
      } else {
        response.setHeader('Content-Type', header);
        let expectedFilePath = combinePath(defaultOptions.path, path);
        if(fs.existsSync(expectedFilePath)) {
          var content = fs.readFileSync(expectedFilePath);
          response.statusCode = 200;
          response.end(content);
        } else {
          response.statusCode = 404;
          response.end(`<html>body>${path} not found</body></html>`);
        }
      }
    } else if(request.method == "POST") {
      const chunks = [];
      request.on('data', chunk => chunks.push(chunk));
      request.on('end', function () {
        var allChunks = Buffer.concat(chunks);
        // Start ajax requests to modify the file system.
        let $action = request.headers["action"];
        let $name = request.headers["name"];
        if(typeof $action != "undefined" && typeof $name != "undefined") {
          $content = allChunks.toString();
          if($action == "write" || $action == "create") {
            if (!fs.lstatSync($name).isDirectory(fspath.dirname($name))) {
              fs.mkdirSync(fspath.dirname($name), { recursive: true });
            }
            fs.writeFileSync($name, $content, "utf8");
            response.statusCode = 200;
            if($action == "create") {
              response.end(`Written ${$name}`);
            } else {
              response.end(`Created ${$name}`);
            }
            return;
          } else if($action == "writeall") {
            let $toWrite = JSON.parse($content);
            let $i = 0;
            let msg = "";
            alwaysWriteAll($toWrite, $nameContent => {
              msg += "Written " + $nameContent._1 + "\n";
             $i = $i + 1;
            });
            response.end(msg + `\n$i files written`);
          } else if($action == "rename") {
            fs.renameSync($name, $content);
            response.statusCode = 200;
            response.end(`Renamed ${$name} to ${$content}`);
            return;
          } else if($action == "delete") {
            fs.unlinkSync($name);
            response.statusCode = 200;
            response.end(`Deleted ${$name}`);
            return;
          } else {
            response.statusCode = 500;
            response.end(`Unsupported write action for this user: ${$action}, ${userId}`)
            return;
          }
        } else if(request.headers["location"]) { // File overwriting
          $location = request.headers["location"];
          $location = $location.length && $location[0] == "/" ? $location.substring(1) : $location;
          $content = allChunks.toString();
          responde.send(`Writing ${location} whatever received on POST data`);
          fs.writeFileSync($location, $content, "utf8");
          responde.end(`Finished to write to $location`);
          return;
        }
        // End ajax requests

        if(defaultOptions.closeable && request.headers["close"]) {
          willkill = setTimeout(() => process.exit(), timeBeforeExit); // Kills the server after 2 seconds if the webpage is not requested.
          response.statusCode = 200;
          response.end('');
          return;
        } else if(request.headers["write-file"]) { // With this and with the correct permissions, we can overwrite any file.
          console.log("going to write file");
          // Just a file that we write on disk.
          var imageType = request.headers["write-file"];
          var imageLocation = combinePath(defaultOptions.path, path);
          console.log("going to write image file to ", imageLocation);
          fs.writeFileSync(imageLocation, allChunks);
          response.statusCode = 201;
          response.end('');
          return;
        }
        
        var continueWithLoading = (userdata) => {
          var canAskQuestion = (request.headers["question"] || urlParts.query["question"] || (defaultOptions.questions ? "true" : "false")) == "true";
          var body =  allChunks.toString();
          var ambiguityKey = request.headers["ambiguity-key"];
          var numberOfSolutionsSoFar = 2; // Only if Ambiguity-Key is set.
          var numSolutionSelected = 1;
          var htmlContent = {ctor:"Err", _0: "Not yet defined"};
          var newQuery = [];
          var fileOperations = [];
          var ambiguitiesSummary = [];
          if(ambiguityKey !== null && typeof ambiguityKey !== "undefined") {
            var selectAmbiguityStr = request.headers["select-ambiguity"];
            if(selectAmbiguityStr != null) {
              numSolutionSelected = JSON.parse(selectAmbiguityStr);
              var solutionSet = cachedSolutions[ambiguityKey];
              if(typeof solutionSet != "undefined") {
                [htmlContent, newQuery, fileOperations] = getSolutionByNum(solutionSet, numSolutionSelected);
                numberOfSolutionsSoFar = solutionSet.computed.length;
                ambiguitiesSummary = solutionSet.computed.map(a => fileOperationSummary(a[2]));
              } else {
                htmlContent = {ctor:"Err", _0: "Solution set not found"};
              }
            } else {
              var acceptAmbiguityStr = request.headers["accept-ambiguity"];
              if(acceptAmbiguityStr != null) {
                var acceptAmbiguity = JSON.parse(acceptAmbiguityStr);
                var solutionSet = cachedSolutions[ambiguityKey];
                [htmlContent, newQuery, fileOperations] = getSolutionByNum(solutionSet, acceptAmbiguity);
                ambiguityKey = undefined;
              } else {
                var cancelAmbiguityStr = request.headers["cancel-ambiguity"];
                if(cancelAmbiguityStr != null) {
                  ambiguityKey = undefined;
                  [htmlContent, newQuery, fileOperations] = loadpage(path, query, userdata);
                  fileOperations = [];
                } else {
                  htmlContent = {ctor:"Err", _0: "Solution set not found."};
                }
              }
            }
          } else if(request.headers["reload"]) {
            [htmlContent, newQuery, fileOperations] = loadpage(path, query, userdata);
          } else {
            var pushedValue = JSON.parse(body);
            [htmlContent, newQuery, fileOperations, ambiguityKey] = loadpage(path, query, userdata, pushedValue);
          }
          response.statusCode = 201;
          response.setHeader('Content-Type', 'text/html; charset=utf-8');
          if(htmlContent.ctor == "Err") {
            response.end(`<html><body style="color:#cc0000"><div   style="max-width:600px;margin-left:auto;margin-right:auto"><h1>Internal Error report</h1><pre style="white-space:pre-wrap">${htmlContent._0}</pre></div></body></html>`)
          } else {
            if(typeof request.headers["url"] === "string") {
              response.setHeader("New-Local-URL", request.headers["url"]);
            }
            response.setHeader('New-Query', JSON.stringify(newQuery));
            if(ambiguityKey != null && typeof ambiguityKey != "undefined" &&
               !path.endsWith(".html") && canAskQuestion &&
               (urlParts.query["edit"] == "true" || (urlParts.query["edit"] == null && defaultOptions.edit))) {
              var solutionSet = cachedSolutions[ambiguityKey];
              var ambiguityEnd = solutionSet.remaining === false;
              ambiguitiesSummary = solutionSet.computed.map(a => fileOperationSummary(a[2]));
              response.setHeader('Ambiguity-Key', ambiguityKey);
              response.setHeader('Ambiguity-Number', JSON.stringify(numberOfSolutionsSoFar));
              response.setHeader('Ambiguity-Selected', JSON.stringify(numSolutionSelected));
              response.setHeader('Ambiguity-Summaries', JSON.stringify(ambiguitiesSummary));
              response.setHeader('Ambiguity-End', ambiguityEnd ? "true" : "false");
            } else {
              if(fileOperations) {
                applyOperations(fileOperations);
                response.setHeader('Operations-Summary', encodeURI(fileOperationSummary(fileOperations)));
              }
            }
            response.end(htmlContent._0);
          }
        }
        
        var token = request.headers["id-token"];
        if(token) {
          const {OAuth2Client} = require('google-auth-library');
          const client = new OAuth2Client(googleClientId);
 
          async function verify() {
            const ticket = await client.verifyIdToken({
                idToken: token,
                audience: googleClientId // Array of client ids if multiple clients access the backend.
            });
            const userdata = ticket.getPayload();
            continueWithLoading(userdata); // Only authenticated users can access their information. Great!
          }
          verify().catch(err => {
            console.log(err);
            continueWithLoading(undefined);            
          });
          return;
        } else {
          continueWithLoading(undefined);
        }
      });
    } else {
      response.statusCode = 400;
      response.end("Unknown method");
    }
  } else {
    response.statusCode = 401;
    response.end(`<html><body style="color:#cc0000"><div   style="max-width:600px;margin-left:auto;margin-right:auto"><h1>Unauthorized access to ${path}</h1></div></body></html>`);
  }
});

port = await getPort({host: hostname, port: [port, 3000, 3001, 3002, 3003, 3004]})

// Load the Elm program into our namespace.
server.listen(port, hostname, () => {
  console.log("Editor Server serving path " + defaultOptions.path);
  if(defaultOptions.edit) {
    console.log("Edit mode:     activated.    (toggle option: 'edit=false')");
  } else {
    console.log("Edit mode:     deactivated.  (toggle option: 'edit=true')");
  }
  if(defaultOptions.autosave) {
    console.log("Autosave mode: activated.    (toggle option: 'autosave=false')");
  } else {
    console.log("Autosave mode: deactivated.  (toggle option: 'autosave=true')");
  }
  if(defaultOptions.question) {
    console.log("Questions:     activated.    (toggle option: 'question=false')");
  } else {
    console.log("Questions:     deactivated.  (toggle option: 'question=true')");
  }
  console.log("To toggle any of these options in the browser, join these toggle options using '&', prefix this with '?', and append the result to any URL, ");
  console.log(`Point your browser at ${protocol}://${hostname}:${port}`);
});

if(fileToOpen) {
  var opn = require('opn');

  // opens the url in the default browser 
  opn(protocol + "://" + hostname + ":" + port + "/" + fileToOpen);
} else if(defaultOptions.openbrowser) {
  var opn = require('opn');

  // opens the url in the default browser 
  opn(protocol + "://" + hostname + ":" + port);
}
} // async declaration of start()

// Never called when starting the server from command-line.
module.exports = function(requireOptions) {
  if(!requireOptions) {
    start();
    return;
  } else {
    for(var k in requireOptions) {
      defaultOptions[k] = requireOptions[k];
    }
    start();
    return;
  }
}


