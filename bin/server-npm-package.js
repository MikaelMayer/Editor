
var params = process.argv.slice(2);

function getParam(x, defaultValue) {
  var param = params.find(elem => elem.startsWith(x));
  if(typeof param !== "undefined") {
    var returnValue = param.substring(x.length + 1);
    if(returnValue == "") return defaultValue;
    return returnValue;
  } else {
    return defaultValue;
  }
}

function existsParam(x) {
  var param = params.find(elem => elem == x);
  return typeof param !== "undefined";
}

function isBoolParamTrue(x) {
  return existsParam(x) || getParam(x, "false") == true;
}

function getNonParam() {
  return params.find(elem => !elem.startsWith("-"))
}

const fs = require("fs");
const fspath = require('path');
const https = require('https');
//const http = require('http');
const url = require('url');
const hostname = getParam("hostname", 'localhost');
var port = parseInt(getParam("port", "3000"));

// The default client id is suitable only for localhost:3000
var googleClientId = getParam("google-client-id", "844835838734-2iphm3ff20ephn906md1ru8vbkpu4mg8.apps.googleusercontent.com");

const getPort = require('get-port');

const serverFile = "./server.elm";
const htaccessFile = "./htaccess.elm";
var path =  getParam("--path",    "");
var question = getParam("--question", "true") == "true";
var autosave = getParam("--autosave", "false") == "true";

var fileToOpen = getNonParam();
if(fileToOpen) {
  if(fileToOpen.indexOf("/") == -1 && fileToOpen.indexOf("\\") == -1) {
    path = "";
  } else {
    path = fileToOpen.replace(/[\/\\][^\/\\]*$/g, "");
  }
  fileToOpen = fileToOpen.replace(/.*[\/\\](?=[^\/\\]*$)/g, "");
  question = false; // When opening a file, by default we should not ask questions.
  autosave = false; // When opening a file, by default we want to let the user save it.
}
var timeBeforeExit = 2000; // Number of ms after receiving the closing signal (if file open) to kill the server.


leo = {};
leo.data = function(name) {
  return function() {
    let args = {};
    for(let i = 1; i <= arguments.length; i++) {
      args["_" + i] = arguments[i - 1];
    }
    return {"$d_ctor": name, args: args};
  }
}
leo.Just = leo.data("Just")
leo.Nothing = leo.data("Nothing")()
leo.Tuple2 = function(a, b) {
  return {"$t_ctor": "Tuple2", _1: a, _2: b}
}

var defaultOptions = {
  edit:     getParam("--edit",     "true") == "true",
  autosave: autosave,
  question: question,
  admin:    isBoolParamTrue("--admin"),
  production:    isBoolParamTrue("--production"),
  path:     path,
  closeable: !(!(fileToOpen)),
  openbrowser: isBoolParamTrue("--openbrowser"),
  key: "localhost-key.pem",
  cert: "localhost.pem",
  hyde: getParam("--hyde", "true") == "true"
};

async function start() {

// Don't modify, this will be replaced by the content of 'server.elm'
const defaultServerContent = "-- input: path            The file to serve.\n-- input: vars:           URL query vars.\n-- input: urlParams:      The URL params plainly\n-- input: defaultOptions  default options (options that vars can override for certain parts).\n--                        If nodefs is set, will use it instead of nodejs.nodeFS\n--                        If browserSide is set, will use a different kind of request. \n-- input: fileOperations  The current set of delayed file disk operations.\n--    Note that Elm pages are given in context the path, the vars, and the file system (fs) to read other files\n-- output: The page, either (almost) uninstrumented or augmented with the toolbar and edit scripts.\n\n{--------------------------------------------------------\n    Permission handling, file system, options processing\n---------------------------------------------------------}\nlistGetOrElse key listDict default = listDict.get key listDict |> Maybe.withDefault default\n\n{--}\nupdatecheckpoint name x = {\n  apply x = x\n  update {input, outputNew, diffs} =\n    let _ = Debug.log \"\"\"Checkpoint @name\"\"\" () in  \n    Ok (InputsWithDiffs [(outputNew, Just diffs)])\n}.apply x\n\ndebugcheckpoint name x = let _ = Debug.log name () in x\n--}\n\nserverOwned what obj = freezeWhen (not permissionToEditServer) (\\od -> \"\"\"You tried to modify @what, which is part of the server. We prevented you from doing so.<br><br>\n\nIf you really intended to modify this, add ?superadmin=true to the URL and redo this operation. This is likely going to create or modify the existing <code>server.elm</code> at the location where you launched Editor.<br><br>\n\nFor debugging purposes, below is the new value that was pushed:\n<pre>@(Regex.replace \"<\" (always \"&lt;\") \"\"\"@od\"\"\")</pre>\nHere is the old value that was computed\n<pre>@(Regex.replace \"<\" (always \"&lt;\") \"\"\"@obj\"\"\")</pre>\n\"\"\") obj\n\n\npreludeEnv =  __CurrentEnv__\n\nmbApplyPrefix = case listDict.get \"path\" defaultOptions of\n  Just \"\" -> Nothing\n  Nothing -> Nothing\n  Just prefix -> Just (\\name -> if name == \"\" then prefix\n      else if Regex.matchIn \"/$\" prefix then prefix + name\n      else prefix + \"/\" + name)\n\ndirectReadFileSystem =\n  listDict.get \"nodefs\" defaultOptions |> Maybe.withDefault nodejs.nodeFS\n\nfs = nodejs.delayedFS directReadFileSystem fileOperations\n\nhydefilecache = listDict.get \"hydefilecache\" defaultOptions\n\nfs = case mbApplyPrefix of\n  Nothing -> fs\n  Just applyPrefix -> { fs |\n    read name = fs.read (applyPrefix name)\n    listdir name = fs.listdir (applyPrefix name)\n    listdircontent name = fs.listdircontent (applyPrefix name)\n    isdir name = fs.isdir (applyPrefix name)\n    isfile name = fs.isfile (applyPrefix name)\n  }\n\nboolVar name resDefault =\n  listDict.get name vars |>\n  Maybe.map (\\original ->\n    Update.bijection\n      (case of \"true\" -> True; \"\" -> True; _ -> False)\n      (case of True -> if original == \"true\" || original == \"\" then original else \"true\"; _ -> \"false\") original) |>\n  Maybe.withDefaultReplace (\n    listDict.get name defaultOptions |> Maybe.withDefault resDefault |> freeze)\n\nbrowserSide = listDict.get \"browserSide\" defaultOptions == Just True\n\nvaradmin = boolVar \"admin\" False\nvarraw = boolVar \"raw\" False\nvaredit = boolVar \"edit\" False || varraw\nvarls = boolVar \"ls\" False\nvarclearhydecache = boolVar \"clearhydecache\" False\nvarhydeNotDisabled = boolVar \"hyde\" True\ndefaultVarEdit = listDict.get \"edit\" defaultOptions |> Maybe.withDefault False\nvarproduction = listDict.get \"production\" defaultOptions |> Maybe.withDefault (freeze False)\niscloseable = listDict.get \"closeable\" defaultOptions |> Maybe.withDefault (freeze False)\nvarFast = boolVar \"fast\" False\n\nuserpermissions = {pageowner= True, admin= varadmin}\npermissionToCreate = userpermissions.admin\npermissionToEditServer = boolVar \"superadmin\" False -- should be possibly get from user authentication\n-- List.contains (\"sub\", \"102014571179481340426\") user -- That's my Google user ID.\n\ncanEditPage = userpermissions.pageowner && varedit && not varls\n\nfreezeWhen = Update.freezeWhen\n\ncanEvaluate = listDict.get \"evaluate\" vars |> Maybe.withDefaultReplace (serverOwned \"default value of evaluate\" \"true\")\n\n{--------------------------------------------------------\n Rewrite path to either a folder or a default file under\n---------------------------------------------------------}\n\npath: String\npath =\n  if fs.isdir path then\n   if not varls then\n     List.mapFirstSuccess (\\test ->\n       if fs.isfile <| path + test then Just (path + test) else Nothing)\n       [\"index.elm\" , \"/index.elm\", \"index.html\", \"/index.html\", \"README.md\" , \"/README.md\" ]\n     |> Maybe.withDefault path\n   else path\n  else path\n\n{---------------------------------------------------------------------------\n Retrieves the string content of the path. For folders, creates a custom page\n----------------------------------------------------------------------------}\n\nmbDotEditorFile = \n  let prefix = Regex.extract \"^(.*/)[^/]*$\" path |> Maybe.map (\\[prefix] -> prefix) |> Maybe.withDefault \"\" in\n  let dotEditor = prefix +  \".editor\" in\n  fs.read dotEditor\n\napplyDotEditor source = \n  let prefix = Regex.extract \"^(.*/)[^/]*$\" path |> Maybe.map (\\[prefix] -> prefix) |> Maybe.withDefault \"\" in\n  let dotEditor = prefix +  \".editor\" in\n  case mbDotEditorFile of\n    Nothing -> source\n    Just modifier ->\n      case __evaluate__ ((\"vars\", vars)::(\"path\", path)::(\"fs\", fs)::(\"content\", source)::preludeEnv) modifier of\n        Err msg -> let _ = Debug.log (\"Error while executing \" + dotEditor + \" : \" + msg) () in\n          source\n        Ok newSource -> newSource\n\nisTextFile path =\n  Regex.matchIn \"\"\"\\.(?:txt|css|js|sass|scss)$\"\"\" path\n\n---------------------\n-- Hyde file support.\n-- Everything unrolled on the main let definitions to benefit from caching\n---------------------\n\n(withoutPipeline, hydefilepath, hydefileSource) = case hydefilecache of\n  Just {file=hydefile} ->\n    case if varclearhydecache then Nothing else hydefilecache of\n      Just {cacheContent} ->\n        case evaluate cacheContent of\n          {inputFiles, outputFiles} ->\n            (not (List.isEmpty outputFiles) &&\n             List.find (\\e -> e == path || e == \"/\" + path) inputFiles == Nothing &&\n             List.find (\\e -> e == path || e == \"/\" + path) outputFiles == Nothing,\n               hydefile, fs.read hydefile)\n          _ -> (False, hydefile, fs.read hydefile)\n      _ -> (False, hydefile, fs.read hydefile) -- Need to recompute the cache anyway\n  _ -> (True, \"\", Nothing)\n\n(folderView, mbSourcecontentAny1, hydeNotNeeded): (Boolean, Maybe String, Boolean)\n(folderView, mbSourcecontentAny1, hydeNotNeeded) =\n  if path == \"server.elm\" then\n    (False, Just \"\"\"<html><head></head><body class=\"editor-error\">The Elm server cannot display itself. This is a placeholder</body></html>\"\"\", True)\n  else if fs.isdir path then\n    (True, Just \"\", True)\n  else if fs.isfile path && Regex.matchIn \"\"\"\\.(png|jpg|ico|gif|jpeg)$\"\"\" path then -- Normally not called because server.js takes care of these cases.\n    (False, Just \"\"\"<html><head><meta name=\"viewport\" content=\"width=device-width, minimum-scale=0.1\"><title>@path</title></head><body style=\"margin: 0px; background: #0e0e0e;\"><img style=\"-webkit-user-select: none;margin: auto;\" src=\"@path\"></body></html>\"\"\", True)\n  else if hydefilecache == Nothing || withoutPipeline || not varhydeNotDisabled then\n    (False, fs.read path, True)\n  else\n    (False, Nothing, False)\n\nhyde_sourceRaw = if hydeNotNeeded then \"\" else\n  hydefileSource |> Maybe.withDefaultLazy (\\_ -> \"\"\"all = [Error \"hyde file '@hydefilepath' not found?!\"]\"\"\")\n\nhyde_source = if hydeNotNeeded then \"\" else\n  hyde_sourceRaw + Update.freeze \"\\n\\nlet t = \" + (listDict.get \"task\" vars |> Maybe.withDefault \"all\") + \"\\n    t = if typeof t == 'function' then t () else t\\n    t = if typeof t == 'list' then t else [t]\\nin t\"\n\nhyde_fileDirectory = if hydeNotNeeded then \"\" else\n  Regex.replace \"/[^/]*$\" \"\" hydefilepath\n\nhyde_inDirectory name =\n  if hyde_fileDirectory == \"\" then name else\n    hyde_fileDirectory  + \"/\" + name\n\nhyde_fs = \n  if hydeNotNeeded then {} else\n  let hyde_fsReadRecord = \n        { directReadFileSystem |\n          read name =\n            let name = hyde_inDirectory name in\n            let _ = recordFileRead name in\n            fs.read name,\n          listdir name =\n            let name = hyde_inDirectory name in\n            let _ = recordFolderList name in\n            fs.listdir name\n        } in\n  nodejs.delayedFS hyde_fsReadRecord <|\n  Update.lens {\n    apply = identity\n    update {outputNew, diffs} = -- input and outputOld were empty, diffs is valid\n    -- We just need to change the paths\n      outputNew |>\n      List.map (case of\n        (name, Rename newName) -> (hyde_inDirectory name, Rename (hyde_inDirectory newName))\n        (name, x) -> (hyde_inDirectory name, x))|>\n      flip (,) (Just diffs) |>\n      List.singleton |> InputsWithDiffs |> Ok\n  } fileOperations\n\n-- A Hyde plug-is a function that takes two arguments\n--   options (as a list, object or tuple)\n--   a list of Write\n-- Returns a list of Write\nplugin name =\n  fs.read (hyde_inDirectory (\"hydefile-plugin-\" + name + \".leo\")) |>\n  Maybe.andThen (\\plugin_content ->\n    case __evaluate__ ((\"fs\", hyde_fs)::(\"plugin\", plugin)::preludeEnv) plugin_content of\n      Ok x -> Just x\n      Err msg -> \n        let _ = Debug.log (\"loading of plugin \" + name + \" failed:\" + msg) () in\n        Nothing\n  ) |> Maybe.withDefaultLazy (\\_ ->\n   let _ = Debug.log (\"plugin \" + name + \" not found\") () in\n   \\options -> identity)\n\nhyde_resEvaluatedHydeFile =\n  if hydeNotNeeded then {} else\n  __evaluateWithCache__ ((\"fs\", hyde_fs)::(\"plugin\", plugin)::preludeEnv) hyde_source\n\n(hyde_generatedFilesDict, hyde_errors) =\n  if hydeNotNeeded then (False, False) else\n  case hyde_resEvaluatedHydeFile of\n    Err msg -> ([], msg)\n    Ok (writtenContent, _) ->\n      let (written, errors) = List.partition (case of Write -> True; _ -> False) writtenContent in\n      let tuplesToWrite =\n            List.map (case of Write name content -> (hyde_inDirectory name, content)) written\n          joinedErrors = \n            List.map (case of Error msg -> msg) errors |> String.join \"\\n\"\n      in\n      (tuplesToWrite, joinedErrors)\n\nhyde_record_output_files =\n  if hydeNotNeeded then False else\n  let hyde_dummy = recordOutputFiles hyde_generatedFilesDict in  -- Writes on disk \n  False\n\nhyde_dummy = if hydeNotNeeded then (False, False) else\n  let x = hyde_generatedFilesDict in -- to make sure dependency is executed\n  if hyde_errors == \"\" then\n    cacheResult () -- Caches the names of written files\n  else \n    ()\n\nmbSourcecontentAny =\n  if hydeNotNeeded then mbSourcecontentAny1 else\n  case listDict.get (\"/\" + path) hyde_generatedFilesDict of\n    Nothing ->\n      case listDict.get path hyde_generatedFilesDict of\n        Nothing ->\n          if hyde_errors == \"\" then\n            let _ = Debug.log \"\"\"Unable to read (/)@path from output of hydefile\"\"\" () in\n            fs.read path\n          else\n            Just <|\n            serverOwned \"error recovery of hyde build tool\" <|\n            \"\"\"<html><head></head><body class=\"editor-error\"><h1>Error while resolving the generated version of @path</h1><pre>@hyde_errors</pre></body></html>\"\"\"\n        x -> x\n    x -> x\n\n---------------------------------\n-- Hyde file support ends here --\n---------------------------------\n\nsourcecontentAny = Maybe.withDefaultReplace (\n    serverOwned \"404 page\" (if isTextFile path then\n           if permissionToCreate then freeze \"\"\"@path does not exist yet. Modify this page to create it!\"\"\" else \"\"\"Error 404, @path does not exist or you don't have admin rights to modify it (?admin=true)\"\"\"\n        else \"\"\"<html><head></head><body class=\"editor-error\">@(\n          if permissionToCreate then freeze \"\"\"<span>@path does not exist yet. Modify this page to create it!</span>\"\"\" else \"\"\"<span>Error 404, @path does not exist or you don't have admin rights to modify it (?admin=true)</span>\"\"\"\n            )</body></html>\"\"\")\n  ) mbSourcecontentAny\n\nsourcecontent = String.newlines.toUnix sourcecontentAny\n\n-- Conversion of php script to elm script\nphpToElmFinal path string =\n  let includingFolder = Regex.replace \"\"\"(/)[^/]*$\"\"\" (\\{submatches=[slash]} -> slash) path in\n  let phpToElm string =\n        let echoRaw content = \"\\nob = ob + \" + content in\n        let wrapStr content = freeze String.q3 + Regex.replace \"@\" (\\{match=m} -> m + m) content + freeze String.q3 in\n        let echo content = echoRaw (wrapStr content) in\n        let phpStringToElmString =\n                (Regex.replace \"\"\"(\\\")([^\\\"]*)(\\\")\"\"\" <| \\m ->\n                  nth m.group 1 +\n                  (nth m.group 2\n                  |> Regex.replace \"\"\"\\$[0-9a-zA-Z_]*\"\"\" (\\n ->\n                     freeze \"\\\" + \" + nth n.group 0 + freeze \" + \\\"\")) +\n                  nth m.group 3) >>\n                (Regex.replace \"\"\"\\$_GET\\[([^\\]]*)\\]\"\"\" <| \\m ->\n                  freeze \"listDict.get \"+ nth m.group 1 + freeze \" $_GET |> Maybe.withDefaultReplace ''\"\n                ) >>\n                (Regex.replace \"\"\"\\$_SERVER\\[([^\\]]*)\\]\"\"\" <| \\m ->\n                  freeze \"listDict.get \"+ nth m.group 1 + freeze \" $_SERVER |> Maybe.withDefaultReplace ''\"\n                )\n        in\n        if not (Regex.matchIn \"<?php\" string) then\n          echo string\n        else\n        Regex.replace \"\"\"^((?:(?!<\\?php)[\\s\\S])+?)(?=(<\\?php))|(\\?>)([\\s\\S]*?)(?=<\\?php)|(\\?>)([\\s\\S]*?)$|(^)(<\\?php)([\\s\\S]*?)(?=\\?>)|(<\\?php)\\s*if\\s*\\(([\\s\\S]*?)\\s*\\)\\s*\\{\\s*\\?>((?:(?!<\\?php)[\\s\\S])+?)<\\?php\\s*\\}\\s*(?=\\?>)|(<\\?php)([\\s\\S]*?)(?=\\?>)\"\"\" (\n             \\{submatches=[content1, isRaw1, isRaw2, content2, isRaw3, content3, beginning1, isPhp1, code1, isPhpIf, condIf, codeIf, isPhp2, code2]} ->\n          if isPhp1 /= \"\" || isPhp2 /= \"\" || isPhpIf /= \"\" then\n            let prefix = if isPhp1 /= \"\" then echo beginning1 else freeze \"\" in\n            prefix +\n            if isPhpIf /= \"\" then\n              echoRaw <| \"(if \"+condIf+\" then \" + wrapStr codeIf + \" else \\\"\\\")\"\n            else\n            let code = if isPhp1 /= \"\" then code1 else code2 in\n            case Regex.extract \"\"\"^\\s*include\\(\"([^\"]*)\"\\)\"\"\" code of\n              Just [included] ->\n                phpToElm (fs.read (includingFolder + included) |> Maybe.withDefaultReplace (\"\\n[code to read \" + included + \" in \" + includingFolder +\"]\"))\n              _ ->\n            case Regex.extract \"\"\"^\\s*switch\\s*\\(([^\\)]*)\\)\\s*\\{((?:\\s*(?:case\\s*[^:]*?\\s*|default):((?:\\s*\\$[\\w_]+\\s*=\\s*(?:(?!;\\r?\\n)[\\s\\S])*;)*)(?:\\s*break\\s*;)?)*)\\s*\\}\\s*\"\"\" code of\n              Just [input, assignments, lastAssignment] ->\n                let vars = \"(\" + (Regex.find \"\"\"(\\$[\\w_]+)\\s*=\"\"\" lastAssignment |> List.map (\\[_, name] -> name) |> String.join \", \") + \")\" in\n                let results = assignments |> Regex.find \"\"\"\\s*(case\\s*([^:]*?)\\s*|default):((?:\\s*\\$[\\w_]+\\s*=\\s*(?:(?!;\\r?\\n)[\\s\\S])*;)*)(?:\\s*break\\s*;)?\"\"\" |>\n                      List.map (\\[whole, caseOrDefault, pattern, values] ->\n                        let tuple =\n                              Regex.find \"\"\"\\s*\\$[\\w_]+\\s*=\\s*((?:(?!;\\r?\\n)[\\s\\S])*?)\\s*;\"\"\" values |>\n                              List.map (\\[whole2, value2] -> phpStringToElmString value2) |> String.join \", \"\n                        in\n                        let finalPattern = if caseOrDefault == \"default\" then \"_\" else pattern in\n                        \"\\n  \" + finalPattern + \" -> (\" + tuple + \")\"\n                      ) |> String.join \"\"\n                in\n                \"\\n\" + vars + \" = case \" + phpStringToElmString input + \" of\"  + results\n              _ ->\n            case Regex.extract \"\"\"\\s*(?:echo|print)\\s+([^;]+?);\\s*\"\"\" code of\n              Just [content] -> echoRaw content\n              _ ->\n            case Regex.extract \"\"\"\\s*([\\$\\w_]+\\s*=\\s*)([\\s\\S]+?)\\s*;(?=\\r?\\n)\"\"\" code of\n              Just [varNameEqual,toAssign] -> \"\\n\" + varNameEqual + phpStringToElmString toAssign\n              res ->\n                \"\\n[convert\" + code + \"]\\n\" + toString res\n          else\n          let content = if isRaw1 /= \"\" then\n                content1\n              else if isRaw2 /= \"\" then\n                content2\n              else -- if isRaw3 /= \"\" then\n                content3\n          in\n          echo content\n        ) string\n  in\n  flip (+) \"\\nob\" <|\n  (+) \"date _ = '2019'\\nob = freeze ''\" <| phpToElm string\n\n{---------------------------------------------------------------------------\n Evaluates the page according to the path extension.\n - Wraps html pages to parse them as raw html\n - Interprets markdown pages and evaluate them as raw html with CSS\n - Directly evaluate sources from elm/leo pages or folders\n----------------------------------------------------------------------------}\nevaluatedPage: Result String (List HtmlNode)\nevaluatedPage = \n  if canEvaluate /= \"true\" then\n    Ok [<html><head></head><body class=\"editor-error\">URL parameter evaluate=@(canEvaluate) requested the page not to be evaluated</body></html>]\n  else if isTextFile path || varraw then\n    Ok [<html style=\"height:100%;\">\n        <head>\n        <title>@path</title>\n        <style type=\"text/css\" media=\"screen\">\n            #aceeditor { \n                  height: 100%;\n                  width: 100%;\n                  border: 1px solid #DDD;\n                  border-radius: 4px;\n                  border-bottom-right-radius: 0px;\n                  margin-top: 5px;\n            }\n        </style>\n        <script>\n          function loadAceEditor() {\n            console.log(\"executing script\");\n            var aceeditor = ace.edit(\"aceeditor\");\n            var mode = editor.config.path.match(/\\.js$/) ? \"ace/mode/javascript\" :\n                       editor.config.path.match(/\\.html?$/) ? \"ace/mode/html\" :\n                       editor.config.path.match(/\\.css$/) ? \"ace/mode/css\" :\n                       editor.config.path.match(/\\.json$/) ? \"ace/mode/json\" :\n                       editor.config.path.match(/\\.leo$/) ? \"ace/mode/elm\" :\n                       editor.config.path.match(/\\.elm$/) ? \"ace/mode/elm\" :\n                       editor.config.path.match(/\\.php$/) ? \"ace/mode/php\" :\n                       \"ace/mode/plain_text\";\n            aceeditor.session.setMode({path: mode, v: Date.now()});\n            aceeditor.setOptions({\n              fontSize: \"20pt\"\n            });\n            aceeditor.setValue(document.getElementById(\"aceeditor\").getAttribute(\"initdata\"));\n            aceeditor.session.on('change', function(e) {\n              document.getElementById(\"aceeditor\").setAttribute(\"initdata\", aceeditor.getValue());\n            });\n            var callbackSelection = function() {\n              var anchor = aceeditor.selection.getSelectionAnchor();\n              var lead = aceeditor.selection.getSelectionLead();\n              var div = document.querySelector(\"#aceeditor\");\n              div.setAttribute(\"ghost-anchor-row\", anchor.row)\n              div.setAttribute(\"ghost-anchor-column\", anchor.column)\n              div.setAttribute(\"ghost-lead-row\", lead.row)\n              div.setAttribute(\"ghost-lead-column\", lead.column)\n            }\n            aceeditor.selection.on(\"changeSelection\", callbackSelection);\n            aceeditor.selection.on(\"changeCursor\", callbackSelection);\n            var div = document.querySelector(\"#aceeditor\");\n            aceeditor.selection.moveTo(div.getAttribute(\"ghost-anchor-row\") || 0, div.getAttribute(\"ghost-anchor-column\") || 0)\n            aceeditor.focus();\n          }\n        </script>\n        </head>\n        <body style=\"height:100%\">\n        <div id=\"aceeditor\" list-ghost-attributes=\"class draggable style\" children-are-ghosts=\"true\"\n          save-ghost-attributes=\"style ghost-anchor-column ghost-anchor-row ghost-lead-column ghost-lead-row\" initdata=@sourcecontent></div>\n        <script>\n        editor.ghostNodes.push(node =>\n          node.tagName === \"SCRIPT\" && node.getAttribute(\"src\") && node.getAttribute(\"src\").match(/mode-(.*)\\.js|libs\\/ace\\/.*\\/ext-searchbox.js/)\n        );\n        \n        var script = document.createElement('script');\n        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.6/ace.js';\n        script.async = false;\n        script.setAttribute(\"isghost\", \"true\");\n        ace = undefined;\n        document.head.appendChild(script);\n        onAceLoaded = (delay) => () => {\n          if(typeof ace != \"undefined\") {\n            console.log(\"ace loaded.\")\n            loadAceEditor();\n          } else {\n            console.log(\"ace not loaded. Retrying in \" + (delay * 2) + \"ms\");\n            setTimeout(onAceLoaded(delay * 2), 100);\n          }\n        }\n        onAceLoaded(1)();\n        </script>\n        </body>\n        </html>]\n  else \n  let isPhp = Regex.matchIn \"\"\"\\.php$\"\"\" path in\n  let isHtml = Regex.matchIn \"\"\"\\.html?$\"\"\" path in\n  if isHtml || isPhp then\n    let sourcecontent = if isHtml then applyDotEditor sourcecontent else\n      let elmSourceContent = phpToElmFinal path sourcecontent in\n      __evaluate__ ((\"$_GET\", vars)::(\"$_SERVER\", [(\"SCRIPT_NAME\", \"/\" + path)])::(\"path\", path)::(\"fs\", fs)::preludeEnv) elmSourceContent |>\n      case of\n        Err msg -> serverOwned \"error message\" \"<html><head></head><body class=\"editor-error\"><pre>Error elm-reinterpreted php: \" + Regex.replace \"<\" \"&lt;\" msg + \"</pre>Original computed source <pre>\" +\n          Regex.replace \"<\" \"&lt;\" elmSourceContent +\n          \"</pre></body></html>\"\n        Ok sourcecontent -> applyDotEditor sourcecontent\n    in\n    let interpretableData = serverOwned \"begin raw tag\" \"<raw>\" + sourcecontent + serverOwned \"end raw tag\" \"</raw>\" in\n    __evaluate__ preludeEnv interpretableData |>\n    Result.andThen (case of\n      [\"raw\", _, nodes] -> Ok nodes\n      result -> Err \"\"\"Html interpretation error: The interpretation of raw html did not work but produced @result\"\"\"\n    )\n  else if Regex.matchIn \"\"\"\\.md$\"\"\" path then\n    let markdownized = String.markdown sourcecontent in\n      case Html.parseViaEval markdownized of\n        x -> \n          let markdownstyle = fs.read \"markdown.css\" |> Maybe.withDefaultReplace defaultMarkdowncss in\n          Ok [<html><head></head><body><style title=\"If you modify me, I'll create a custom markdwon.css that will override the default CSS for markdown rendering\">@markdownstyle</style><div class=\"wrapper\">@x</div></body></html>]\n  else if Regex.matchIn \"\"\"\\.(elm|leo)$\"\"\" path then\n    let res = __evaluate__ ((\"vars\", vars)::(\"path\", path)::(\"fs\", fs)::preludeEnv) sourcecontent in\n    case res of\n      [\"html\", _, _] -> [res]\n      _ -> res\n  else if folderView then\n    Ok [<html><head>\n      <script>\n        var ispressed = false;\n        var whichOne = \"\";\n        //declare bool variable to be false\n        document.onkeydown = function(e) {\n          if (e.ctrlKey){\n              ispressed = true;\n          }\n        };\n        document.onkeyup = function(e) {\n          if (e.keyCode == 17){ //releasing ctrl key. doesn't set e.ctrlKey properly or would use that.\n            ispressed = false;\n          }\n        }\n        var handleFileSelect = e => {\n          e.preventDefault();\n        }\n        document.addEventListener('drop', handleFileSelect, false);\n      </script>\n      <style>\n        #menu_bar {\n          overflow: hidden;\n          background-color: #ffffff;\n          opacity:1;\n        }\n\n        #menu_bar a {\n          float: left;\n          display: block;\n          color: #f2f2f2;\n          text-align: center;\n          padding: 14px 16px;\n          text-decoration: none;\n          font-size: 17px;\n        }\n\n        #menu_bar a:hover {\n          background-color: #ddd;\n          color: black;\n        }\n\n        #menu_bar a.active {\n          background-color: #4CAF50;\n          color: white;\n        }\n        .dropdown {\n          float: left;\n          overflow: hidden;\n        }\n\n        .dropdown .dropbtn {\n          font-size: 16px;  \n          border: none;\n          outline: none;\n          color: white;\n          padding: 14px 16px;\n          background-color: inherit;\n          font-family: inherit;\n          margin: 0;\n        }\n        .dropdown .dropbtn {\n          font-size: 16px;  \n          border: none;\n          outline: none;\n          color: white;\n          padding: 14px 16px;\n          background-color: inherit;\n          font-family: inherit;\n          margin: 0;\n        }\n\n        .menu_bar a:hover, .dropdown:hover .dropbtn {\n          background-color: red;\n        }\n\n        .dropdown-content {\n          display: none;\n          position: absolute;\n          background-color: #f9f9f9;\n          min-width: 160px;\n          box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);\n          z-index: 1;\n        }\n\n        .dropdown-content a {\n          float: none;\n          color: black;\n          padding: 12px 16px;\n          text-decoration: none;\n          display: block;\n          text-align: left;\n        }\n\n        .dropdown-content a:hover {\n          background-color: #ddd;\n        }\n\n        .dropdown:hover .dropdown-content {\n          display: block;\n        }\n        .content {\n          padding: 16px;\n        }\n\n        .sticky {\n          position: fixed;\n          top: 0;\n          width: 100%;\n        }\n\n        .sticky + .content {\n          padding-top: 60px;\n        }\n        #fileListing div.file-item {\n          display: block;\n        }\n        #fileListing div.file-item input {\n          display: none;\n        }\n        #fileListing div.file-item {\n          display: table-row;\n        }\n        #fileListing div.file-item label {\n          display: table-cell;\n          vertical-align: middle;\n          padding: 0.3em;\n        }\n        #fileListing div.file-item label:hover {\n          background: rgb(229,243,255);\n        }\n        #fileListing div.file-item input:checked + label {\n          color: white;\n          outline: 1px solid rgb(153,209,255);\n          background: rgb(204,232,255);\n        }\n        #fileListing div.file-item label a {\n          text-decoration: none;\n          color: black;\n          padding: 2px;\n        }\n        #fileListing div.file-item label a:hover {\n          text-decoration: underline;\n          color: blue;\n        }\n        #fileListing div.file-item label svg {\n          vertical-align: middle;\n          transform: scale(0.5);\n        }\n        #fileListing div.file-item label svg.file-extension-icon {\n          opacity: 0.5;\n        }\n        #fileListing div.file-item label svg.file-extension-icon > path {\n          stroke:black;\n          stroke-width:2px;\n          stroke-linecap:butt;\n          fill:none;\n          -linejoin:miter;\n          stroke-opacity:1;\n        }\n        #fileListing div.file-item label svg.file-extension-icon > text {\n          font-size: 2em;\n        }\n\n      </style>\n      <div id=\"menu_bar\">\n        <button id=\"renamefs\" onClick=\"renameFs()\">Rename File(s)</button>\n        <button id=\"duplicatefs\" onClick=\"duplicateFs()\">Make a Copy</button>\n        <button id=\"movefs\" onClick=\"moveFs()\">Move File(s)</button>\n        <button id=\"createFolder\" onClick=\"createFolder()\">Create a Folder</button>\n        <button id=\"deletefs\" onClick=\"deleteFs()\">Delete File(s)</button>\n        <div id=\"forprog\"></div>\n      </div>\n      </head><body><h1><label value=path>@path</label></h1>\n      <form id=\"fileListing\"></form>\n      <script>\n      el = editor.el;\n      var fullListDir = (path) => JSON.parse(editor._internals.doReadServer(\"fullListDir\", path));\n      var thisListDir = fullListDir(editor.config.path);\n      var folders = thisListDir.filter((i) => i[1] == true);\n      var getSelectedFiles = () => Array.from(document.querySelectorAll(\"input.filesBtn\")).filter((btn) => btn.checked);\n      var warnSelectFile = reason => window.alert (reason + \", please select some and click this button again\");\n      var warnDeselectFiles = reason => window.alert (reason + \", please deselect all files and folders and click this button again\");\n      var isDupInFolder = (folder, name) => folder.filter((i) => i[0] == name).length != 0;\n      var isDuplicateHere = (name) => isDupInFolder(thisListDir, name);\n      var isFolder = (name) => folders.filter((i) => i[0] == name).length != 0;\n\n      window.onscroll = function() {stickyFun()};\n      var menu_bar = document.getElementById(\"menu_bar\");\n      var sticky = menu_bar.offsetTop;\n\n      function stickyFun() {\n        if (window.pageYOffset >= sticky) {\n          menu_bar.classList.add(\"sticky\")\n        } else {\n          menu_bar.classList.remove(\"sticky\");\n        }\n      }\n      function getOneFile(reason) {\n        var selected = getSelectedFiles();\n        if (selected.length == 0) {\n          warnSelectFile(reason);\n          return 0;\n        } else if (selected.length != 1) {\n          window.alert (\"Please select only one file to rename\");\n          return 0;\n        }\n        return selected[0];\n      }\n      function renameFs() {\n        console.log (\"in rename fs\");\n        var sel = getOneFile(\"To rename files or folders\");\n        if (! sel) return;\n        if (sel.id == \"..\") {\n          window.alert(\"Can't change the up dir\");\n          return;\n        }\n        var newname = window.prompt(\"Set new name for file: \", sel.id);\n        if (newname == null) return;\n        if (newname == \"\") {\n          window.alert(\"Please specify a new name for the file.\");\n          return;\n        }\n        if (isDuplicateHere(newname)) {\n          const doit = window.confirm(\"Are you sure you want to overwrite an existing file with the name \" + newname + \"?\");\n          if (!doit) return;\n        }\n        var x = editor._internals.doWriteServer(\"rename\", editor.config.path + sel.id, editor.config.path + newname);\n        console.log (\"renamed\", sel.id, newname);\n        goodReload();\n      }\n      function deleteFs() {\n        var selected = getSelectedFiles();\n        if (selected.length == 0) {\n          warnSelectFile(\"To delete a file or a folder\"); \n          return;\n        }\n        if (selected.filter((i) => i.id == \"..\").length != 0) {\n          window.alert(\"Can't delete the parent dir\");\n          return;\n        }\n        var warningMsg = \"Are you sure you want to delete the following file(s)?\"\n        for (i = 0; i < selected.length; i++) {\n          warningMsg = warningMsg + \"\\n\" + selected[i].id;\n        }\n        var conf = window.confirm(warningMsg);\n        if (conf) {\n          for (i = 0; i < selected.length; i++) {\n            var isfolder = folders.filter((j) => j[0] == selected[i].id); //optomizable\n            console.log (isfolder);\n            if (isfolder.length != 0) {\n              editor._internals.doWriteServer(\"rmdir\", editor.config.path + selected[i].id); //does this work on non-empty stuff? idts....\n              continue;\n            }\n            editor._internals.doWriteServer(\"unlink\", editor.config.path + selected[i].id);\n          }\n          goodReload();\n          return;\n        }\n      }\n      function duplicateFs() {\n        var sel = getOneFile(\"To duplicate files or folders\");\n        if (! sel) return;\n        if (sel.id == \"..\") {\n          window.alert(\"Can't change the up dir\");\n          return;\n        }\n        var lastdot = sel.id.lastIndexOf(\".\");\n        var nn;\n        if (isFolder(sel.id)) {\n          nn = sel.id + \"_(Copy)\";\n        } else {\n          nn = sel.id.substring(0, lastdot) + \"_(Copy)\" + sel.id.substring(lastdot);\n        }\n        var newname = window.prompt(\"Name for duplicate: \", nn);\n        var contents = editor._internals.doReadServer(\"read\", editor.config.path + sel.id);\n        if (contents[0] != \"1\") {\n          window.alert (\"Couldn't read the file for some reason. aborting.\");\n          console.error (\"couldn't read the file for some reason. aborting.\");\n          return;\n        }\n        contents = contents.substring(1, contents.length);\n        var resp = editor._internals.doWriteServer(\"create\", editor.config.path + newname, contents);\n        goodReload();\n      }\n      function createFolder() {\n        var btns = getSelectedFiles();\n        if (btns.length != 0) {\n          warnDeselectFiles(\"To create a folder\");\n          return;\n        }\n        var newname = window.prompt(\"Name for new folder: \", \"\");\n        console.log (newname);\n        if (newname == null) return;\n        if (newname == \"\") {\n          window.alert(\"Please set a name for the new folder!\");\n          return;\n        }\n        var dups = isDuplicateHere(newname);\n        if (dups) {\n          const conf = window.confirm (\"Are you sure you want to overwrite a folder with the name \" + newname + \" with an empty file? This would delete the folder.\");\n          if (!conf) return;\n        }\n        editor._internals.doWriteServer(\"mkdir\", newname, \"\");\n        goodReload();\n      }\n      function moveFs() {\n        var btn = getOneFile(\"To move files or folders\");\n        if (!btn) return;\n        if (btn.id == \"..\") {\n          window.alert(\"Can't change the up dir\");\n          return;\n        }\n        var newpath = window.prompt(\"New path to file (relative to root of server):\", \"\");\n        if (newpath == null) return;\n        if (newpath[newpath.length -1] != \"/\") {\n          newpath = newpath + \"/\";\n        }\n        try {\n          var nldir = fullListDir(newpath);\n          if (isDupInFolder(nldir, btn.id)) {\n            const conf = window.confirm(\"Are you sure you want to overwrite an existing file?\");\n            if (!conf) return;\n          }\n        } catch (e) {\n          window.alert (\"The path specified does not exist. Move cancelled.\");\n          return;\n        }\n        console.log (\"move approved\");\n        var oldloc = (editor.config.path + btn.id);\n        var newloc = newpath == \"/\" ? btn.id : (newpath + btn.id);\n        console.log (\"renamimg\\n%s\\n%s\", (editor.config.path + btn.id), (newpath + btn.id));\n        editor._internals.doWriteServer(\"rename\", oldloc, newloc); \n        console.log (\"rename successful\");\n        goodReload();\n      }\n\n      function radPressed(){\n        var btns = document.querySelectorAll(\"input.filesBtn\");\n        if (!ispressed){\n          for(var i = 0; i < btns.length; i++){\n            if (btns[i].value == whichOne) continue;\n            btns[i].checked = false;\n          }\n        }\n      }\n      \n      // Returns a progress bar or reuses the existing one.\n      function initializeProgress() {\n        var progressBar = document.getElementById(\"progress-bar\");\n        if (!progressBar) {\n          progressBar = el(\"progress\", {id:\"progress-bar\", max:\"100\", value:\"0\", visible:false}, [], {isghost: true});\n        }\n        progressBar.value = 0;\n        progressBar.visible = true;\n        return progressBar;\n      }\n\n      var handleFiles = (files) => {\n        var pgbr = document.getElementById(\"forprog\");\n        var progbar = initializeProgress();\n        pgbr.append(progbar);\n        var uploadProgress = {};\n        var didUp = false;\n        ([...files]).forEach((fl) => {\n          var fileName = editor.config.path + fl.name;\n          uploadProgress[fileName] = 0;\n        });\n        var callbackUpload = function (fileName, file, percent) {\n          uploadProgress[fileName] = typeof percent == \"number\" ? percent : 100;\n          let total = 0;\n          let count = 0;\n          for(var i in uploadProgress) {\n            total += uploadProgress[i]\n            count++;\n          }\n          progbar.value = total / count;\n          if(total == 100) {\n            progbar.visible = false;\n            if (didUp) {\n              goodReload();\n              pgbr.innerHTML = \"\";\n            }\n          }\n        }\n        ([...files]).forEach((fl) => {\n          var fileName = editor.config.path + fl.name;\n          editor.uploadFile(fileName, fl,\n            callbackUpload,\n            (err) => {\n              pgbr.innerHTML = \"\";\n              console.err(err);\n            },\n            callbackUpload);\n          didUp = true;\n        });\n      }\n      function preventDefaults (e) {\n        e.preventDefault()\n        e.stopPropagation()\n      }\n      function handleDrop(e) {\n        preventDefaults(e);\n        let dt = e.dataTransfer;\n        let files = dt.files;\n        handleFiles(files);\n      }\n      function loadFileList() {\n        let form = document.getElementById(\"fileListing\");\n        form.innerHTML = \"\";\n        let files = thisListDir;\n        function getRecordForCheckbox(file) {\n          var rec = {type:\"checkbox\",\n                      id:file,\n                      class:\"filesBtn\",\n                      name:\"filesBtn\",\n                      value:file,\n                      onClick:\"whichOne=value\",\n                      onChange:\"radPressed()\"};\n          return rec;\n        }\n        var dirIcon = () => {\n          var d = el(\"div\", {}, [], {innerHTML: \n          `<svg class=\"file-extension-icon\" width=\"60\" height=\"30\">\n            <path d=\"M 8,3 5,6 5,26 10,10 32,10 32,6 18,6 15,3 8,3 Z M 5,26 10,10 37,10 32,26 Z\" />`});\n          return d.childNodes[0];\n        }\n        var extensionIcon = name => {\n          let extension = name.replace(/^(?:(?!\\.(?=[^\\.]*$)).)*\\.?/, \"\");\n          if(\".\" + extension == name || extension === \"\") extension = \"-\";\n          var d = el(\"div\", {}, [], {innerHTML: \n          `<svg class=\"file-extension-icon\" width=\"60\" height=\"30\">\n            <text x=\"0\" y=\"25\">${extension}\n           `});\n          return d.childNodes[0];\n        }\n\n        var fileItemDisplay = function(name, isDir) {\n           let newURL = name == \"..\" ?\n                    editor.config.path.replace(/(\\/|^)[^\\/]+\\/?$/, \"\")\n                  : editor.config.path + \"/\" + name;\n           var link = typeof isDir == \"boolean\" ? (isDir ? newURL + \"/?ls\" : newURL + \"?edit\") : name;\n           if(link.length > 0 && link[0] != \"/\") link = \"/\" + link;\n           return el(\"div\", {class:\"file-item\"}, [\n              el(\"input\", getRecordForCheckbox(name), \"\"),\n              el(\"label\", {for:name, value:name}, [ \n                isDir ? dirIcon() : extensionIcon(name),\n                el(\"a\", {href:link}, name, {onclick: function(event) {\n                  event.preventDefault();\n                  if(isDir) {\n                    window.history.pushState({localURL: location.href}, name, link);\n                    editor.config.path = newURL;\n                    goodReload();\n                  } else {\n                    editor._internals.doReloadPage(link);\n                  }\n                }})])]);\n        }\n        /*var otherItemDisplay = function(link, name) {\n           return el(\"div\", {class:\"file-item\"}, [\n              el(\"input\", getRecordForCheckbox(name), \"\"),\n              el(\"label\", {for:name, value:name}, [ \n                extensionIcon(name),\n                el(\"a\", {href:link}, name)\n                ])\n              ]);\n        }*/\n        //el(tag, attributes, children, properties)\n        if (editor.config.path != \"\") {\n          var link = \"../\" + \"?ls\";\n          form.append(fileItemDisplay(\"..\", true));\n        }\n        // directories before files, sorted case-insensitive\n        files.sort(([name1, isDir1], [name2, isDir2]) =>\n          isDir1 && !isDir2 ? -1 : isDir2 && !isDir1 ? 1 :\n          name1.toLowerCase() < name2.toLowerCase() ? -1 : 0);\n        for (i = 0; i < files.length; i++) {\n          var [name, isDir] = files[i];\n          let extension = name.replace(/^(?:(?!\\.(?=[^\\.]*$)).)*\\.?/, \"\");\n          if(\".\" + extension == name || extension === \"\") extension = \"-\";\n          const img_exts = [\"jpeg\", \"jpg\", \"png\", \"svg\", \"tiff\", \"tif\", \"gif\", \"pdf\"]\n          const is_img = img_exts.includes(extension.toLowerCase());\n          if (!is_img) {\n            if (isDir) {\n              form.append(fileItemDisplay(name, isDir))\n            } else {\n              form.append(fileItemDisplay(name, isDir));\n            }\n          } else {\n            form.append(fileItemDisplay(name));\n          }\n        }\n\n        form.append(el(\"input\", {type:\"file\", id:\"fileElem\", onchange:\"handleFiles(this.files)\"}, [], {}));\n      }\n      loadFileList();\n      var goodReload = () => {\n        document.getElementById(\"fileListing\").innerHTML = \"\";\n        thisListDir = fullListDir (editor.config.path);\n        loadFileList();\n      }\n    window.addEventListener('drop', handleDrop, false);\n    window.addEventListener('dragover', (e) => e.preventDefault(), false);\n    </script></body></html>]\n  else \n    Ok [<html><head></head><body class=\"editor-error\">\n      <p>Editor cannot open file because it does not recognize the extension.</p>\n      <p>As an alternative, you can open the file in raw mode by appending <code>?raw</code> to it.</p>\n      <button onclick=\"\"\"\n        location.search = location.search + (location.search == \"\" ? \"?raw\" : \"&raw\");\n      \"\"\">Open @path in raw mode</button>\n    </body></html>]\n\n{---------------------------------------------------------------------------\n Recovers from evaluation errors\n Recovers if page does not contain an html tag or a body tag\n----------------------------------------------------------------------------}\nrecoveredEvaluatedPage: List HtmlNode\nrecoveredEvaluatedPage = --updatecheckpoint \"recoveredEvaluatedPage\" <|\n  case evaluatedPage of\n  Err msg -> serverOwned \"Error Report\" <|\n    [<html><head></head><body style=\"color:#cc0000\" class=\"editor-error\"><div style=\"max-width:600px;margin-left:auto;margin-right:auto\"><h1>Error report</h1><button onclick=\"editor.reload();\" title=\"Reload the current page\">Reload</button><pre style=\"white-space:pre-wrap\">@msg</pre></div></body></html>]\n  Ok nodes ->\n    let hasChildTag theTag nodes = List.any (case of [tag, _, _] -> tag == theTag; _ -> False) nodes\n        recoverHtmlChildren nodes =\n          let hasHead = hasChildTag \"head\" nodes\n              hasBody = hasChildTag \"body\" nodes\n          in\n          if hasHead && hasBody then nodes else\n          let startBodyIndex = List.indexWhere (\n                 case of\n                   [tag, _, _] -> tag /= \"title\" && tag /= \"link\" && tag /= \"meta\" && tag /= \"script\" && tag /= \"style\" && tag /= \"base\" && tag /= \"isindex\" && tag /= \"nextid\" && tag /= \"range\" && tag /= \"head\"\n                   [\"TEXT\", x] -> not (Regex.matchIn \"\"\"^\\s*$\"\"\" x)\n                   [\"COMMENT\", _] -> False\n               ) nodes in\n          case List.split startBodyIndex nodes of\n              (([\"head\", _, _] as head)::whitespace, bodyElems) -> head :: (whitespace ++ [[\"body\", [], bodyElems]])\n              (headElems, ([\"body\", _, _] as body) :: whitespace) -> [[\"head\", [], headElems], body]\n              (headElems, bodyElems) -> [[\"head\", [], headElems], [\"body\", [], bodyElems]]\n        recoverHtml nodes =  nodes |> List.mapWithReverse identity (case of\n          [\"html\", attrs, children] -> [\"html\", attrs, recoverHtmlChildren children]\n          x -> x\n        )\n    in\n    if hasChildTag \"html\" nodes then\n      recoverHtml nodes\n    else -- We need to wrap nodes with html, title, links, consecutive style and script and empty text nodes\n      let aux nodes = case nodes of\n        ([\"TEXT\", x] as head) :: rest ->\n          if Regex.matchIn \"\"\"^\\s*$\"\"\" x then\n            head :: aux rest\n          else recoverHtml [[\"html\", [], nodes]]\n        ([\"COMMENT\", x] as head) :: rest ->\n          head :: aux rest\n        ([tag, _, _] as head) :: rest ->\n           if tag == \"!DOCTYPE\" then\n             head :: aux rest\n           else recoverHtml [[\"html\", [], nodes]]\n      in aux nodes\n\njsEnabled = boolVar \"js\" True\n\nremoveJS node = case node of\n  [text, content] -> node\n  [tag, attrs, children] ->\n    if tag == \"script\" then [tag, [], [[\"TEXT\", \"/*Script disabled by Thaditor*/\"]]] else\n    [tag, attrs, List.map removeJS children]\n  _ -> []\n\n{-\n-- On reverse, all ghost elems will have disappeared. We reinsert them.\nprependGhosts ghostElems = update.lens {\n  apply elems = ghostElems ++ elems\n  update _ = Ok (InputsWithDiffs [(elems, VListDiffs [(0, ListElemInsert)\n} finalElems\n-}\n\n{---------------------------------------------------------------------------\n Instruments the resulting HTML page\n - Removes whitespace that are siblings of <head> and <body>\n - !f the page is editable:\n   * Adds the contenteditable attribute to body\n   * Adds the edition menu and the source preview area\n - Else: Adds the \"edit\" box to switch to edit mode\n - Adds the initial scripts\n - Append the edition scripts so that we can modify the page even without edit mode (that's dangerous, should we avoid this?)\n----------------------------------------------------------------------------}\nmain: List HtmlNode\nmain =\n  --updatecheckpoint \"main\" <|\n  let filteredMainPage = List.filter (case of -- Remove text nodes from top-level document.\n        [\"TEXT\", _] -> False\n        _ -> True\n      ) recoveredEvaluatedPage in\n  List.mapWithReverse identity (case of\n    [\"html\", htmlattrs, htmlchildren] -> [\"html\", htmlattrs, htmlchildren |>\n      (let removeAfterBody l = case l of ([\"body\", _, _] as head) :: _ -> [head]; a :: b -> a :: removeAfterBody b\n           removeBeforeHead l = case l of [\"head\", _, _] :: _ -> l; a :: b -> removeBeforeHead b; _ -> l in\n       removeBeforeHead >> removeAfterBody) |>\n      List.mapWithReverse identity (case of\n        [\"head\", headattrs, headChildren] ->\n          let headChildren =  if jsEnabled then headChildren else List.map removeJS headChildren in\n          [\"head\", headattrs, if varFast then headChildren else\n             insertThereInstead identity True headChildren ++  -- All new nodes added to the beginning of the head are added back to headChildren.\n             serverOwned \"initial script and style \" initialScript ++ headChildren]\n        [\"body\", bodyattrs, bodyChildren] ->\n          let bodyChildren = if jsEnabled then bodyChildren else List.map removeJS bodyChildren in\n          [\"body\", bodyattrs, bodyChildren]\n        x -> x -- anything else, i.e. comments or text nodes between end of head and start of body.\n      )]\n    x -> x\n  ) filteredMainPage --|> Update.debug \"main\"\n\n-- Returns an empty list. If elements are inserted, inserts them in the given list instead.\ninsertThereInstead onInsert atBeginning list =\n  Update.lens {apply _ = [],\n    update {outputNew, input=list} =\n      Ok (InputsWithDiffs [(if atBeginning then onInsert outputNew ++ list else list ++ onInsert outputNew, Just <|\n        VListDiffs [(if atBeginning then 0 else List.length list, ListElemInsert (List.length outputNew))]\n      )])\n  } list\n\n{---------------------------------------------------------------------------\n Definitions for the pipeline above\n----------------------------------------------------------------------------}\n\nboolToCheck = Update.bijection (case of \"true\" -> [[\"checked\", \"\"]]; _ -> []) (case of [[\"checked\", \"\"]] -> \"true\"; _ -> \"false\")\n\ninitialScript = serverOwned \"initial script\" <| [\n  <script id=\"thaditor-vars\" class=\"editor-interface\">\n     editor = typeof editor == \"undefined\" ? {} : editor;\n     editor.config = typeof editor.config == \"undefined\" ? {} : editor.config;\n     editor.config.EDITOR_VERSION = typeof EDITOR_VERSION === \"number\" ? EDITOR_VERSION : 0;\n     editor.config.path = @(jsCode.stringOf path);\n     editor.config.varedit = @(if varedit then \"true\" else \"false\");\n     editor.config.varls = @(if varls then \"true\" else \"false\");\n     editor.config.askQuestions = @(case listDict.get \"question\" vars of\n                       Just questionattr -> \"true\"\n                       _ -> if boolVar \"question\" True then \"true\" else 'false');\n     editor.config.autosave = @(case listDict.get \"autosave\" vars of\n                      Just autosaveattr -> \"true\"\n                      _ -> if boolVar \"autosave\" True then \"true\" else \"false\");\n     editor.config.canEditPage = @(if canEditPage then \"true\" else \"false\");\n     editor.config.editIsFalseButDefaultIsTrue = @(if varedit == False && (listDict.get \"edit\" defaultOptions |> Maybe.withDefault False) == True then \"true\" else \"false\");\n     // Are we using Thaditor?\n     editor.config.thaditor = typeof thaditor !== \"undefined\";\n     // User name, if defined. Used to create personalized temporary CSS files.\n     editor.config.userName = typeof userName === \"string\" ? userName : \"anonymous\";\n   </script>,\n-- The following is replaced by an inline <script> for when Editor runs as a file opener.\n   <script id=\"thaditor-luca\" class=\"editor-interface\" >editor = typeof editor == \"undefined\" ? {} : editor;\r\n\r\n(function(editor) {\r\n  // Default configuration.\r\n  editor.config = typeof editor.config == \"undefined\" ? {} : editor.config;\r\n  editor.config = {\r\n    EDITOR_VERSION: 1,\r\n    path: location.pathname,\r\n    varedit: location.search.match(/(^\\?|&)edit(?:=true)?(&|$)/),\r\n    varls: location.search.match(/(^\\?|&)ls(?:=true)?(&|$)/),\r\n    askQuestions: location.search.match(/(^\\?|&)question(?:=true)?(&|$)/),\r\n    autosave: location.search.match(/(^\\?|&)autosave(?:=true)?(&|$)/),\r\n    canEditPage: false,\r\n    editIsFalseButDefaultIsTrue : false,\r\n    thaditor: false,\r\n    userName: typeof userName === \"string\" ? userName : \"anonymous\",\r\n    ...editor.config};\r\n  \r\n  var _internals = {};\r\n  editor._internals = _internals;\r\n  // Overwrite the entire document (head and body)\r\n  // I'm not sure there is a better way.\r\n  function writeDocument(NC) {\r\n    let {scrollX, scrollY} = window;\r\n    document.open();\r\n    document.write(NC);\r\n    document.close();\r\n    setTimeout(() => {\r\n      window.scrollTo(scrollX, scrollY);\r\n    }, 0)\r\n  }\r\n  _internals.writeDocument = writeDocument;\r\n\r\n  // Asynchronous if onOk is defined and readServer is defined. and asynchronous and returns result otherwise.\r\n  \r\n  // Could be overriden so that Editor could work with a local file system, Git, or anything else.\r\n  _internals.doReadServer = function doReadServer(action, name, onOk, onErr) {\r\n    if (typeof thaditor != \"undefined\") { // apache_server, everything goes through thaditor\r\n      return thaditor._internals.readServer(action, name, onOk, onErr);\r\n    } else {\r\n      var request = new XMLHttpRequest();\r\n      var url = \"/\";\r\n      request.open('GET', url, false);  // `false` makes the request synchronous\r\n      request.setRequestHeader(\"action\", action);\r\n      request.setRequestHeader(\"name\", name);\r\n      request.send(null);\r\n      if(request.status == 200) {\r\n        return request.responseText || \"\";\r\n      } else {\r\n        console.log(\"error while reading \" + url, request);\r\n        return undefined;\r\n      }\r\n    }\r\n  };\r\n\r\n  // Returns a promise after performing a direct GET action on the server.\r\n  function getServer(action, name) {\r\n    return new Promise(function(resolve, reject) {\r\n      _internals.doReadServer(action, name, resolve, reject);\r\n    });\r\n  }\r\n  editor.getServer = getServer;\r\n\r\n  // Asynchronous if onOk is defined and writeServer is defined. and asynchronous and returns result otherwise.\r\n  function doWriteServer(action, name, content, onOk, onErr) {\r\n    if (typeof thaditor != \"undefined\") {\r\n      return thaditor._internals.writeServer(action, name, content, onOk, onErr);\r\n    } else {\r\n      var request = new XMLHttpRequest();\r\n      var url = \"/\";\r\n      request.open('POST', url, false);  // `false` makes the request synchronous\r\n      request.setRequestHeader(\"action\", action);\r\n      request.setRequestHeader(\"name\", name);\r\n      request.send(content);\r\n      if(request.status == 200) {\r\n        return request.responseText;\r\n      } else if(request.status == 500) {\r\n        return request.responseText;\r\n      } else {\r\n        console.log(\"error while writing \" + url, request);\r\n        return \"\";\r\n      }\r\n    }\r\n  }\r\n  _internals.doWriteServer = doWriteServer;\r\n\r\n  // Returns a promise after performing a direct POST action on the server.\r\n  function postServer(action, name, content) {\r\n    return new Promise(function(resolve, reject) {\r\n      _internals.doWriteServer(action, name, content, resolve, reject);\r\n    });\r\n  }\r\n  editor.postServer = postServer;\r\n\r\n  // Page reloading without trying to recover the editor's state.\r\n  function doReloadPage(url, replaceState) {\r\n    function finish(text, newLocalURL) {\r\n      writeDocument(text);\r\n      if(newLocalURL) {\r\n        window.history[replaceState ? \"replaceState\" : \"pushState\"]({localURL: newLocalURL}, \"Nav. to \" + newLocalURL, newLocalURL);\r\n      }\r\n    }\r\n    if(editor.config.thaditor) { // Ask the worker to recompute the page\r\n      thaditor.do({action:\"sendRequest\",\r\n        toSend: \"{\\\"a\\\":1}\",\r\n        loc: location.pathname + location.search,\r\n        requestHeaders: {reload: true, url: url},\r\n        what: undefined}).then(data => {\r\n          if (data.action == \"confirmDone\") {\r\n            finish(data.text, data.newLocalURL);\r\n          }\r\n        });\r\n    } else { // Ask Editor's web server to recompute the page.\r\n      var xmlhttp = new XMLHttpRequest();\r\n      xmlhttp.onreadystatechange = (xmlhttp => () => {\r\n        if (xmlhttp.readyState == XMLHttpRequest.DONE) {\r\n          finish(xmlhttp.responseText, xmlhttp.getResponseHeader(\"New-Local-URL\"));\r\n        }\r\n      })(xmlhttp);\r\n      xmlhttp.open(\"POST\", location.pathname + location.search);\r\n      xmlhttp.setRequestHeader(\"reload\", \"true\");\r\n      xmlhttp.setRequestHeader(\"url\", url);\r\n      console.log(\"setting url to \", url);\r\n      xmlhttp.send(\"{\\\"a\\\":1}\");\r\n    }\r\n  }\r\n  editor._internals.doReloadPage = doReloadPage;\r\n\r\n  // Uploads a file\r\n  // targetPathName: The path where to upload the file\r\n  // file: The file to upload (typically from a drop event or a input[type=file] change)\r\n  // onOk: Callback when upload is complete, with targetPathName and file\r\n  // onErr: callback if upload fails, with targetPathName and file\r\n  // onProgress: callback every progress made, with targetPathName, file and percentage\r\n  function uploadFile(targetPathName, file, onOk, onError, onProgress) {\r\n    if(editor.config.thaditor) {\r\n      thaditor.postServer(\"write\", targetPathName, file, onProgress).then(() => {\r\n        if(onOk) onOk(targetPathName, file);\r\n      }).catch(() => {\r\n         if(onError) onError(targetPathName, file);\r\n      })\r\n    } else { // Editor webserver\r\n      var xhr = new XMLHttpRequest();\r\n      xhr.onprogress = (e) => {\r\n        if(onProgress) {\r\n          onProgress(targetPathName, file, e && (e.loaded * 100.0 / e.total) || 100)\r\n        }\r\n      }\r\n      xhr.onreadystatechange = ((xhr, file) => () => {\r\n        if (xhr.readyState == XMLHttpRequest.DONE) {\r\n          if (xhr.status == 200 || xhr.status == 201) {\r\n            onOk ? onOk(targetPathName, file) : 0;\r\n          } else {\r\n            console.log(\"Error while uploading picture or file\", xhr);\r\n            onError ? onError(targetPathName, file) : 0;\r\n          }\r\n        }\r\n      })(xhr, file);\r\n      xhr.open(\"POST\", targetPathName, false);\r\n      xhr.setRequestHeader(\"write-file\", file.type);\r\n      xhr.send(file);\r\n    }\r\n  }\r\n  editor.uploadFile = uploadFile;\r\n  \r\n  function pasteHtmlAtCaret(html) {\r\n    var sel, range;\r\n    if (window.getSelection) {\r\n        // IE9 and non-IE\r\n        sel = window.getSelection();\r\n        // do not paste html into modify menu\r\n        if (sel.anchorNode.offsetParent && sel.anchorNode.offsetParent.id === \"modify-menu\") {\r\n          return;\r\n        }\r\n        if (sel.getRangeAt && sel.rangeCount) {\r\n            range = sel.getRangeAt(0);\r\n            range.deleteContents();\r\n            // Range.createContextualFragment() would be useful here but is\r\n            // only relatively recently standardized and is not supported in\r\n            // some browsers (IE9, for one)\r\n            var div = document.createElement(\"div\");\r\n            div.innerHTML = html;\r\n            var frag = document.createDocumentFragment(), node, lastNode;\r\n            while ( (node = div.firstChild) ) {\r\n                lastNode = frag.appendChild(node);\r\n            }\r\n            range.insertNode(frag);\r\n            // Preserve the selection\r\n            if (lastNode) {\r\n                range = range.cloneRange();\r\n                range.setStartAfter(lastNode);\r\n                range.collapse(true);\r\n                sel.removeAllRanges();\r\n                sel.addRange(range);\r\n            }\r\n        }\r\n    } else if (document.selection && document.selection.type != \"Control\") {\r\n        // IE < 9\r\n        document.selection.createRange().pasteHTML(html);\r\n    }\r\n  }\r\n  editor.pasteHtmlAtCaret = pasteHtmlAtCaret;\r\n  \r\n  // Given some files, uploads them and place them at cursor. Images are inserted as <img>, whereas other files just have the <a href=>)\r\n  function uploadFilesAtCursor(files) { \r\n    // files is a FileList of File objects. List some properties.\r\n    for (var i = 0, file; file = files[i]; i++) {\r\n      var targetPathName =  editor.getStorageFolder(file) + file.name;\r\n      // if(file.size < 30000000)\r\n      editor.uploadFile(targetPathName, file, (targetPathName, file) => {\r\n        if(file.type.indexOf(\"image\") == 0) {\r\n          editor.pasteHtmlAtCaret(`<img src=\"${targetPathName}\" alt=\"${file.name}\">`);\r\n        } else {\r\n          editor.pasteHtmlAtCaret(`<a href=\"${targetPathName}\">${targetPathName}</a>`); \r\n        }\r\n      });\r\n    }\r\n  }\r\n  editor.uploadFilesAtCursor = uploadFilesAtCursor;\r\n  \r\n  // Returns the storage folder that will prefix a file name on upload (initial slash excluded, final slash included)\r\n  editor.getStorageFolder = function(file) {\r\n    var storageOptions = document.querySelectorAll(\"meta[editor-storagefolder]\");\r\n    for(let s of storageOptions) {\r\n      if(file.type.startsWith(s.getAttribute(\"file-type\") || \"\")) {\r\n        let sf = storageOptions.getAttribute(\"editor-storagefolder\") || \"\";\r\n        if(!sf.endsWith(\"/\")) sf = sf + \"/\";\r\n        return sf;\r\n      }\r\n    }\r\n    let extension = \"\";\r\n    if(file && file.type.startsWith(\"image\")) {\r\n      var otherImages = document.querySelectorAll(\"img[src]\");\r\n      for(let i of otherImages) {\r\n         extension = (i.getAttribute(\"src\") || \"\").replace(/[^\\/]*$/, \"\");\r\n         break;\r\n      }\r\n      if(extension[0] == \"/\") { // Absolute URL\r\n        return extension;\r\n      }\r\n    }\r\n    if(extension != \"\" && extension[extension.length-1] != \"/\") {\r\n      extension = extension + \"/\";\r\n    }\r\n    // extension ends with a / or is empty\r\n    var tmp = location.pathname.split(\"/\");\r\n    tmp = tmp.slice(0, tmp.length - 1);\r\n    storageFolder = tmp.join(\"/\") + (extension != \"\" ?  \"/\" + extension : \"/\");\r\n    return storageFolder;\r\n  }\r\n  editor.fs = { \r\n    listdir: \r\n      async function(dirname) {\r\n        return JSON.parse(await getServer(\"listdir\", dirname) || \"[]\");\r\n      }\r\n  };\r\n\r\n  function getSelectorOf(clickedElem) {\r\n    let curSelector = clickedElem.tagName.toLowerCase();\r\n    if(curSelector === \"html\" || curSelector === \"body\" || curSelector === \"head\") return curSelector;\r\n    if(clickedElem.getAttribute(\"id\")) {\r\n      curSelector += \"#\" + clickedElem.getAttribute(\"id\");\r\n    }\r\n    if (clickedElem.getAttribute(\"class\") && clickedElem.getAttribute(\"class\") != \"\") {\r\n      curSelector += (\" \" + clickedElem.getAttribute(\"class\").trim()).replace(/\\s+/g, \".\");\r\n    }\r\n    return curSelector;\r\n  }\r\n  \r\n  // Given a node, computes a way to retrieve this node if the page was reloaded.\r\n  // That's a treasure map.\r\n  editor.toTreasureMap = function(oldNode) {\r\n    if(!oldNode) return undefined;\r\n    if(oldNode.nodeType == 1 && oldNode.getAttribute(\"id\") && document.getElementById(oldNode.getAttribute(\"id\"))) {\r\n      return {id: oldNode.getAttribute(\"id\")};\r\n    }\r\n    let tentativeSelector = [];\r\n    let t = oldNode;\r\n    let isText = false, textIndex = 0;\r\n    while(t && t.parentNode) {\r\n      let index = Array.prototype.slice.call( t.parentNode.children ).indexOf(t);\r\n      if(t.nodeType === 1) {\r\n        let theSelector = getSelectorOf(t);\r\n        tentativeSelector.unshift(theSelector);\r\n        // Emulate :nth-of-type but for a class of siblings having the same selector.\r\n        let s = t.previousElementSibling;\r\n        if(!t.getAttribute(\"id\")) {\r\n          while(s) {\r\n            if(s.matches(theSelector)) {\r\n              tentativeSelector.unshift(\"~\", theSelector);\r\n            }\r\n            s = s.previousElementSibling;\r\n          }\r\n        }\r\n        if(t.hasAttribute(\"id\")) break;\r\n      } else {\r\n        isText = true;\r\n        textIndex = Array.prototype.slice.call( t.parentNode.childNodes ).indexOf(t);\r\n      }\r\n      t = t.parentNode;\r\n    }\r\n    return {tentativeSelector: tentativeSelector, isText: isText, textIndex: textIndex};\r\n  }\r\n  // Returns the new node that matches the old node the closest.\r\n  // For text nodes, try to recover the text node, if not, returns the parent node;\r\n  editor.fromTreasureMap = function(data) {\r\n    if(!data) return undefined;\r\n    if(typeof data === \"object\" && data.id) {\r\n      return document.getElementById(data.id);\r\n    }\r\n    if(typeof data == \"object\" && Array.isArray(data.tentativeSelector)) {\r\n      let tentativeSelector = [...data.tentativeSelector];\r\n      while(tentativeSelector.length >= 1) {\r\n        if(tentativeSelector[0] !== \"~\") {\r\n          let newNode = document.querySelector(tentativeSelector.join(\" \"));\r\n          if(newNode) {\r\n            return data.isText && newNode.childNodes && newNode.childNodes[data.textIndex] || newNode;\r\n          }\r\n        }\r\n        tentativeSelector.shift();\r\n      }\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  // Helper to create an element with attributes, children and properties\r\n  function el(tag, attributes, children, properties) {\r\n    let tagClassIds = tag.split(/(?=#|\\.)/g);\r\n    let x;\r\n    for(let attr of tagClassIds) {\r\n      if(x && attr.startsWith(\".\")) {\r\n        x.classList.toggle(attr.substring(1), true);\r\n      } else if(x && attr.startsWith(\"#\")) {\r\n        x.setAttribute(\"id\", attr.substring(1));\r\n      } else if(!x) {\r\n        x = document.createElement(attr);\r\n      }\r\n    }\r\n    if(typeof attributes == \"object\") {\r\n      for(let k in attributes) {\r\n        let v = attributes[k];\r\n        if(typeof v != \"undefined\") {\r\n          x.setAttribute(k, v);\r\n        }\r\n      }\r\n    }\r\n    if(Array.isArray(children)) {\r\n      for(let child of children) {\r\n        if(typeof child === \"string\") {\r\n          x.append(child)\r\n        } else if(typeof child !== \"undefined\")\r\n          x.appendChild(child);\r\n      }\r\n    } else if(typeof children !== \"undefined\") {\r\n      x.append(children);\r\n    }\r\n    if(typeof properties == \"object\") {\r\n      for(let k in properties) {\r\n        x[k] = properties[k];\r\n      }\r\n    }\r\n    return x;\r\n  }\r\n  editor.el = el;\r\n  \r\n  // Returns true if the element matches the selector\r\n  // Equivalent curried call: editor.matches(selector)(elem)\r\n  editor.matches = function(elem, selector) {\r\n    if(typeof selector == \"undefined\") { // Then selector is in the elem variable\r\n      return (selector => function(elem) {\r\n        return editor.matches(elem, selector);\r\n      })(elem);\r\n    }\r\n    if(elem && elem.matches) {\r\n      try {\r\n        return elem.matches(selector);\r\n      } catch(e) {\r\n        console.log(\"error while matching selector \" + selector, e);\r\n        return false;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // An array of (node => {innerHTML, attributes, properties}) that can be defined by plug-ins.\r\n  editor.customContextMenuButtons = [];\r\n  \r\n  // Creates an SVG icon from the given path. If fill is true, will have the path filled.\r\n  function svgFromPath(path, fill, width, height, viewBox) {\r\n    return `<svg class=\"context-menu-icon${fill ? \" fill\": \"\"}\" \r\n          width=\"${width ? width : 40}\" height=\"${height ? height : 30}\" \r\n          ${viewBox ? \"viewBox=\\\"\" + viewBox[0] + \" \"+ viewBox[1] + \" \"+ viewBox[2] + \" \"+ viewBox[3] +\"\\\"\" : \"viewBox=\\\"0 0 40 30\\\"\"}>\r\n          <path d=\"${path}\"></path></svg>`\r\n  }\r\n  editor.svgFromPath = svgFromPath;\r\n  \r\n  /***************************\r\n   * Ghost & ignored API\r\n   ****************************/\r\n  \r\n  // Returns true if this element is marked as ghost\r\n  function isGhostNode(elem) {\r\n    return elem && elem.isghost || (elem.nodeType == 1 &&\r\n      (elem.tagName == \"GHOST\" || elem.getAttribute(\"isghost\") == \"true\"));\r\n  }\r\n  editor.isGhostNode = isGhostNode;\r\n  \r\n  // Returns true if all children of this elements are marked as ghosts\r\n  function areChildrenGhosts(n) {\r\n    return n && n.getAttribute && (\r\n      n.getAttribute(\"children-are-ghosts\") == \"true\" ||\r\n      n.getAttribute(\"children-are-ghost\") == \"true\"\r\n    ) ||\r\n    editor.ghostChildNodes.find(f => f(n));\r\n  }\r\n  editor.areChildrenGhosts = areChildrenGhosts;\r\n  \r\n  // Returns true if this element has a node which implicitly marks it as a ghost\r\n  function hasGhostAncestor(htmlElem) {\r\n    if(htmlElem == null) return false;\r\n    if(isGhostNode(htmlElem)) return true;\r\n    return areChildrenGhosts(htmlElem.parentNode) || (htmlElem.parentNode == null && htmlElem.nodeType !== 9 /*document*/) || hasGhostAncestor(htmlElem.parentNode);\r\n  }\r\n  editor.hasGhostAncestor = hasGhostAncestor;\r\n  \r\n  function isGhostAttributeKey(name) {\r\n    return name.startsWith(\"ghost-\");\r\n  }\r\n  editor.isGhostAttributeKey = isGhostAttributeKey;\r\n\r\n  // Array of functions on nodes returning an array of attributes that should be ghosts (i.e. removed on back-propagation)\r\n  editor.ghostAttrs = [];\r\n  editor.ghostAttrs.push(n =>\r\n    ((n && n.getAttribute && n.getAttribute(\"list-ghost-attributes\")) || \"\").split(\" \").concat(\r\n      ((n && n.getAttribute && n.getAttribute(\"save-ghost-attributes\")) || \"\").split(\" \")).filter(a => a != \"\")\r\n  );\r\n  // attribute of some chrome extensions\r\n  editor.ghostAttrs.push(n => [\"bis_skin_checked\"]);\r\n  \r\n  // Array of functions on nodes returning an array of predicates such that if one is true, the children of this element will be ignored (i.e. their old value is always returned on back-propagation)\r\n  editor.ignoredChildNodes = [];\r\n  \r\n  // Returns truesy if the element n is ignoring child nodes.\r\n  function isIgnoringChildNodes(n) {\r\n    return editor.ignoredChildNodes.find(f => f(n));\r\n  }\r\n  editor.isIgnoringChildNodes = isIgnoringChildNodes;\r\n  // Assuming that n is ignoring children, stores the encoding of the original children\r\n  function storeIgnoredChildNodes(n) {\r\n    let res = [];\r\n    for(let k = 0; k < n.childNodes.length; k++) {\r\n      res.push(domNodeToNativeValue(n.childNodes[k]));\r\n    }\r\n    // Let's store this element's array of children\r\n    n.__editor__ = n.__editor__ || {};\r\n    n.__editor__.ignoredChildNodes = res;\r\n  }\r\n  editor.storeIgnoredChildNodes = storeIgnoredChildNodes;\r\n\r\n  // Return true if this htmlElem is inside an element that ignores its children.\r\n  function hasIgnoringAncestor(htmlElem) {\r\n    if(htmlElem == null) return false;\r\n    return isIgnoringChildNodes(htmlElem.parentNode) || hasIgnoringAncestor(htmlElem.parentNode);\r\n  }\r\n  editor.hasIgnoringAncestor = hasIgnoringAncestor;\r\n  \r\n  // Array of functions on nodes returning an array of attributes that should be ignored (i.e. old value returned on back-propagation)\r\n  editor.ignoredAttrs = [];\r\n  editor.ignoredAttrs.push(n =>\r\n    ((n && n.getAttribute && n.getAttribute(\"list-ignored-attributes\")) || \"\").split(\" \").concat(\r\n      ((n && n.getAttribute && n.getAttribute(\"save-ignored-attributes\")) || \"\").split(\" \")).filter(a => a != \"\")\r\n  );\r\n  editor.ignoredAttrs.push(n => editor.matches(n, \"body\") ? [\"contenteditable\", \"data-gr-c-s-loaded\"] : []);\r\n  editor.ignoredAttrs.push(n => editor.matches(n, \"html\") ? [\"class\"] : []);\r\n  \r\n  \r\n  // Returns a method that, for each key name, return true if it is a ghost attribute for the node\r\n  function isSpecificGhostAttributeKeyFromNode(n) {\r\n    var additionalGhostAttributes = [];\r\n    for(var k in editor.ghostAttrs) {\r\n      additionalGhostAttributes = additionalGhostAttributes.concat(editor.ghostAttrs[k](n))\r\n    }\r\n    return (a => name => a.indexOf(name) != -1)(additionalGhostAttributes);\r\n  }\r\n  editor.isSpecificGhostAttributeKeyFromNode = isSpecificGhostAttributeKeyFromNode;\r\n\r\n  // Returns a method that, for each key name, return true if it is an ignored attribute for the node\r\n  function isIgnoredAttributeKeyFromNode(n) {\r\n    var additionalIgnoredAttributes = [];\r\n    for(var k in editor.ignoredAttrs) {\r\n      additionalIgnoredAttributes = additionalIgnoredAttributes.concat(editor.ignoredAttrs[k](n))\r\n    }\r\n    return ((a, n) => (name, oldValue) => {\r\n      let result = a.indexOf(name) != -1;\r\n      if(result) { // let's store the previous attribute's value, even if it did not exist.\r\n        n.__editor__ = n.__editor__ || {};\r\n        n.__editor__.ignoredAttrMap = n.__editor__.ignoredAttrMap || {};\r\n        if(!(name in n.__editor__.ignoredAttrMap)) {\r\n          n.__editor__.ignoredAttrMap[name] = oldValue;\r\n        }\r\n      }\r\n      return result;\r\n    })(additionalIgnoredAttributes, n);\r\n  }\r\n  editor.isIgnoredAttributeKeyFromNode = isIgnoredAttributeKeyFromNode;\r\n  function ignoredAttributeValue(n, name) {\r\n    let result = n.__editor__.ignoredAttrMap[name];\r\n    if(name in n.__editor__.ignoredAttrMap) {\r\n      return result;\r\n    }\r\n    return n.getAttribute(name);\r\n  }\r\n  \r\n  // Array of predicates that, if they return true on a node, Editor will mark this node as ghost.\r\n  editor.ghostNodes = [];\r\n  // Array of predicates that, if they return true on a node, Editor will mark all the children of this node as ghosts\r\n  editor.ghostChildNodes = [];\r\n\r\n  // Analytics scripts\r\n  editor.ghostNodes.push(insertedNode =>\r\n    editor.matches(insertedNode, \"script[src]\") &&\r\n       (insertedNode.getAttribute(\"src\").indexOf(\"google-analytics.com/analytics.js\") != -1 ||\r\n        insertedNode.getAttribute(\"src\").indexOf(\"google-analytics.com/gtm/js\") != -1 ||\r\n        insertedNode.getAttribute(\"src\").indexOf(\"googletagmanager.com/gtm.js\") != -1)\r\n  );\r\n\r\n  // For for ace styles in header\r\n  editor.ghostNodes.push(insertedNode => {\r\n      if(insertedNode.tagName == \"STYLE\" && typeof insertedNode.getAttribute(\"id\") == \"string\" &&\r\n       (insertedNode.getAttribute(\"id\").startsWith(\"ace-\") ||\r\n        insertedNode.getAttribute(\"id\").startsWith(\"ace_\"))) {\r\n        insertedNode.setAttribute(\"save-ghost\", \"true\"); \r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n  );\r\n  // For Google sign-in buttons and i-frames\r\n  editor.ghostNodes.push(\r\n    editor.matches(\"div.abcRioButton, iframe#ssIFrame_google\")\r\n  );\r\n  // For anonymous styles inside HEAD (e.g. ace css themes and google sign-in)\r\n  editor.ghostNodes.push(insertedNode => \r\n     insertedNode.tagName == \"STYLE\" && insertedNode.getAttribute(\"id\") == null && insertedNode.attributes.length == 0 &&\r\n     insertedNode.parentElement.tagName == \"HEAD\" && typeof insertedNode.isghost === \"undefined\"&& insertedNode.textContent.match(\"error_widget\\\\.ace_warning\")\r\n     && (insertedNode.setAttribute(\"save-ghost\", \"true\") || true)\r\n   );\r\n  // For ace script for syntax highlight\r\n  editor.ghostNodes.push(insertedNode =>\r\n    editor.matches(insertedNode, \"script[src]\") &&\r\n       insertedNode.getAttribute(\"src\").startsWith(\"https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.6/mode-j\")\r\n  );\r\n  // For ace script for syntax highlight\r\n  editor.ghostNodes.push(insertedNode =>\r\n    insertedNode.tagName == \"ACE_OUTER\"\r\n  );\r\n  // For the grammarly extension\r\n  editor.ghostNodes.push(\r\n    editor.matches(\".gr-top-z-index, .gr-top-zero\")\r\n  );\r\n\r\n  function domNodeToNativeValue(n) {\r\n    if(n.nodeType == 3) {\r\n      return [\"TEXT\", n.textContent];\r\n    } else if(n.nodeType == 8) {\r\n      return [\"COMMENT\", n.textContent];\r\n    } else if(n.nodeType === 10) {\r\n      return [\"!DOCTYPE\", n.name, n.publicId ? n.publicId : [], n.systemId ? n.systemId : []];\r\n    } {\r\n      var attributes = [];\r\n      var tagName = n.nodeType === document.DOCUMENT_NODE ? \"#document\" : n.tagName.toLowerCase();\r\n      if(n.nodeType == 1) {\r\n        var isSpecificGhostAttributeKey = isSpecificGhostAttributeKeyFromNode(n);\r\n        var isIgnoredAttributeKey =  isIgnoredAttributeKeyFromNode(n); // TODO recover ignored value\r\n        for(var i = 0; i < n.attributes.length; i++) {\r\n          var key = n.attributes[i].name;\r\n          var ignored = isIgnoredAttributeKey(key);\r\n          if(!isGhostAttributeKey(key) && !isSpecificGhostAttributeKey(key) || ignored) {\r\n            var value = ignored ? ignoredAttributeValue(n, key) : n.attributes[i].value;\r\n            if(typeof value == \"undefined\") continue;\r\n            if(key == \"style\") {\r\n              value = value.split(\";\").map(x => x.split(\":\")).filter(x => x.length == 2)\r\n            }\r\n            attributes.push([key, value]);\r\n          }\r\n        }\r\n      }\r\n      var children = [];\r\n      if(n.__editor__ && n.__editor__.ignoredChildNodes) {\r\n        children = n.__editor__.ignoredChildNodes;\r\n      } else {\r\n        var childNodes = n.childNodes;\r\n        if(tagName.toLowerCase() === \"noscript\" && n.childNodes.length === 1 && n.childNodes[0].nodeType === 3) {\r\n          // We'll recover the associated HTML node\r\n          childNodes = el(\"div\", {}, [], {innerHTML: n.childNodes[0].textContent, parentNode: n}).childNodes;\r\n        }\r\n        if(!areChildrenGhosts(n)) {\r\n          for(i = 0; i < childNodes.length; i++) {\r\n            if(!isGhostNode(childNodes[i])) {\r\n              children.push(domNodeToNativeValue(childNodes[i]));\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return [tagName, attributes, children];\r\n    }\r\n  }\r\n  editor.domNodeToNativeValue = domNodeToNativeValue;\r\n  \r\n  // Returns the closest ancestor of the selection having the given tagName\r\n  function getElementArCaret(tagName) {\r\n    var node = document.getSelection().anchorNode;\r\n    var w = node != null && node.nodeType == 3 ? node.parentNode : node;\r\n    if(!tagName) return w;\r\n    while(w != null && w.tagName.toLowerCase() != tagName.toLowerCase()) {\r\n      w = w.parentNode;\r\n    }\r\n    return w;\r\n  }\r\n  editor.getElementArCaret = getElementArCaret;\r\n\r\n  // Removes all the text from a node (not the text nodes themselves)\r\n  function emptyTextContent(node) {\r\n    if(node != null) {\r\n      if(node.nodeType == 3) {\r\n        node.textContent = \"\";\r\n      } else {\r\n        for(let i = 0; i < node.childNodes.length; i++) {\r\n          emptyTextContent(node.childNodes[i]);\r\n        }\r\n      }\r\n    }\r\n    return node;\r\n  }\r\n  editor.emptyTextContent = emptyTextContent;\r\n\r\n  // Duplicates a node. Returns the cloned element that has been inserted.\r\n  // options: {\r\n  //   onBeforeInsert: callback to transform cloned element before it is inserted (identity by default)\r\n  //   target: Node before which to place the duplicated node (original node by default)\r\n  //   after: If true, place the cloned node after the target node. (false by default)\r\n  //   ignoreText: if true, will not attempt to duplicate text / indentation. (false by default)\r\n  // }\r\n  function duplicate(node, options) {\r\n    if(typeof options == \"undefined\") options = {}\r\n    if(typeof options.onBeforeInsert != \"function\") options.onBeforeInsert = e => e;\r\n    if(node != null && node.parentNode != null) {\r\n      var parentInsertion = options.target ? options.target.parentElement : node.parentElement;\r\n      var insertBeforeNode = options.after ? options.target ? options.target.nextSibling : node.nextSibling :\r\n                                             options.target ? options.target             : node;\r\n      if(node.nextSibling != null && !options.target && !options.ignoreText) {\r\n        var next = node.nextSibling;\r\n        if(next.nodeType == 3 && next.nextSibling != null &&\r\n           next.nextSibling.tagName == node.tagName && (node.tagName == \"TR\" || node.tagName == \"TH\" || node.tagName == \"LI\" || node.tagName == \"TD\")) {\r\n          var textElement = next.cloneNode(true);\r\n          node.parentNode.insertBefore(textElement, options.after ? node.nextSibling : node);\r\n          if(options.after) {\r\n            insertBeforeNode = textElement.nextSibling;\r\n          } else {\r\n            insertBeforeNode = textElement\r\n          }\r\n        }\r\n      }\r\n      var duplicated = node.cloneNode(true);\r\n      function removeEditorAttributes(node) {\r\n        if(node.nodeType != 1) return;\r\n        let attrs = [...node.attributes];\r\n        for(var i = 0; i < attrs.length; i++) {\r\n          if(attrs[i].name.match(/^ghost-clicked$|^translate-id.*$/)) {\r\n            node.removeAttribute(attrs[i].name);\r\n          }\r\n        }\r\n        for(var i = 0; i < node.childNodes; i++) {\r\n          removeEditorAttributes(node.childNodes[i]);\r\n        }\r\n      }\r\n      removeEditorAttributes(duplicated);\r\n      \r\n      var cloned = options.onBeforeInsert(duplicated);\r\n      parentInsertion.insertBefore(cloned, insertBeforeNode);\r\n      return cloned;\r\n    }\r\n  }\r\n  editor.duplicate = duplicate;\r\n\r\n  // Removes a node from the DOM\r\n  // Attempts to remove the associated text element in the case of table elements or list items unless options.ignoreText is true\r\n  function remove(node, options) {\r\n    if(typeof options == \"undefined\") options = {}\r\n    if(node.previousSibling != null && !options.ignoreText) { // Remove whitespace as well\r\n      var next = node.nextSibling;\r\n      if(next.nodeType == 3 && next.nextSibling != null &&\r\n         next.nextSibling.tagName == node.tagName && (node.tagName == \"TR\" || node.tagName == \"TH\" || node.tagName == \"LI\" || node.tagName == \"TD\")) {\r\n        next.remove();\r\n      }\r\n    }\r\n    node.remove();\r\n  }\r\n  editor.remove = remove;\r\n\r\n  editor._internals.mutationCallbacks = {};\r\n   \r\n  // TODO: In the future, only determine if the user was either using the interface, or modifying a selected element.\r\n  // And then mark the mutation as computer or user. No more ghosts.\r\n  editor._internals.mutationCallbacks.handleScriptInsertion = \r\n    // Mark nodes as ghost on insertion, if they are so.\r\n    function handleScriptInsertion(mutations) {\r\n      for(var i = 0; i < mutations.length; i++) {\r\n        // A mutation is a ghost if either\r\n        // -- The attribute starts with 'ghost-'\r\n        // -- It is the insertion of a node whose tag is \"ghost\" or that contains an attribute \"isghost=true\"\r\n        // -- It is the modification of a node or an attribute inside a ghost node.\r\n        var mutation = mutations[i];\r\n        if(editor.hasGhostAncestor(mutation.target) || editor.hasIgnoringAncestor(mutation.target)) continue;\r\n        if(mutation.type == \"childList\") {\r\n          for(var j = 0; j < mutation.addedNodes.length; j++) {\r\n            var insertedNode = mutation.addedNodes[j];\r\n            if(editor.hasGhostAncestor(insertedNode)) {\r\n              insertedNode.isghost = true;\r\n            } else {\r\n              if(typeof insertedNode.isghost === \"undefined\" && (insertedNode.nodeType == 1 && insertedNode.getAttribute(\"isghost\") != \"true\" || insertedNode.nodeType == 3 && !insertedNode.isghost) && editor.ghostNodes.find(pred => pred(insertedNode, mutation))) {\r\n               if(insertedNode.nodeType == 1) insertedNode.setAttribute(\"isghost\", \"true\");\r\n               insertedNode.isghost = true;\r\n              } else { // Record ignored attributes\r\n                if(insertedNode.nodeType == 1) {\r\n                  var isIgnoredAttributeKey = editor.isIgnoredAttributeKeyFromNode(insertedNode);\r\n                  for(var k = 0; k < insertedNode.attributes.length; k++) {\r\n                    var attr = insertedNode.attributes[k];\r\n                    isIgnoredAttributeKey(attr.name, attr.value);\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n  \r\n  editor.ui = { _internals: {}, model: typeof editor.ui == \"object\" ? editor.ui.model : undefined };\r\n  editor.ui._internals.getLosslessCssParser = new Promise((resolve, reject) => {\r\n      editor.ui._internals.setLosslessCssParser = x => { editor.ui.CSSparser = new x(); resolve(x) };\r\n  });\r\n  \r\n  // Display an box to switch to edit mode.\r\n  // This is the only item available for UI even if edit=false\r\n  editor.ui._internals.switchEditBox = \r\n     function switchEditBox(toEdit) {\r\n      let prev = toEdit ? \"=false\" : \"(=true|=?$|=?(?=&))\",\r\n          next = toEdit ? \"\"  : \"=false\",\r\n          icon = toEdit ? editor.svgFromPath(\"M 30.85,10.65 19.56,21.95 19.56,21.95 16.96,19.34 28.25,8.05 30.85,10.65 30.85,10.65 Z M 31.56,9.94 33.29,8.21 C 33.68,7.82 33.67,7.19 33.28,6.8 L 32.1,5.62 C 31.71,5.23 31.08,5.22 30.68,5.62 L 28.96,7.34 31.56,9.94 31.56,9.94 Z M 16.31,20.11 15.67,23.22 18.81,22.61 16.31,20.11 16.31,20.11 16.31,20.11 Z M 26.41,16.5 26.41,26.5 C 26.41,27.61 25.51,28.5 24.41,28.5 L 9.4,28.5 C 8.3,28.5 7.41,27.6 7.41,26.49 L 7.41,3.51 C 7.41,2.4 8.31,1.5 9.41,1.5 L 19.41,1.5 19.41,7.5 C 19.41,8.61 20.3,9.5 21.41,9.5 L 25.41,9.5 29.99,4.92 C 30.78,4.13 32.04,4.13 32.82,4.91 L 34,6.09 C 34.77,6.87 34.77,8.14 33.99,8.92 L 26.41,16.5 26.41,16.5 Z M 20.41,1.5 20.41,7.5 C 20.41,8.05 20.86,8.5 21.4,8.5 L 26.41,8.5 20.41,1.5 20.41,1.5 Z\", true, 40, 40)  : \"x\",\r\n         title = toEdit ? \"Edit this page\" : \"Preview this page\";\r\n      return el(\"div#editbox.editor-interface\", {title: title}, [\r\n        el(\"style.editor-interface\", {}, `\r\n        #editbox {\r\n          ${toEdit ?\r\n         `position: fixed;\r\n          ${editor.config.onMobile() ? \"bottom\" : \"top\"}: 0px;\r\n          right: 0px;\r\n          margin-${editor.config.onMobile() ? \"bottom\" : \"top\"}: 25px;\r\n          margin-right: 25px;\r\n          border-radius: 60px;\r\n          background: var(--context-button-color);\r\n          ` :\r\n         `display: none`\r\n         }z-index: 20000;\r\n          opacity: 1;\r\n          cursor: pointer;\r\n        }\r\n        #editbox svg.context-menu-icon.fill>path {\r\n          fill: #ffffff;\r\n          fill-rule: evenodd;\r\n          stroke: #FFFFFF;\r\n          stroke-width: 0px;\r\n          stroke-linecap: none;\r\n          -linejoin: miter;\r\n          stroke-opacity: 0;\r\n        }\r\n        #editbox:hover {\r\n          background: var(--context-button-color-hover)\r\n        }`),\r\n        el(\"div.editor-interface\", {}, [], { innerHTML: icon })\r\n      ], {\r\n        isghost: true,\r\n        onclick(event) {\r\n          if(!location.search.match(new RegExp(\"edit\" + prev))) {\r\n             if(editor.ui.init) {\r\n               editor.config.canEditPage = true;\r\n               editor.ui.init();\r\n               document.body.setAttribute(\"contenteditable\", \"true\");\r\n               document.querySelector(\"#editbox\").remove();\r\n               if(typeof editor.config.onInit == \"function\") {\r\n                 editor.config.onInit()\r\n               }\r\n             } else {\r\n               location.search = location.search.startsWith(\"?\") ? location.search + \"&\" + \"edit\" + next : \"?edit\" + next\r\n             }\r\n          } else {\r\n             location.search = location.search.replace(new RegExp(\"edit\" + prev, \"g\"), \"edit\" + next);\r\n          }\r\n        }\r\n        });\r\n    } // editor.ui._internals.switchEditBox\r\n\r\n  // Hook Editor's core to the web window, add event listeners.\r\n  editor.init = function() {\r\n    \r\n    /*\r\n      Pretend loading a page using Editor's commands.\r\n      Does not attempt to load Editor's interface.\r\n    */\r\n    window.onpopstate = function(e){\r\n        console.log(\"onpopstate\", e);\r\n        if(e.state && e.state.localURL) {\r\n          editor._internals.doReloadPage(String(location), true);\r\n        } else {\r\n          editor._internals.doReloadPage(location.pathname + location.search, true);\r\n        }\r\n    };\r\n    \r\n    var onCopy = function(event) {\r\n      const selection = document.getSelection();\r\n      if(selection.rangeCount && (!document.activeElement || !document.activeElement.matches(\"#modify-menu *\"))) {\r\n        let range = selection.getRangeAt(0); // Let's put the correct stuff in the clipboardData.\r\n        let contents = range.cloneContents();\r\n        let newHtmlData = \"\";\r\n        for(let i = 0; i < contents.childNodes.length; i++) {\r\n          let n = contents.childNodes[i];\r\n          newHtmlData += n.nodeType == 1 ? n.outerHTML : el(\"div\", {}, n).innerHTML;\r\n        }\r\n        event.clipboardData.setData('text/html', newHtmlData);\r\n        event.preventDefault();\r\n      }\r\n    };\r\n    \r\n    var onPaste = function(e) {\r\n      if(e.clipboardData.types.indexOf(\"text/html\") >= 0 && (!document.activeElement || !document.activeElement.matches(\"#modify-menu *\"))) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        console.log(\"paste\", e);\r\n        let content = e.clipboardData.getData(\"text/html\").replace(/^\\s*<html>\\s*<body>\\s*(<!--[^\\-]*-->\\s*)?|(\\s*<!--[^\\-]*-->)?\\s*<\\/body>\\s*<\\/html>\\s*$/g, \"\");\r\n        console.log(\"pasted content\", content);\r\n        pasteHtmlAtCaret(content);\r\n        return true;\r\n      }\r\n    };\r\n    \r\n    var onDocLoad = function(event) { \r\n      document.body.addEventListener(\"copy\", onCopy);\r\n      document.body.addEventListener(\"paste\", onPaste, {capture: true});\r\n      \r\n      if(typeof editor.config.canEditPage == \"boolean\" && !editor.config.canEditPage && !editor.config.varls) {\r\n        document.body.insertBefore(editor.ui._internals.switchEditBox(true), document.body.childNodes[0]);\r\n      }\r\n      \r\n      if(!editor.config.thaditor && editor.config.editIsFalseButDefaultIsTrue) {\r\n        // Special case when ?edit=false but the default behavior is edit=true if nothing is set.\r\n        // Happens only in editor webserver.\r\n        // It continues to add edit=false to any clicked links.\r\n        document.onclick = function (e) {\r\n            var addEditEqualToUrl = function(href, what) {\r\n              if(href.indexOf(\"://\") == -1) { // Instrument the relative link so that it is edit=true\r\n                if(href.indexOf(\"?\") >= 0) {\r\n                  if(href.endsWith(\"?\")) {\r\n                    href = href + \"edit=\" + what\r\n                  } else {\r\n                    href = href + \"&edit=\" + what\r\n                  }\r\n                } else {\r\n                  href = href + \"?edit=\" + what\r\n                }\r\n              }\r\n              return href;\r\n            }\r\n            e = e ||  window.event;\r\n            var node = e.target || e.srcElement;\r\n            while(node) {\r\n              if(node.tagName == \"A\" && node.getAttribute(\"href\") && !node.onclick && !node.getAttribute(\"onclick\")) {\r\n               var newLocation = addEditEqualToUrl(node.getAttribute(\"href\"), \"false\");\r\n               console.log(newLocation);\r\n               window.location.href = newLocation;\r\n               e.stopPropagation();\r\n               return false;\r\n              } else {\r\n                node = node.parentNode;\r\n              }\r\n            }\r\n          }\r\n      } // end if !editor.config.thaditor && editor.config.editIsFalseButDefaultIsTrue\r\n    };\r\n    \r\n    // Events handler for copying and pasting, so that we have the least surprise.\r\n    // TODO: When the document is loaded, inject the interface?\r\n    document.addEventListener(\"DOMContentLoaded\", onDocLoad); // onDOMContentLoaded\r\n    \r\n    // Removes all callbacks\r\n    editor.uninit = function() {\r\n      window.onpopstate = undefined;\r\n      document.removeEventListener(\"DOMContentLoaded\", onDocLoad);\r\n      document.body.removeEventListener(\"copy\", onCopy);\r\n      document.body.removeEventListener(\"paste\", onPaste);\r\n      document.body.insertBefore(editor.ui._internals.switchEditBox(true), document.body.childNodes[0]);\r\n      document.onclick = undefined;\r\n      if (typeof editor._internals.automaticGhostMarker !== \"undefined\") {\r\n        // console.log(\"automaticGhostMarker.disconnect()\");\r\n        editor._internals.automaticGhostMarker.disconnect();\r\n      }\r\n    }\r\n    \r\n    // Immediately start listening to insertions to mark them as ghosts.\r\n    // TODO: In the future, we won't care anymore.\r\n    if (typeof editor._internals.automaticGhostMarker !== \"undefined\") {\r\n      // console.log(\"automaticGhostMarker.disconnect()\");\r\n      editor._internals.automaticGhostMarker.disconnect();\r\n    }\r\n\r\n    editor._internals.automaticGhostMarker = new MutationObserver(editor._internals.mutationCallbacks.handleScriptInsertion);\r\n    editor._internals.automaticGhostMarker.observe( document.head.parentElement\r\n     , { attributes: false\r\n       , childList: true\r\n       , characterData: false\r\n       , attributeOldValue: false\r\n       , characterDataOldValue: false\r\n       , subtree: true\r\n       }\r\n     );\r\n   } // editor.init\r\n  \r\n  editor.config.onMobile = () => window.matchMedia(\"(max-width: 800px)\").matches;\r\n  editor.config.buttonHeight = () => editor.config.onMobile() ? 48 : 30;\r\n  editor.config.buttonWidth  = () => editor.config.onMobile() ? 48 : 40;\r\n\r\n  // Helpers: Text preview and summary\r\n  function textPreview(element, maxLength) {\r\n    let x = element.textContent;\r\n    let result = \"'\" + x + \"'\";;\r\n    if(x == \"\") {\r\n      if(element.tagName === \"META\") {\r\n        result = element.getAttribute(\"charset\") ? \"charset:\" + element.getAttribute(\"charset\")  :\r\n                (element.getAttribute(\"name\") || element.getAttribute(\"http-equiv\") || \"(name?)\") + \": \" + (element.getAttribute(\"content\") || \"(content?)\");\r\n      } else if(element.tagName === \"SCRIPT\" || element.tagName === \"IMG\") {\r\n        result = typeof element.getAttribute(\"src\") === \"string\" ? (element.getAttribute(\"src\") || \"(src?)\").replace(/(https?:\\/\\/)?(www\\.)?/, \"\") : \"empty script\";\r\n      } else if(element.tagName === \"LINK\") {\r\n        result = typeof element.getAttribute(\"href\") === \"string\" ? (element.getAttribute(\"href\") || \"(src?)\").replace(/(https?:\\/\\/)?(www\\.)?/, \"\") : \"empty script\";\r\n      }\r\n    }\r\n    if(typeof maxLength !== \"undefined\" && result.length > maxLength) {\r\n      return result.substring(0, maxLength) + \"...'\";\r\n    }\r\n    return result;\r\n  }\r\n  function summary(element, idAndClasses, maxLength) {\r\n    var summary = element.tagName.toLowerCase();\r\n    if(idAndClasses && element.getAttribute(\"id\")) {\r\n      summary += \"#\" + element.getAttribute(\"id\");\r\n    }\r\n    var elemClass = element.getAttribute(\"class\");\r\n    if(idAndClasses && elemClass && elemClass.trim().length) {\r\n      summary += \".\" + elemClass.split(/\\s+/g).join(\".\");\r\n    }\r\n    summary += \" \" + textPreview(element);\r\n    maxLength = maxLength || 80;\r\n    summary = summary.substring(0, maxLength || 80) + (summary.length > 80 ? \"...\" : \"\");\r\n    return summary;\r\n  }\r\n  \r\n  function getTempCSSName(CSSFilePath) {\r\n    let newFilePath = CSSFilePath.split(\"/\");\r\n    let newFileName = `tmp-${editor.config.userName}-${newFilePath[newFilePath.length - 1]}`;\r\n    newFilePath[newFilePath.length - 1] = newFileName;\r\n    newFilePath = newFilePath.join(\"/\");\r\n    return newFilePath;\r\n  }\r\n  \r\n  function editor_stopWatching() {\r\n    editor.ui.model.outputObserver.disconnect();\r\n  }\r\n  \r\n  function editor_resumeWatching() {\r\n    editor.ui.model.outputObserver.observe\r\n      ( document.body.parentElement\r\n      , { attributes: true\r\n        , childList: true\r\n        , characterData: true\r\n        , attributeOldValue: true\r\n        , characterDataOldValue: true\r\n        , subtree: true\r\n        });\r\n  }\r\n  \r\n  function removeTimestamp(path) {\r\n    var dummyIndex = path.indexOf(\"?\");\r\n    if(dummyIndex > -1) {\r\n      path = path.slice(0, dummyIndex);\r\n    }\r\n    return path;\r\n  }\r\n  function setTimestamp(path) {\r\n    path = removeTimestamp(path);\r\n    path += \"?timestamp=\" + (+new Date());\r\n    return path;\r\n  }\r\n  \r\n  function isAbsolute(url) {\r\n    return url.match(/^https?:\\/\\/|^www\\.|^\\/\\//);\r\n  }\r\n  function linkToEdit(link) {\r\n    return link && !isAbsolute(link) ? link.match(/\\?/) ? link + \"&edit\" : link + \"?edit\" : link;\r\n  }\r\n  \r\n  // Helper.\r\n  function relativeToAbsolute(url) {\r\n    if(isAbsolute(url) || url && url.length && url[0] == \"/\") return url;\r\n    let u =  new URL(location.href);\r\n    if(url[0] === \"#\") {\r\n      return u.pathname + url; \r\n    }\r\n    else {\r\n      return u.pathname.replace(/[^\\/]*$/, \"\") + url;\r\n    }\r\n  }\r\n\r\n  // Saves the Document Object Model, bare version.\r\n  editor.saveDOM = function saveDom() {\r\n    if(document.getElementById(\"notification-menu\") != null) {\r\n      //document.getElementById(\"notification-menu\").innerHTML = `Please wait until previous saving completes.`\r\n      // TODO: Listen and gather subsequent modifications when it is loading\r\n      return;\r\n    }\r\n    editor.ui.model.isSaving = true;\r\n    var newMenu = el(\"menuitem#notification-menu.to-be-selected\", {isghost: true});\r\n    if(document.getElementById('lastaction')) {\r\n      document.getElementById('lastaction').remove();\r\n    }\r\n    if(document.getElementById(\"modify-menu\")) {\r\n      document.getElementById(\"modify-menu\").append(newMenu);\r\n    }\r\n    if(editor.config.thaditor) {\r\n      editor.ui.model.actionsDuringSave = [];\r\n    }\r\n    editor.ui.refresh();\r\n    editor.ui.sendNotification(\"Saving...\");\r\n    const toSend = JSON.stringify(editor.domNodeToNativeValue(document));\r\n    editor.ui._internals.notifyServer({\"question\": editor.ui.model.askQuestions ? \"true\" : \"false\"}, toSend, \"Save\")\r\n  } //editor.saveDOM\r\n  \r\n  \r\n  function isLive() {\r\n    return !(editor.config.path.includes(\"Thaditor/versions/\"));\r\n  }\r\n\r\n  //Version used\r\n  function computeDraftVersion() {\r\n    return isLive() ? \"Live\" : editor.config.path.slice(editor.config.path.lastIndexOf(\"versions/\")+9, editor.config.path.lastIndexOf(\"/\"));\r\n  }\r\n  \r\n  var ifAlreadyRunning = typeof editor == \"object\" && typeof editor.ui === \"object\" && typeof editor.ui.model === \"object\";   \r\n  \r\n  /******************************\r\n        Editor's interface.\r\n  ******************************/\r\n  editor.ui._internals.loadInterface = function() {\r\n    // Insets the modification menu.\r\n    editor.ui._internals.contextMenu = document.querySelector(\"div#context-menu\");\r\n    if(!editor.ui._internals.contextMenu) {\r\n      editor.ui._internals.contextMenu = el(\"div#context-menu\", {contenteditable: \"false\"}, [], {isghost: true});\r\n      document.body.insertBefore(editor.ui._internals.contextMenu, document.body.childNodes[0]);\r\n    }\r\n    editor.ui._internals.modifyMenu = document.querySelector(\"div#modify-menu\");\r\n    if(!editor.ui._internals.modifyMenu) {4\r\n      editor.ui._internals.modifyMenu = el(\"div#modify-menu\", {contenteditable: \"false\"}, [], {isghost:true})\r\n      document.body.insertBefore(editor.ui._internals.modifyMenu, document.body.childNodes[0]);\r\n    }\r\n    prevStyleElem = editor.ui._internals.styleElem;\r\n    editor.ui._internals.styleElem = document.querySelector(\"link#server-elm-style\");\r\n    if(!editor.ui._internals.styleElem) {\r\n      if(prevStyleElem) {\r\n        document.head.append(prevStyleElem);\r\n        editor.ui._internals.styleElem = prevStyleElem;\r\n      } else {\r\n        editor.ui._internals.styleElem = el(\"link#server-elm-style\",{rel:\"stylesheet\", type:\"text/css\",href:\"/server-elm-style.css\",class:\"editor-interface\",isghost:\"true\"});\r\n        document.head.append(editor.ui._internals.styleElem);\r\n      }\r\n    }    \r\n    /*\r\n      Pushes the notification msg to the log & displays it for 3 seconds directly left of the moidfymenu.\r\n      css for notification box is textarea .notif\r\n    */\r\n    editor.ui.sendNotification = function sendNotification(msg, timeout) {\r\n      let modifyMenuDiv = editor.ui._internals.modifyMenu;\r\n      if (!modifyMenuDiv) {\r\n        console.log(\"Notifications havent been set up for use outside of editor, like in the filesystem\");\r\n        console.log (msg);\r\n        return;\r\n      }\r\n      let notifBox = modifyMenuDiv.querySelector(\"#notif-box\");\r\n      if (!notifBox) {\r\n        notifBox = el(\"textarea\", {id:\"notif-box\", class:\"textarea notifs editor-interface\", visibility:true, readonly:true, isghost:true}, [], {value:msg});\r\n        editor.ui._internals.modifyMenu.append(notifBox);\r\n      }\r\n      notifBox.value = msg;\r\n      notifBox.style.display = \"block\";\r\n      notifBox.classList.toggle(\"visible\", true);\r\n      notifBox.style.zIndex = 100;\r\n      notifBox.style.visibility = true;\r\n      editor.ui.model.editor_log.push(msg);\r\n      var logWindow = getEditorInterfaceByTitle(\"Log\");\r\n      if(logWindow) logWindow.refresh();\r\n      setTimeout(function hideNotification() {\r\n        let notifBox = document.getElementById(\"notif-box\");\r\n        if (notifBox) {\r\n          notifBox.classList.toggle(\"visible\", false);\r\n          setTimeout(() => notifBox.remove(), 500);\r\n        }\r\n      }, timeout ? timeout : 3000);\r\n    };\r\n    \r\n    // Sub-interfaces can register functions that will store some information that will be inserted at the same key in the record editor.ui.model.restoredAfterReload.\r\n    editor.ui._internals.saveBetweenReloads = {};\r\n    \r\n    // Same as editor._internals.writeDocument, but tries to preserve as much of the DOM and toolbar state as possible.\r\n    editor.ui._internals.writeDocument = (function() {\r\n      // Save/Load ghost/ignored attributes/nodes for when a page is reloaded, only if elements have an id.\r\n      // Same for some attributes\r\n      function saveGhostAttributes() {\r\n        var ghostModified = document.querySelectorAll(\"[ghost-visible]\");\r\n        var savedGhostAttributes = [];\r\n        for(var i = 0; i < ghostModified.length; i++) {\r\n          var elem = ghostModified[i];\r\n          savedGhostAttributes.push([editor.toTreasureMap(elem),\r\n              \"ghost-visible\", ghostModified[i].getAttribute(\"ghost-visible\")]);\r\n        }\r\n\r\n        function saveAttributes(name) {\r\n          var ghostAttributesModified = document.querySelectorAll(\"[\"+name+\"]\");\r\n          for(var i = 0; i < ghostAttributesModified.length; i++) {\r\n            var elem = ghostAttributesModified[i];\r\n            var toSave = elem.getAttribute(name).split(\" \");\r\n            for(j in toSave) {\r\n              var key = toSave[j];\r\n              savedGhostAttributes.push([editor.toTreasureMap(elem), key, elem.getAttribute(key)]);\r\n            }\r\n          }\r\n        }\r\n        saveAttributes(\"save-ghost-attributes\");\r\n        saveAttributes(\"save-ignored-attributes\");  \r\n      \r\n        var elemsWithAttributesToSave = document.querySelectorAll(\"[save-properties]\");\r\n        var savedProperties = [];\r\n        for(var i = 0; i < elemsWithAttributesToSave.length; i++) {\r\n          var elem = elemsWithAttributesToSave[i];\r\n          var toSave = elem.getAttribute(\"save-properties\").split(\" \");\r\n          for(j in toSave) {\r\n            var key = toSave[j];\r\n            savedProperties.push([editor.toTreasureMap(elem), key, elem[key]])\r\n          }\r\n        }\r\n        var parentsGhostNodes = [];\r\n        var ghostElemsToReinsert = document.querySelectorAll(\"[save-ghost]\");\r\n        for(var i = 0; i < ghostElemsToReinsert.length; i++) {\r\n          var elem = ghostElemsToReinsert[i];\r\n          parentsGhostNodes.push({parent: editor.toTreasureMap(elem.parentNode), node: elem});\r\n        }\r\n        return [savedGhostAttributes, savedProperties, parentsGhostNodes];\r\n      }\r\n      function applyGhostAttributes(attrs) {\r\n        var [savedGhostAttributes, savedProperties, parentsGhostNodes] = attrs;\r\n        for(var i in savedGhostAttributes) {\r\n          var [data, key, attr] = savedGhostAttributes[i];\r\n          var elem = editor.fromTreasureMap(data);\r\n          if(elem != null) {\r\n            elem.setAttribute(key, attr);\r\n          }\r\n        }\r\n        for(var i in savedProperties) {\r\n          var [data, key, value] = savedProperties[i];\r\n          var elem = editor.fromTreasureMap(id);\r\n          if(elem != null) {\r\n            elem[key] = value;\r\n          }\r\n        }\r\n        for(var i in parentsGhostNodes) {\r\n          var {parent: data, node: elem} = parentsGhostNodes[i];\r\n          var parent = editor.fromTreasureMap(data);\r\n          if(parent != null) {\r\n            if(!elem.getAttribute(\"id\") || !document.getElementById(elem.getAttribute(\"id\"))) {\r\n              parent.appendChild(elem);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      function saveBeforeReloadingToolbar() {\r\n        editor.ui.model.restoredAfterReload = {};\r\n        for(let k in editor.ui._internals.saveBetweenReloads) {\r\n          editor.ui.model.restoredAfterReload[k] = editor.ui._internals.saveBetweenReloads[k]();\r\n        }\r\n        console.log(\"saved before reloading toolbar\", editor.ui.model.restoredAfterReload);\r\n      }\r\n      \r\n      return function writeDocument(newContent) {\r\n        let saved = saveGhostAttributes();\r\n        saveBeforeReloadingToolbar();\r\n        if(editor.ui.model.caretPosition) {\r\n          editor.ui.model.caretPosition = dataToRecoverCaretPosition(editor.ui.model.caretPosition);\r\n        }\r\n        if(editor.ui.model.selectionRange) {\r\n          editor.ui.model.selectionRange = dataToRecoverSelectionRange(editor.ui.model.selectionRange);\r\n        }\r\n        if(editor.ui.model.clickedElem) {\r\n          editor.ui.model.clickedElem = editor.toTreasureMap(editor.ui.model.clickedElem);\r\n        }\r\n        let scrollX = window.scrollX;\r\n        let scrollY = window.scrollY;\r\n        editor._internals.writeDocument(newContent);\r\n        applyGhostAttributes(saved);\r\n        setTimeout(() => window.scroll(scrollX, scrollY), 10);\r\n      };\r\n    })(); // editor.ui._internals.writeDocument \r\n    \r\n      // Handle a rewrite message from the worker\r\n    editor.ui._internals.handleRewriteMessage = function(e) {\r\n      //Rewrite the document, restoring some of the UI afterwards.\r\n      if(editor.config.fast) {\r\n        // If we are in fast mode, then the page is used only for comparing with back-propagation.\r\n        // The actual page is loaded through a query to the server.\r\n        console.log(\"Here we will call the proxy to fetch the current URL \" + String(location));\r\n        let xhr = new XMLHttpRequest();\r\n        xhr.onreadystatechange = function() {\r\n            if (xhr.readyState == 4) {\r\n                // The request is done; did it work?\r\n                if (xhr.status == 200) {\r\n                    // Yes, use `xhr.responseText` to resolve the promise\r\n                    editor._internals.writeDocument(xhr.responseText); // At least keep the scroll\r\n                    //editor.ui._internals.handleRewriteMessageWithText(e, xhr.responseText);\r\n                } else {\r\n                    // No, reject the promise\r\n                    console.log(\"Error while reading page \"+String(location) + \"\\n Fallback on Thaditor.\");\r\n                    editor.ui._internals.handleRewriteMessageWithText(e, e.data.text);\r\n                }\r\n             }\r\n        };\r\n        xhr.open(\"GET\", String(location));\r\n        xhr.send();\r\n      } else {\r\n        editor.ui._internals.handleRewriteMessageWithText(e, e.data.text);\r\n      }\r\n    }\r\n    \r\n    editor.ui._internals.handleRewriteMessageWithText = function(e, text) {\r\n      let editor_model = editor.ui.model;\r\n      editor_model.isSaving = false;\r\n      editor.ui._internals.writeDocument(text);\r\n      \r\n      var newLocalURL = e.data.newLocalURL;\r\n      var newQueryStr = e.data.newQueryStr;\r\n      var ambiguityKey = e.data.ambiguityKey;\r\n      var ambiguityNumber = e.data.ambiguityNumber;\r\n      var ambiguitySelected = e.data.ambiguitySelected;\r\n      var ambiguityEnd = e.data.ambiguityEnd;\r\n      var ambiguitySummaries = e.data.ambiguitySummaries;\r\n      var opSummaryEncoded = e.data.opSummaryEncoded;\r\n      var replaceState = e.data.customRequestHeaders && e.data.customRequestHeaders.replaceState == \"true\";\r\n      if(ambiguityKey !== null && typeof ambiguityKey != \"undefined\" &&\r\n         ambiguityNumber !== null && typeof ambiguityNumber != \"undefined\" &&\r\n         ambiguitySelected !== null && typeof ambiguitySelected != \"undefined\") {\r\n        var n = JSON.parse(ambiguityNumber);\r\n        console.log (\"editor.ui._internals.handleRewriteMessage ambiguity\");\r\n        var selected = JSON.parse(ambiguitySelected);\r\n        var summaries = JSON.parse(ambiguitySummaries);\r\n        \r\n        var disambiguationMenuContent = [];\r\n        disambiguationMenuContent.push(el(\"span#ambiguity-id\", {v: ambiguityKey}, \"Choose the update you prefer, and click the save button:\"));\r\n        // Find the common path of all files so that we don't need to repeat its name or path.\r\n        var fileOf = x => x.replace(/^(.*): *\\n[\\s\\S]*$/, \"$1\")\r\n        var commonPrefix = fileOf(summaries[1]);\r\n        for(var i = 1; i <= n; i++) {\r\n          while(!fileOf(summaries[i - 1]).startsWith(commonPrefix)) {\r\n            let n = commonPrefix.replace(/^(.*)(?:\\/|\\\\).*$/, \"$1\");\r\n            commonPrefix = n === commonPrefix ? \"\" : n;\r\n          }\r\n        }\r\n        if(commonPrefix) {\r\n          disambiguationMenuContent.push(el(\"span#ambiguity-prefix\", {}, commonPrefix + \":\"));\r\n        }\r\n        for(var i = 1; i <= n; i++) {\r\n          var summary = summaries[i-1].substring(commonPrefix.length).\r\n                replace(/\"/g,'&quot;').\r\n                replace(/</g, \"&lt;\").\r\n                replace(/---\\)|\\+\\+\\+\\)/g, \"</span>\").\r\n                replace(/\\(---/g, \"<span class='remove'>\").\r\n                replace(/\\(\\+\\+\\+/g, \"<span class='add'>\").\r\n                replace(/(\\nL\\d+C\\d+:)(.*)/, \"$1<span class='codepreview'>$2</span>\");\r\n          disambiguationMenuContent.push(el(\"span.solution\" + (i == selected ? \".selected\" : \"\") + (i == n && ambiguityEnd != 'true' ? '.notfinal' : ''), {\r\n          title: i == selected ? \"Currently displaying this solution\" : \"Select this solution\" + (i == n && ambiguityEnd != 'true' ? \" (compute further solutions after if any)\" : \"\"), onclick: i == selected ? `` : `this.classList.add('to-be-selected'); editor.ambiguity.select('${ambiguityKey}', ${i})`}, \"\", {innerHTML: \"#\" + i + \" \" + summary}));\r\n        }\r\n        disambiguationMenuContent.push(el(\"button#ambiguityCancel.action-button\", {title: \"Revert to the original version\", onclick: `editor.ambiguity.cancel(\"${ambiguityKey}\", ${selected})`}, \"Cancel\"));\r\n        editor_model.disambiguationMenu = el(\"div.disambiguationMenu\", {}, disambiguationMenuContent);\r\n        editor_model.disambiguationMenu.ambiguityKey = ambiguityKey;\r\n        editor_model.disambiguationMenu.selected = selected;\r\n        editor_model.clickedElem = undefined;\r\n        editor_model.displayClickedElemAsMainElem = true;\r\n        editor_model.notextselection = false;\r\n        editor_model.caretPosition = undefined;\r\n        editor_model.link = undefined;\r\n        var advancedBlock = getEditorInterfaceByTitle(\"Advanced\");\r\n        if(advancedBlock) advancedBlock.minimized = false;\r\n        editor_model.visible = true;\r\n        //editor_model.displaySource: false, // Keep source opened or closed\r\n        // TODO: Disable click or change in DOM until ambiguity is resolved.\r\n      } else { //no ambiguity\r\n        if(editor_model.disambiguationMenu && editor_model.disambiguationMenu.replayActionsAfterSave) {\r\n          console.log(\"disambiguationMenu was there. replaying actions\");\r\n          editor_model.disambiguationMenu.replayActionsAfterSave(\"Modifications applied\");\r\n        } else {\r\n          console.log(\"disambiguationMenu is not there.\");\r\n        }\r\n        editor_model.disambiguationMenu = undefined;\r\n        if(opSummaryEncoded) {\r\n          var opSummary = decodeURI(opSummaryEncoded);\r\n          opSummary =\r\n            opSummary.\r\n            replace(/</g, \"&lt;\").\r\n            replace(/---\\)/g, \"</span>\").\r\n            replace(/\\(---/g, \"<span class='remove'>\").\r\n            replace(/\\+\\+\\+\\)/g, \"</span>\").\r\n            replace(/\\(\\+\\+\\+/g, \"<span class='add'>\");\r\n          editor_model.editor_log.push(opSummary);\r\n          // editor.ui.sendNotification(opSummary);\r\n        }\r\n      } // /noambiguity\r\n      var strQuery = \"\";\r\n      if(newQueryStr != null) { //newQueryStr = undefined ==> (newQueryStr !== null) ==> false;\r\n        var newQuery = JSON.parse(newQueryStr);\r\n        for(var i = 0; i < newQuery.length; i++) {\r\n          var {_1: key, _2: value} = newQuery[i];\r\n          strQuery = strQuery + (i == 0 ? \"?\" : \"&\") + key + (value === \"\" && key == \"edit\" ? \"\" : \"=\" + value)\r\n        } \r\n      }\r\n      if(newLocalURL) { // Overrides query parameters\r\n        window.history[replaceState ? \"replaceState\" : \"pushState\"]({localURL: newLocalURL}, \"Nav. to \" + newLocalURL, newLocalURL);\r\n      } else if(strQuery) {\r\n        window.history.replaceState({}, \"Current page\", strQuery);\r\n      }\r\n      // editor.ui.refresh(); // The interface will be automatically refreshed after loading.\r\n    }; // editor.ui._internals.handleRewriteMessage\r\n    \r\n    // Used only by the Editor webserver (editor.config.thaditor == false)\r\n    editor.ui._internals.handleServerResponse = xmlhttp => function () {\r\n        if (xmlhttp.readyState == XMLHttpRequest.DONE) {\r\n          editor.ui._internals.handleRewriteMessage({\r\n            data: {\r\n              newLocalURL: xmlhttp.getResponseHeader(\"New-Local-URL\"),\r\n              newQueryStr: xmlhttp.getResponseHeader(\"New-Query\"),\r\n              ambiguityKey: xmlhttp.getResponseHeader(\"Ambiguity-Key\"),\r\n              ambiguityNumber: xmlhttp.getResponseHeader(\"Ambiguity-Number\"),\r\n              ambiguitySelected: xmlhttp.getResponseHeader(\"Ambiguity-Selected\"),\r\n              ambiguityEnd: xmlhttp.getResponseHeader(\"Ambiguity-End\"),\r\n              ambiguitySummaries: xmlhttp.getResponseHeader(\"Ambiguity-Summaries\"),\r\n              opSummaryEncoded: xmlhttp.getResponseHeader(\"Operations-Summary\"),\r\n              customRequestHeaders: xmlhttp.customRequestHeaders,\r\n              text: xmlhttp.responseText\r\n            }\r\n          })\r\n        } //xhr.onreadystatechange == done\r\n    }; //editor.ui._internals.handleServerResponse\r\n    \r\n    editor.ui._internals.handleSendRequestFinish = function(data) {\r\n      console.log(\"editor.ui._internals.handleSendRequestFinish\", data);\r\n      /*\r\n        We want to undo everything in the undo stack that has been done since the save began.\r\n        In the process of vanilla undoing this (using mark's function), the items will be\r\n        pushed onto the redoStack in the normal way, s.t. we can redo them in a moment.\r\n        Once we're at the state we were at when we began to save, we re-write the page\r\n        with the confirmed content that the worker gave us.\r\n        Once the confirmed content has been rewritten, we have undo/redo stacks that point,\r\n        as the undo/redo stacks are an array of array of MutationRecords, all of whose target\r\n        has just been erased and replaced with a new object. \r\n        So we need to convert the old UR stacks to be pointing to the right objects.\r\n        We solve this in the undo()/redo() functions, by checking to see if the object\r\n        pointed to in the mutationrecord is still connected to the active DOM. if not,\r\n        we use the inactive node to record the path up the tree, and search for the\r\n        corresponding node in the newly active tree, replacing the MR.target with the active one.\r\n        Once we have the UR stacks set up, we just need to vanilla undo/redo to get back to\r\n        the state pre-update & post-save.\r\n      */\r\n      // TODO: In case of ambiguity, only replay undo/redo after ambiguity has been resolved.\r\n      const ads = editor.ui.model.actionsDuringSave;\r\n      const adsLen = editor.ui.model.actionsDuringSave.length;\r\n      ads.forEach((action) => {\r\n        if (action == \"undo\") {\r\n          editor.ui.undo();\r\n        } else if (action == \"redo\") {\r\n          editor.ui.redo();\r\n        } else {\r\n          throw new Error(\"Unidentified action in restoring post-save state post-save\");\r\n        }\r\n      });\r\n      \r\n      editor.ui.model.outputObserver.disconnect();\r\n      editor.ui._internals.handleRewriteMessage({data: data});\r\n      // Now the page is reloaded, but the scripts defining Editor have not loaded yet.\r\n      setTimeout(function() {\r\n        var replayActionsAfterSave = msg => function(msgOverride) {\r\n          console.log(\"replaying actions after save\");\r\n          const newAds = editor.ui.model.actionsDuringSave;\r\n          const newAdsLen = newAds.length;\r\n          for (let i = 0; i < adsLen; i++) {\r\n            if (newAds[i] == \"undo\") {\r\n              editor.ui.undo();\r\n            } else if (newAds[i] == \"redo\") {\r\n              editor.ui.redo();\r\n            } else {\r\n              throw new Error(\"unidentified action in actionsduringsave\");\r\n            }\r\n          }\r\n          if(newAdsLen) {\r\n            editor.ui.refresh();\r\n          }\r\n          if(msg) {\r\n            setTimeout(function saveCompleted(count) {\r\n               if(editor.ui.sendNotification) {\r\n                 editor.ui.sendNotification(newAdsLen === 0 || !msgOverride ? msg : msgOverride);\r\n               } else {\r\n                 setTimeout(() => saveCompleted((count || 0) + 1), (count||0)*10);\r\n               }\r\n            }, 0);\r\n          }\r\n        }\r\n        let what = data.what ? data.what + \" completed.\" : undefined;\r\n        if(!data.isAmbiguous || !editor.ui.model.disambiguationMenu) {\r\n          replayActionsAfterSave(what)();\r\n        } else {\r\n          editor.ui.model.disambiguationMenu.replayActionsAfterSave = replayActionsAfterSave(what);\r\n        }\r\n      }, 10);\r\n    }; // editor.ui._internals.handleSendRequestFinish\r\n    \r\n    // The \"what\" is so that we can show a notification when this is done\r\n    editor.ui._internals.notifyServer = function(requestHeaders, toSend, what) {\r\n      if(editor.config.thaditor) {\r\n        thaditor.do( {action:\"sendRequest\",\r\n                    toSend: toSend || \"{\\\"a\\\":2}\",\r\n                    aq:editor.ui.model.askQuestions,\r\n                    loc: location.pathname + location.search,\r\n                    requestHeaders: requestHeaders,\r\n                    what: what}\r\n        ).then(editor.ui._internals.handleSendRequestFinish);\r\n      } else {\r\n        var xmlhttp = new XMLHttpRequest();\r\n        xmlhttp.onreadystatechange = editor.ui._internals.handleServerResponse(xmlhttp);\r\n        xmlhttp.open(\"POST\", location.pathname + location.search);\r\n        xmlhttp.setRequestHeader(\"Content-Type\", \"application/json\");\r\n        if(requestHeaders) {\r\n          for(let k in requestHeaders) {\r\n            xmlhttp.setRequestHeader(k, requestHeaders[k]);\r\n          }\r\n        }\r\n        xmlhttp.customRequestHeaders = requestHeaders;\r\n        xmlhttp.send(toSend || \"{\\\"a\\\":2}\");\r\n      }\r\n    }; // editor.ui._internals.notifyServer\r\n    \r\n    // Recomputes the page and display it entirely.\r\n    editor.reload = function reloadPage() {\r\n      editor.ui.sendNotification(\"Reloading...\");\r\n      editor.ui._internals.notifyServer({reload: \"true\"}, undefined, \"Reload\");\r\n    }; // editor.reload\r\n    \r\n    editor.ui.reload = editor.reload;\r\n    \r\n    // Computes the file at the given URL and display it with Editor.\r\n    // If replaceState it true, the back button will not work.\r\n    editor.navigateTo = function navigateTo(url, replaceState) {\r\n      url = relativeToAbsolute(url);\r\n      editor.ui.sendNotification(\"Loading...\");\r\n      editor.ui._internals.notifyServer({reload: \"true\", url: url, replaceState: \"\"+replaceState}, undefined, \"Page load\");\r\n    }; // editor.navigateTo\r\n    \r\n    editor.ui.navigateTo = editor.navigateTo;\r\n    \r\n    // API to deal with ambiguity\r\n    editor.ambiguity = {};\r\n    editor.ui.ambiguity = editor.ambiguity;\r\n    \r\n    // Select and display the num-th alternative of the ambiguity indexed by key.\r\n    editor.ambiguity.select = function(key, num) {\r\n      editor.ui._internals.notifyServer({\"ambiguity-key\": key, \"select-ambiguity\": JSON.stringify(num), \"question\": \"true\"});\r\n    }; // editor.ambiguity.select\r\n    \r\n    // Select the ambiguity result If the page displayed after an ambiguity is detected.\r\n    // For Thaditor, this changes nothing because files are already written, it only clears the ambiguity data.\r\n    editor.ambiguity.accept = function(key, num) {\r\n      editor.ui._internals.notifyServer({\"ambiguity-key\": key, \"accept-ambiguity\": JSON.stringify(num)});\r\n    }; // editor.ambiguity.accept\r\n    \r\n    // Cancels the entire change that presented an ambiguity, indexed by key.\r\n    editor.ambiguity.cancel = function(key, num) {\r\n      editor.ui._internals.notifyServer({\"ambiguity-key\": key, \"cancel-ambiguity\": JSON.stringify(num)});\r\n    }; // editor.ambiguity.cancel\r\n    \r\n    // Saves the CSS and stores undo/redo before saving the DOM.\r\n    editor.ui.save = function save() {\r\n      if (editor.ui.model.isSaving) {\r\n        editor.ui.sendNotification(\"Can't save while save is being undertaken\");\r\n      } else {\r\n        //temp place to put CSS file loading stuff (may well be moved later)\r\n        let allPageLinks = document.querySelectorAll(\"link[rel=stylesheet]\");\r\n        (async () => {\r\n          for(let e = 0; e < allPageLinks.length; e++) {\r\n            let linkNode = allPageLinks[e];\r\n            if(!editor.isGhostNode(linkNode) && linkNode.getAttribute(\"ghost-href\")) {\r\n              let linkNodeTmpHref = linkNode.getAttribute(\"href\");\r\n              let linkNodeOriginalHref = linkNode.getAttribute(\"ghost-href\");\r\n              let trueTempPath = removeTimestamp(linkNodeTmpHref); // This one is absolute normally\r\n              let originalAbsPath = relativeToAbsolute(removeTimestamp(linkNodeOriginalHref));\r\n              let newValue = (await editor.getServer(\"read\", trueTempPath)) || \"\";\r\n              await editor.postServer(\"write\", originalAbsPath, newValue);\r\n              linkNode.cachedContent = newValue;\r\n              linkNode.tmpCachedContent = newValue;\r\n              // Since we delete the temporary file, we cannot revert to the temporary href.\r\n              // Problem: it's not possible to undo small changes.\r\n              // Worse: The deletion of the tmp css file will make it impossible to undo to states before of before this saving.\r\n              // Ghost attributes are not restored when doing undo.\r\n              editor_stopWatching();\r\n              linkNode.setAttribute(\"href\", setTimestamp(linkNodeOriginalHref));\r\n              linkNode.removeAttribute(\"ghost-href\");\r\n              editor_resumeWatching();\r\n              await editor.postServer(\"unlink\", trueTempPath);\r\n            }                 \r\n          }\r\n          editor.ui.model.undosBeforeSave = editor.ui.model.undoStack.length;\r\n          if(!this || typeof this != \"object\" || typeof this.classList == \"undefined\" || !this.classList.contains(\"disabled\")) {\r\n            editor.saveDOM();\r\n          }\r\n        })();\r\n      } // if editor.ui.model.isSaving\r\n    };  // editor.ui.save\r\n    \r\n    // Store the mutation in the undo buffer.\r\n    // Gather undos if they happen within 100ms;\r\n    editor.ui._internals.makeMutationUndoable = function makeMutationUndoable(m) {\r\n      var editor_model = editor.ui.model;\r\n      var time = +new Date();\r\n      //for childLists, add mutable next/previous sibling properties\r\n      if(m.type === \"childList\") {\r\n          /*Object.defineProperty(m, 'rePrevSib', {value: m.previousSibling /*&& !(m.previousSibling.nodeType == 1)) ? \r\n                                                m.previousSibling.previousElementSibling : m.previousSibling, \r\n                                                writable: true});\r\n          Object.defineProperty(m, 'reNextSib', {value: m.nextSibling /*&& !(m.nextSibling.nodeType == 1)) ? \r\n                                                m.nextSibling.nextElementSibling : m.nextSibling,\r\n                                                writable: true});*/\r\n      }\r\n        //for attributes/characterData, add alternative mutable oldValue\r\n      else {\r\n        Object.defineProperty(m, 'URValue', {value: m.oldValue, writable: true});\r\n      }\r\n      //Object.defineProperty(m, 'timestamp', {value: time})\r\n      m.timestamp = time;\r\n      //check if the last element on currently on the stack is operating on the same \"information\", i.e. oldValue or nodelists\r\n      //and should be combined together when undoing/redoing\r\n      \r\n      let lastUndo = editor_model.undoStack[editor_model.undoStack.length-1];\r\n      //makes single actions that are recorded as multiple mutations a single action\r\n      //true here ==> mutation is separate action\r\n      if(!lastUndo || (lastUndo[0].timestamp < (time - 100))) {  \r\n        if (editor_model.isSaving) {\r\n          editor_model.actionsDuringSave.unshift(\"undo\");\r\n        }\r\n        editor_model.undoStack.push([m]);\r\n        editor_model.redoStack = [];\r\n      }\r\n      //false here ==> mutation is same action as last mutation\r\n      //makes no sense for somethign that is first added then removed for those actions to be grouped together \r\n      //i.e. if i add text then get rid of it, it makes no sense for undo to revert the removal and addition direclty in sequence\r\n      else {\r\n        lastUndo = editor_model.undoStack.pop();\r\n        lastUndo.push(m);\r\n        editor_model.undoStack.push(lastUndo);\r\n      }     \r\n    }; //editor.ui._internals.makeMutationUndoable\r\n    \r\n    function isDescendantOf(a, b) {\r\n      while(a && a != b) {\r\n        a = a.parentElement;\r\n      }\r\n      return a == b;\r\n    }\r\n    \r\n    editor.ui._internals.handleMutations = function handleMutations(mutations, observer) {\r\n      var onlyGhosts = true;\r\n      for(var i = 0; i < mutations.length; i++) {\r\n        // A mutation is a ghost if either\r\n        // -- The attribute starts with 'ghost-'\r\n        // -- It is the insertion of a node whose tag is \"ghost\" or that contains an attribute \"isghost=true\"\r\n        // -- It is the modification of a node or an attribute inside a ghost node.\r\n        /*  \r\n         * Add mutations to undo list if they are not ghosts and if they are really doing something.\r\n         */\r\n        let mutation = mutations[i];\r\n        if(editor.hasGhostAncestor(mutation.target)) {\r\n          continue;\r\n        }\r\n        if(mutation.type == \"attributes\") {\r\n          var isSpecificGhostAttributeKey = editor.isSpecificGhostAttributeKeyFromNode(mutation.target);\r\n          var isIgnoredAttributeKey = editor.isIgnoredAttributeKeyFromNode(mutation.target);\r\n          if(editor.isGhostAttributeKey(mutation.attributeName) || isSpecificGhostAttributeKey(mutation.attributeName) ||\r\n             mutation.target.getAttribute(mutation.attributeName) === mutation.oldValue ||\r\n             isIgnoredAttributeKey(mutation.attributeName)) {\r\n          } else {\r\n            onlyGhosts = false;\r\n            editor.ui._internals.makeMutationUndoable(mutation);\r\n            // Please do not comment out this line until we get proper clever save.\r\n            if(!editor.ui.model.userIsModifying) {\r\n              console.log(\"Attribute is not ghost so the change will be saved\", mutation);\r\n              console.log(\"TIP: Use this script if you want to mark it as ghost:\");\r\n              let sel = getShortestUniqueSelector(mutation.target);\r\n              if(typeof mutation.oldValue === \"undefined\") {\r\n                console.log(\"editor.ghostAttrs.push(n => editor.matches(n, '\"+sel+\"') ? ['\"+mutation.attributeName+\"'] : []);\")\r\n              } else {\r\n                console.log(\"editor.ignoredAttrs.push(n => editor.matches(n, '\"+sel+\"') ? ['\"+mutation.attributeName+\"'] : []);\")\r\n              }\r\n            }\r\n          }\r\n        } else if(mutation.type == \"childList\") {\r\n          if(!editor.areChildrenGhosts(mutation.target)) {\r\n            for(var j = 0; j < mutation.addedNodes.length; j++) {\r\n              if(!editor.hasGhostAncestor(mutation.addedNodes[j]) && !editor.hasIgnoringAncestor(mutation.addedNodes[j])) {\r\n                onlyGhosts = false;\r\n                editor.ui._internals.makeMutationUndoable(mutation);\r\n                if(!editor.ui.model.userIsModifying) {\r\n                  // Please do not comment out this line until we get proper clever save.\r\n                  console.log(`Added node ${j} does not have a ghost ancestor`, mutation);\r\n                  console.log(\"TIP: Ignore node and siblings with this script:\");\r\n                  let sel = getShortestUniqueSelector(mutation.target);\r\n                  console.log(\"editor.ignoredChildNodes.push(editor.matches('\"+sel+\"'));\");\r\n                  if(mutation.addedNodes[j].nodeType === 1) {\r\n                    console.log(\"TIP: Mark this element as ghost:\");\r\n                    sel = getShortestUniqueSelector(mutation.addedNodes[j]);\r\n                    console.log(\"editor.ghostNodes.push(editor.matches('\"+sel+\"'));\");\r\n                  }\r\n                }\r\n              }\r\n            }\r\n            for(var j = 0; j < mutation.removedNodes.length; j++) {\r\n              if(!editor.isGhostNode(mutation.removedNodes[j]) && !editor.isIgnoringChildNodes(mutation.target) && !editor.hasIgnoringAncestor(mutation.target)) {\r\n                onlyGhosts = false;\r\n                editor.ui._internals.makeMutationUndoable(mutation);\r\n                if(!editor.ui.model.userIsModifying) {\r\n                  // Please do not comment out this line until we get proper clever save.\r\n                  console.log(`Removed node ${j} was not a ghost`, mutation);\r\n                  console.log(\"TIP: Mark this element as ghost:\");\r\n                  let sel = getShortestUniqueSelector(mutation.target);\r\n                  console.log(\"editor.ignoredChildNodes.push(editor.matches('\"+sel+\"'));\");\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } else if(mutation.type === \"characterData\") {\r\n          onlyGhosts = false;\r\n          editor.ui._internals.makeMutationUndoable(mutation);\r\n          let textOfSelectedElement = editor.ui.model.clickedElem && isDescendantOf(mutation.target, editor.ui.model.clickedElem);\r\n          if(!editor.ui.model.userIsModifying && !textOfSelectedElement) {\r\n            // Please do not comment out this line until we get proper clever save.\r\n            console.log(\"Text modified not by user\", mutation);\r\n          }\r\n        } else {\r\n          onlyGhosts = false;\r\n          editor.ui._internals.makeMutationUndoable(mutation);\r\n          if(!editor.ui.model.userIsModifying) {\r\n            // Please do not comment out this line until we get proper clever save.\r\n            console.log(\"mutations other than attributes, childList and characterData are not ghosts\", mutation);\r\n          }\r\n        }\r\n      }\r\n      if(onlyGhosts) {\r\n        return;\r\n      } // Send in post the new HTML along with the URL\r\n      // Set undo/redo state\r\n      editor.ui.syncUndoRedoButtons();\r\n      \r\n      if(editor.ui.model.autosave && !editor.ui.model.disambiguationMenu) {\r\n        if(typeof editor._internals.autosavetimer !== \"undefined\") {\r\n          clearTimeout(editor._internals.autosavetimer);\r\n        }\r\n        editor._internals.autosavetimer = setTimeout(function() {\r\n          editor._internals.autosavetimer = undefined;\r\n          editor.ui.save();\r\n        }, typeof editor.config.editdelay == \"number\" ? editor.config.editdelay : 1000);\r\n      } else {\r\n        var saveButtons = document.querySelectorAll(\".saveButton\");\r\n        // TODO: Can we regenerate the whole interface for consistency?\r\n        for(let sb of saveButtons) {\r\n          sb.classList.toggle(\"disabled\", false);\r\n        }\r\n        return;\r\n      }\r\n    } //editor.ui._internals.handleMutations\r\n    \r\n    //debugging function for printing both teh undo and redo stacks.\r\n    editor.ui._internals.printstacks = function printstacks() {\r\n      console.log(\"-----------------------------\");\r\n      let i, j;\r\n      console.log(\"UNDO STACK:\");\r\n      for(i = 0; i < editor.ui.model.undoStack.length; i++) {\r\n        console.log(i + \".\");\r\n        for(j = 0; j < editor.ui.model.undoStack[i].length; j++) {\r\n          console.log(editor.ui.model.undoStack[i][j]);\r\n        }\r\n      }\r\n      console.log(\"REDO STACK:\");\r\n      for(i = 0; i < editor.ui.model.redoStack.length; i++) {\r\n        console.log(i + \".\"); \r\n        for(j = 0; j < editor.ui.model.redoStack[i].length; j++) {\r\n          console.log(editor.ui.model.redoStack[i][j]);\r\n        }\r\n      }\r\n      console.log(\"-----------------------------\");\r\n    }; // editor.ui._internals.printstacks\r\n    \r\n    // Returns true if Editor's undo feature should be enabled.\r\n    editor.ui.canUndo = function canUndo() {\r\n      return editor.ui.model.undoStack.length > 0;\r\n    }; // editor.ui.canUndo\r\n\r\n    //undo function: handles undo feature\r\n    editor.ui.undo = function undo() {\r\n      let undoElem = editor.ui.model.undoStack.pop();\r\n      //need to check if undoStack is empty s.t. we can set the \"savability\" of the document accurately\r\n      if(undoElem == undefined) {\r\n        return 0;\r\n      }\r\n      (async () => {\r\n      //TODO prevent pressing the undo button while save underway while letting Editor use the undo function. (just not the user);\r\n      //need to disconnect the MutationObserver such that our undo does not get recorded as a mutation\r\n      editor_stopWatching();\r\n      const quicker = node => recoverElementFromData(dataToRecoverElement(node));\r\n      let k;\r\n      for(k = undoElem.length - 1; k >= 0; k--) {\r\n        let mutType = undoElem[k].type; \r\n        let qk = quicker(undoElem[k].target);\r\n        \r\n        let target = (undoElem[k].target.isConnected ? \r\n                        undoElem[k].target :\r\n                        (qk == undefined ? undoElem[k].target : qk));\r\n        //in each case, we reverse the change, setting the URValue/oldValue as the current value\r\n        //at the target, and replacing the URValue/oldValue with the current value present in target\r\n        if(mutType === \"attributes\") {\r\n          let cur_attr = target.getAttribute(undoElem[k].attributeName);\r\n          if(undoElem[k].URValue === null) {\r\n            target.removeAttribute(undoElem[k].attributeName); \r\n          }       \r\n          else { \r\n            target.setAttribute(undoElem[k].attributeName, undoElem[k].URValue);\r\n          }\r\n          undoElem[k].URValue = cur_attr; \r\n        }\r\n        else if(mutType === \"characterData\") {\r\n          const cur_data = target.textContent;\r\n          target.textContent = undoElem[k].URValue;\r\n          undoElem[k].URValue = cur_data;\r\n          //undoElem[k].isConnected ? undoElem[k].URValue : quicker(undoElem[k]).URValue = cur_data;\r\n        }\r\n        else if(mutType === \"linkHrefCSS\") { // There should be only one such even\r\n          var keepUndo = undoElem[k];\r\n          await assignTmpCss(target, keepUndo.oldValue, true);\r\n        }\r\n        else {\r\n          let uRemNodes = undoElem[k].removedNodes;\r\n          let uAddNodes = undoElem[k].addedNodes;\r\n          //readding the removed nodes\r\n          // -in this case, we loop through the childNodes and add them in the appropriate spot \r\n          // or remove them \r\n          // NOTE: we only change the nextSib property of the undoElem, and alternate between adding/removing from the \r\n          //       addedNodes & removedNodes lists depending on whether we are undoing (in which case we will add)\r\n          // NOTE: Since there is only one nextSibling/prevSibling property, and based off the fact that MutationObserver\r\n          //       should take into account every mutation, we should only have elements in one of uRemNodes and uAddNodes\r\n          //       at once.\r\n          let kidNodes = target.childNodes;\r\n          let i, j;\r\n          if(uRemNodes.length) {\r\n            if(kidNodes.length === 0) {            \r\n              if(undoElem[k].nextSibling == null && undoElem[k].previousSibling == null) {\r\n                for(i = 0; i < uRemNodes.length; i++) { \r\n                  /*if(editor.hasGhostAncestor(uRemNodes.item(i))) {\r\n                    continue;\r\n                  }*/\r\n                  target.appendChild(uRemNodes.item(i)); \r\n                }\r\n              }\r\n            }\r\n            // The next sibling of the removed node\r\n            let ns = undoElem[k].nextSibling && undoElem[k].nextSibling.isConnected ? undoElem[k].nextSibling : quicker(undoElem[k].nextSibling);\r\n            // The previous sibling of the removed node\r\n            let ps = undoElem[k].previousSibling && undoElem[k].previousSibling.isConnected ? undoElem[k].previousSibling : quicker(undoElem[k].previousSibling);\r\n            // Let's find these siblings to re-add the node.\r\n            for(j = 0; j < kidNodes.length; j++) {  \r\n              let knode = kidNodes.item(j);\r\n              let knode_may = quicker(knode);\r\n              //if(kidNodes.item(j) === undoElem[k].nextSibling && kidNodes.item(j).previousSibling === undoElem[k].previousSibling) {\r\n              if ((knode == ns || knode_may == ns || ns == undefined) &&\r\n                  (knode.previousSibling == ps || knode_may.previousSibling == ps || ps == undefined || ((knode == ps) && !(ns == ps)))){\r\n                for(i = 0; i < uRemNodes.length; i++) { \r\n                  /*if(editor.hasGhostAncestor(uRemNodes.item(i))) {\r\n                    continue;\r\n                  }*/\r\n                  let uremnode = uRemNodes.item(i);\r\n                  let urn = quicker(uremnode);\r\n                  //debugger;\r\n                  if (ns) {\r\n                    target.insertBefore(urn == undefined ? uremnode : urn, knode.isConnected ? knode : knode_may); \r\n                  }\r\n                  else {\r\n                    target.appendChild(urn == undefined ? uremnode : urn, knode.isConnected ? knode : knode_may);\r\n                  }\r\n                }\r\n                break;\r\n              }\r\n            }\r\n          }\r\n          for(i = 0; i < uAddNodes.length; i++) {\r\n            /*if(editor.hasGhostAncestor(uAddNodes.item(i))) {\r\n              continue;\r\n            }*/\r\n            if(!target.contains(uAddNodes.item(i))) {\r\n              console.log(\"The item you are trying to undo doesn't exist in the parent node.\");\r\n            }\r\n            else {\r\n              target.removeChild(uAddNodes.item(i));\r\n            }\r\n          }\r\n        }\r\n      } //mutation looper\r\n      editor.ui.model.redoStack.push(undoElem);\r\n      if (editor.ui.model.isSaving) {\r\n        editor.ui.model.actionsDuringSave.unshift(\"redo\");\r\n      }\r\n      //TODO make sure save button access is accurate (i.e. we should ony be able to save if there are thigns to undo)\r\n      //turn MutationObserver back on\r\n      editor_resumeWatching();\r\n      editor.ui.refresh();\r\n      //editor.ui._internals.printstacks();\r\n      })();\r\n      return 1;\r\n    }; //editor.ui.undo\r\n\r\n    // Returns true if Editor's redo feature should be enabled.\r\n    editor.ui.canRedo = function canRedo() {\r\n      return editor.ui.model.redoStack.length > 0;\r\n    }; // editor.ui.canRedo\r\n    \r\n    // Redo an undone mutation array.\r\n    editor.ui.redo = function redo() {\r\n      let redoElem = editor.ui.model.redoStack.pop();\r\n      if(redoElem === undefined) {\r\n        return 0;\r\n      }\r\n      (async () => {\r\n      editor_stopWatching();\r\n      const quicker = node => recoverElementFromData(dataToRecoverElement(node));\r\n      let k;\r\n      for(k = 0; k < redoElem.length; k++) {\r\n        let mutType = redoElem[k].type;\r\n        let qk = quicker(redoElem[k].target);\r\n        let target = (redoElem[k].target.isConnected ? \r\n                        redoElem[k].target : \r\n                        (qk == undefined ? redoElem[k].target : qk));\r\n        if(mutType === \"attributes\") {\r\n          let cur_attr = target.getAttribute(redoElem[k].attributeName);\r\n          if (redoElem[k].URValue === null) {\r\n            target.removeAttribute(redoElem[k].attributeName); \r\n          } else { \r\n            target.setAttribute(redoElem[k].attributeName, redoElem[k].URValue);\r\n          }\r\n          redoElem[k].URValue = cur_attr;\r\n        } \r\n        else if(mutType === \"characterData\") {\r\n          let cur_data = target.textContent;\r\n          target.textContent = redoElem[k].URValue;  \r\n          redoElem[k].URValue = cur_data;\r\n          //redoElem[k].isConnected ? redoElem[k].URValue : quicker(redoElem[k]).URValue = cur_data;\r\n        }\r\n        else if(mutType === \"linkHrefCSS\") {\r\n          let keepRedo = redoElem[k];\r\n          await assignTmpCss(target, keepRedo.newValue, true);\r\n        }\r\n        else {\r\n          let rRemNodes = redoElem[k].removedNodes;\r\n          let rAddNodes = redoElem[k].addedNodes;\r\n          let i, j;\r\n          let kidNodes = target.childNodes;\r\n          if(rAddNodes.length) {\r\n            for(j = 0; j < kidNodes.length; j++) {\r\n              let knode = kidNodes.item(j);\r\n              let raddnode = rAddNodes.item(i);\r\n              let ran = quicker(raddnode);\r\n              let knode_may = quicker(knode);\r\n              //if(kidNodes.item(j) === redoElem[k].nextSibling && kidNodes.item(j).previousSibling === redoElem[k].previousSibling)\r\n              let ns = redoElem[k].nextSibling && redoElem[k].nextSibling.isConnected ? redoElem[k].nextSibling : quicker(redoElem[k].nextSibling);\r\n              let ps = redoElem[k].previousSibling && redoElem[k].previousSibling.isConnected ? redoElem[k].previousSibling : quicker(redoElem[k].previousSibling);\r\n              if ((knode == ns || knode_may == ns || ns == undefined) &&\r\n                  (knode.previousSibling == ps || knode_may.previousSibling == ps || ps == undefined || ((knode == ps) && !(ns == ps)))) {\r\n                for(i = 0; i < rAddNodes.length; i++) {\r\n                  /*console.log(editor.hasGhostAncestor);\r\n                  if(editor.hasGhostAncestor(rAddNodes.item(i))) {\r\n                    continue;\r\n                  }*/\r\n                  console.log(rAddNodes.item(i));\r\n\r\n                  if(ns) {\r\n                    target.insertBefore(ran == undefined ? rAddNodes.item(i) : ran, knode.isConnected ? knode : knode_may);\r\n                  }\r\n                  else {\r\n                    target.appendChild(ran == undefined ? rAddNodes.item(i) : ran, knode.isConnected ? knode : knode_may);\r\n\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n          for(i = 0; i < rRemNodes.length; i++) {\r\n            /*if(editor.hasGhostAncestor(rRemNodes.item(i))) {\r\n              continue;\r\n            }*/if(!target.parentElement.contains(quicker(rRemNodes.item(i)))) { //bc the node in rRemNodes isn't necessarily connected, we need to rewrite this.\r\n              console.log(\"The item you are trying to redo doesn't exist in the parent node.\");\r\n            } else {\r\n              target.removeChild(quicker(rRemNodes.item(i)));\r\n            }\r\n          }\r\n        }\r\n      } //mut looper\r\n      editor.ui.model.undoStack.push(redoElem);\r\n      if (editor.ui.model.isSaving) {\r\n        editor.ui.model.actionsDuringSave.unshift(\"undo\");\r\n      }\r\n      editor_resumeWatching();\r\n      editor.ui.refresh();\r\n      //editor.ui._internals.printstacks();\r\n      })();\r\n      return 1;\r\n    }; //editor.ui.redo\r\n\r\n    // Synchronizes the state of undo/redo buttons with the stacks.\r\n    editor.ui.syncUndoRedoButtons = function syncUndoRedoButtons() {\r\n      let undoButton = document.querySelector(\"#undobutton\");\r\n      let redoButton = document.querySelector(\"#redoButton\");\r\n      if(undoButton) undoButton.classList.toggle(\"disabled\", !editor.ui.canUndo());\r\n      if(redoButton) redoButton.classList.toggle(\"disabled\", !editor.ui.canRedo());\r\n      let saveButton = document.querySelector(\".saveButton\");\r\n      if(saveButton) saveButton.classList.toggle(\"disabled\", !editor.ui.canSave() && !editor.ui.model.disambiguationMenu);\r\n    }; \r\n    \r\n    // Returns true if the save button should be enabled.\r\n    editor.ui.canSave = function editor_canSave() {\r\n      return editor.ui.model.undoStack.length !== editor.ui.model.undosBeforeSave;\r\n    };\r\n    \r\n    // When selecting some text, mouse up on document, the focus node can be outside of the anchor node. We want to prevent this from happening\r\n    // This is because triple click in Chrome selects the whitespace after the last word as well.\r\n    editor.ui.fixSelection = function fixSelection() {\r\n      if(+new Date() < fixSelection.lastChanged + 1000) return;\r\n      var sel = window.getSelection();\r\n      if(!sel || !sel.rangeCount) return;\r\n      sel = sel.getRangeAt(0);\r\n      if(sel.startContainer.nodeType !== 3) return;\r\n      if(sel.endContainer.nodeType !== 1) return;\r\n      // We'll ensure that the end of selection is inside a text node and that it does not goes ouside a boundary.\r\n      let tmp = sel.startContainer;\r\n      let finalTextNode = tmp.parentNode.childNodes[tmp.parentNode.childNodes.length - 1];\r\n      while(finalTextNode.nodeType != 3) {\r\n        finalTextNode = finalTextNode.previousSibling;\r\n      }\r\n      if(finalTextNode) { // finalTextNode.nodeType === 3\r\n        var range = document.createRange();\r\n        range.setStart(sel.startContainer, sel.startOffset);\r\n        range.setEnd(finalTextNode, finalTextNode.textContent.length);\r\n        editor.ui.clearTextSelection();\r\n        window.getSelection().addRange(range);\r\n        fixSelection.lastChanged = +new Date();\r\n      }\r\n    }; // editor.ui.fixSelection\r\n    \r\n    \r\n    // Returns a copy of the selection before clearing it.\r\n    editor.ui.clearTextSelection = function clearTextSelection() {\r\n      var sel = window.getSelection();\r\n      if(!sel || !sel.rangeCount) return;\r\n      var selection = sel.getRangeAt(0);\r\n      if (window.getSelection) {\r\n        if (window.getSelection().empty) {  // Chrome\r\n          window.getSelection().empty();\r\n        } else if (window.getSelection().removeAllRanges) {  // Firefox\r\n          window.getSelection().removeAllRanges();\r\n        }\r\n      } else if (document.selection) {  // IE?\r\n        document.selection.empty();\r\n      }\r\n      return selection;\r\n    }; // editor.ui.clearTextSelection\r\n    \r\n    // Handle a file event (e.g. uploaded files)\r\n    editor.ui.handleDroppedFiles =\r\n      function handleDroppedFiles(evt) {\r\n        evt.stopPropagation();\r\n        evt.preventDefault();\r\n        var files = evt.dataTransfer.files; // FileList object\r\n        editor.uploadFilesAtCursor(files);\r\n      }\r\n    \r\n    editor.ui.handleDragOver =\r\n      function handleDragOver(evt) {\r\n        evt.stopPropagation();\r\n        evt.preventDefault();\r\n        evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.\r\n      }\r\n    \r\n    // Prevent mouse down on modify-menu that end outside modify-menu to trigger onclick\r\n    editor.ui._internals.onMouseDown = function(event) {\r\n      var tmp = event.target;\r\n      while(tmp) {\r\n        if(tmp.getAttribute && tmp.getAttribute(\"id\") == \"modify-menu\") {\r\n          editor.ui.model.dismissNextClick = true;\r\n          return;\r\n        }\r\n        tmp = tmp.parentElement;\r\n      }\r\n    }   \r\n    editor.ui._internals.onClick = function(event) {\r\n      if(editor.ui.model.dismissNextClick) {\r\n        editor.ui.model.dismissNextClick = false;\r\n        return;\r\n      }\r\n      \r\n      var clickedElem = event.target;\r\n      //console.log(\"click event\", event.target);\r\n      var editorSelectOptions = document.querySelectorAll(\"meta[editor-noselect],meta[editor-doselect]\");\r\n      var matchOptions = function(clickedElem) {\r\n        var result = true;\r\n        for(let i = 0; i < editorSelectOptions.length; i++) {\r\n          let negativeSelector = editorSelectOptions[i].getAttribute(\"editor-noselect\"),\r\n              positiveSelector = editorSelectOptions[i].getAttribute(\"editor-doselect\");\r\n          if(result && negativeSelector) {\r\n            result = !editor.matches(clickedElem, negativeSelector);\r\n          }\r\n          if(!result && positiveSelector) {\r\n            result = editor.matches(clickedElem, positiveSelector);\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n      while(clickedElem && editorSelectOptions && !matchOptions(clickedElem)) {\r\n        clickedElem = clickedElem.parentElement;\r\n      }\r\n      var ancestors = [];\r\n      var tmp = clickedElem;\r\n      var aElement;\r\n      var ancestorIsModifyBox = false;\r\n      var ancestorIsContextMenu = false;\r\n      var link = undefined;\r\n      while(tmp) {\r\n        ancestors.push(tmp);\r\n        if(tmp.getAttribute && tmp.getAttribute(\"id\") == \"modify-menu\") {\r\n          ancestorIsModifyBox = true;\r\n        }\r\n        if(tmp.getAttribute && tmp.getAttribute(\"id\") == \"context-menu\") {\r\n          ancestorIsContextMenu = true;\r\n        }\r\n        if(!aElement && tmp.tagName === \"A\") { // First link.\r\n          aElement = tmp;\r\n          link = aElement.getAttribute(\"href\");\r\n        }\r\n        tmp = tmp.parentElement;\r\n      }\r\n      document.querySelectorAll(\"[ghost-hovered=true]\").forEach(e => e.removeAttribute(\"ghost-hovered\"));\r\n      if(ancestorIsModifyBox || ancestorIsContextMenu || ancestors[ancestors.length - 1].tagName != \"HTML\") return;\r\n      //console.log(\"not modify box\", ancestors)\r\n      document.querySelector(\"#context-menu\").classList.remove(\"visible\");\r\n      \r\n      editor.ui.model.clickedElem = clickedElem;\r\n      editor.ui.model.link = link;\r\n      editor.ui.model.link_href_source = aElement; // So that we can modify it\r\n      editor.ui.model.insertElement = false;\r\n      editor.ui.model.notextselection = false;\r\n      editor.ui.refresh();\r\n      // Check if the event.target matches some selector, and do things...\r\n    } //end of editor.ui._internals.onClick\r\n\r\n    // Icons:\r\n    var icons = {};\r\n    editor.ui.icons = icons;\r\n    icons.parentUp = editor.svgFromPath(\"M 20,5 20,25 M 15,10 20,5 25,10\");\r\n    icons.boxArrowDown = editor.svgFromPath(\"M 10,17 13,14 17,18 17,4 23,4 23,18 27,14 30,17 20,27 Z\", true, 30, 20, [0, 0, 40, 30]);\r\n    icons.boxArrowUp = editor.svgFromPath(\"M 10,14 13,17 17,13 17,27 23,27 23,13 27,17 30,14 20,4 Z\", true, 30, 20, [0, 0, 40, 30]);\r\n    icons.boxArrowExpand = editor.svgFromPath(\"M 9.5,22 9.5,17 20.5,7 30.5,17 30.5,22 20.5,12 Z\", true, 30, 20, [0, 0, 40, 30]);\r\n    icons.arrowDown = editor.svgFromPath(\"M 10,17 13,14 17,18 17,4 23,4 23,18 27,14 30,17 20,27 Z\", true);\r\n    icons.arrowRight = editor.svgFromPath(\"M 21,25 18,22 22,18 8,18 8,12 22,12 18,8 21,5 31,15 Z\", true);\r\n    icons.arrowUp = editor.svgFromPath(\"M 10,14 13,17 17,13 17,27 23,27 23,13 27,17 30,14 20,4 Z\", true);\r\n    icons.arrowLeft = editor.svgFromPath(\"M 19,25 22,22 18,18 32,18 32,12 18,12 22,8 19,5 9,15 Z\", true);\r\n    icons.clone = editor.svgFromPath(\"M 19,8 31,8 31,26 19,26 Z M 11,4 23,4 23,8 19,8 19,22 11,22 Z\");\r\n    icons.save = editor.svgFromPath(\"M 10,5 10,25 30,25 30,9 26,5 13,5 Z M 13,6 25,6 25,12 13,12 Z M 22,7 22,11 24,11 24,7 Z M 13,15 27,15 27,24 13,24 Z M 11,23 12,23 12,24 11,24 Z M 28,23 29,23 29,24 28,24 Z\", true);\r\n    icons.openLeft = editor.svgFromPath(\"M 27.5,4 22.5,4 12.5,15 22.5,25 27.5,25 17.5,15 Z\", true);\r\n    icons.closeRight = editor.svgFromPath(\"M 12.5,4 17.5,4 27.5,15 17.5,25 12.5,25 22.5,15 Z\", true);\r\n    icons.openTop = editor.svgFromPath(\"M 9.5,22 9.5,17 20.5,7 30.5,17 30.5,22 20.5,12 Z\", true);\r\n    icons.closeBottom = editor.svgFromPath(\"M 9.5,7 9.5,12 20.5,22 30.5,12 30.5,7 20.5,17 Z\", true);\r\n    icons.wasteBasket = editor.svgFromPath(\"m 24,11.5 0,11 m -4,-11 0,11 m -4,-11 0,11 M 17,7 c 0,-4.5 6,-4.5 6,0 m -11,0.5 0,14 c 0,3 1,4 3,4 l 10,0 c 2,0 3,-1 3,-3.5 L 28,8 M 9,7.5 l 22,0\");\r\n    icons.plus = editor.svgFromPath(\"M 18,5 22,5 22,13 30,13 30,17 22,17 22,25 18,25 18,17 10,17 10,13 18,13 Z\", true);\r\n    icons.liveLink = link => `<a class=\"livelink\" href=\"javascript:if(editor.confirmLeaving()) { editor.navigateTo('${link}'); }\">${editor.svgFromPath(\"M 23,10 21,12 10,12 10,23 25,23 25,18 27,16 27,24 26,25 9,25 8,24 8,11 9,10 Z M 21,5 33,5 33,17 31,19 31,9 21,19 19,17 29,7 19,7 Z\", true)}</a>`;\r\n    icons.gear = editor.svgFromPath(\"M 17.88,2.979 14.84,3.938 15.28,7.588 13.52,9.063 10,8 8.529,10.83 11.42,13.1 11.22,15.38 7.979,17.12 8.938,20.16 12.59,19.72 14.06,21.48 13,25 15.83,26.47 18.1,23.58 20.38,23.78 22.12,27.02 25.16,26.06 24.72,22.41 26.48,20.94 30,22 31.47,19.17 28.58,16.9 28.78,14.62 32.02,12.88 31.06,9.84 27.41,10.28 25.94,8.52 27,5 24.17,3.529 21.9,6.42 19.62,6.219 17.88,2.979 Z M 20,11 A 4,4 0 0 1 24,15 4,4 0 0 1 20,19 4,4 0 0 1 16,15 4,4 0 0 1 20,11 Z\", true);\r\n    icons.folder = editor.svgFromPath(\"M 8,3 5,6 5,26 10,10 32,10 32,6 18,6 15,3 8,3 Z M 5,26 10,10 37,10 32,26 Z\");\r\n    icons.reload = editor.svgFromPath(\"M 32.5,8.625 30.25,15.25 24.75,11.125 M 6.75,20 9.875,14.5 15.125,19 M 29.5,18 C 28.25,22.125 24.375,25 20,25 14.5,25 10,20.5 10,15 M 10.5,12 C 11.75,7.875 15.625,5 20,5 25.5,5 30,9.5 30,15\");\r\n    icons.log = editor.svgFromPath(\"M 17.24,16 A 1.24,2 0 0 1 16,18 1.24,2 0 0 1 14.76,16 1.24,2 0 0 1 16,14 1.24,2 0 0 1 17.24,16 Z M 20,16 21.24,16 21.24,16 A 1.24,2 0 0 1 20,18 1.24,2 0 0 1 18.76,16 1.24,2 0 0 1 20,14 1.33,2.16 0 0 1 21,15 M 12,14 12,18 14,18 M 10,12 23,12 23,20 10,20 Z M 23,6 23,11 28,11 M 14,6 14,12 10,12 10,20 14,20 14,25 28,25 28,11 23,6 14,6 Z\");\r\n    icons.source = editor.svgFromPath(\"M 22.215125,2 25,3 18.01572,27 15,26 Z M 12,19 12,25 2,14 12,4 12,9 7,14 Z M 28,9 28,4 38,15 28,25 28,20 33,15 Z\", true);\r\n    icons.undo = editor.svgFromPath(\"M 9.5,12.625 11.75,19.25 17.25,15.125 M 31.5,16 C 30.25,11.875 26.375,9 22,9 16.5,9 12,13.5 12,19\");\r\n    icons.redo = editor.svgFromPath(\"M 31.5,12.625 29.25,19.25 23.75,15.125 M 9.5,16 C 10.75,11.875 14.625,9 19,9 24.5,9 29,13.5 29,19\");\r\n    icons.isDraft = editor.svgFromPath(\"M 2,7 2,25 38,25 38,7 M 36,6 C 32,6 29.1,3.9 26.1,3.9 23.1,3.9 22,5 20,6 L 20,23 C 22,22 23.1,20.9 26.1,20.9 29.1,20.9 32,22.9 36,22.9 Z M 4,6 C 8,6 10.9,3.9 13.9,3.9 16.9,3.9 18,5 20,6 L 20,23 C 18,22 16.9,20.9 13.9,20.9 10.9,20.9 8,22.9 4,22.9 Z\");\r\n    icons.escape = editor.svgFromPath(\"M 7.5 4 L 17.5 15 L 7.5 25 L 12.5 25 L 20 17.5 L 27.5 25 L 32.5 25 L 22.5 15 L 32.5 4 L 27.5 4 L 20 12.25 L 12.5 4 L 7.5 4 z\", true);\r\n    icons.linkMode = editor.svgFromPath(\"M 14,3 14,23 19,19 22,27 25,26 22,18 28,18 Z\");\r\n    icons.check = editor.svgFromPath(\"M 10,13 13,13 18,21 30,3 33,3 18,26 Z\", true);\r\n    \r\n    /***********************\r\n      Editor's main toolbar\r\n    ************************/\r\n\r\n    var thaditor_files = [\r\n      \"Thaditor\", \"Makefile\", \"ThaditorPackager.py\", \"ThaditorInstaller.py\", \"ThaditorInstaller.php\",\r\n      \"ThaditorInstaller.htaccess\", \"composer.json\", \"composer.lock\", \"credentials.json\", \"cacert.pem\", \"versions\",\r\n      \"vendor\", \"ssg\", \"cache\"\r\n    ];\r\n    \r\n    var verz = computeDraftVersion();\r\n    //hover mode functions for linkSelectMode\r\n    function escapeLinkMode() {\r\n      document.body.removeEventListener('mouseover', linkModeHover1, false);\r\n      document.body.removeEventListener('mouseout', linkModeHover2, false);\r\n      //removing the hovered element (which is retained if the escape key is hit)\r\n      document.querySelectorAll(\"[ghost-hovered=true]\").forEach(e => e.removeAttribute(\"ghost-hovered\"));\r\n      editor.ui.model.visible = false;\r\n      editor.ui.model.linkSelectMode = false;\r\n      editor.ui.model.linkSelectCallback = undefined;\r\n      editor.ui.model.linkSelectOtherMenus = undefined;\r\n      editor.ui.refresh();\r\n    }\r\n    function noGhostHover(node) {\r\n      curClass = node.getAttribute(\"class\")\r\n      if(curClass === \"modify-menu-icon-label-link\" ||\r\n        curClass === \"context-menu-icon\" ||\r\n        curClass === \"context-menu-icon fill\") {\r\n          return false;\r\n        }\r\n      else if(node.tagName === \"path\" || node.tagName === \"PATH\") {\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n    function linkModeHover1(event) {\r\n      //console.log(event.target);\r\n      //console.log(event.target.tagName);\r\n      //console.log(event.target.getAttribute(\"class\"));\r\n      if(noGhostHover(event.target)) { \r\n        event.target.setAttribute(\"ghost-hovered\", true);\r\n        editor.ui.refresh();\r\n        //console.log(\"hey!\");\r\n      }\r\n    }\r\n    function linkModeHover2(event) {\r\n      if(noGhostHover(event.target)) {\r\n        event.target.removeAttribute(\"ghost-hovered\");\r\n        editor.ui.refresh();\r\n      }\r\n    }\r\n\r\n    function confirmLeaving() {\r\n      if(editor.ui.canSave()) {\r\n        var x = confirm(\"There are unsaved modifications. Do you want to discard them?\");\r\n        if(x) {\r\n          editor.ui.model.undoStack = [];\r\n          editor.ui.model.redoStack = [];\r\n          return true;\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n      editor.ui.model.undoStack = [];\r\n      editor.ui.model.redoStack = [];\r\n      return true;\r\n    }\r\n    editor.confirmLeaving = confirmLeaving;\r\n    //(outer lastEditScript)\r\n\r\n    // Wraps a portion of code so that it and its mutation observers are executed with the flag editor.ui.model.userIsModifying set to true.\r\n    editor.userModifies = function userModifies(callback) {\r\n      editor.ui.model.userIsModifying = true;\r\n      callback();\r\n      setTimeout(() => editor.ui.model.userIsModifying = false, 0); // Will be invoked after mutation handlers.\r\n    }\r\n    \r\n    // newValue can be a function, in which it should be applied on the current content.\r\n    // Returns the old value.\r\n    async function assignTmpCss(linkNode, newValue, notUndoable) {\r\n      if(!notUndoable) { // We send this to undo.\r\n        editor_stopWatching();\r\n        let oldValue = await assignTmpCss(linkNode, newValue, true);\r\n        let m = {type: \"linkHrefCSS\", target: linkNode, oldValue: oldValue, newValue: newValue};\r\n        editor.ui._internals.makeMutationUndoable(m);\r\n        editor.ui.syncUndoRedoButtons();\r\n        editor_resumeWatching();\r\n        return;\r\n      }\r\n      // Here the change should not take care of doing the undo/redo part. \r\n      let ghostHref = linkNode.getAttribute(\"ghost-href\");\r\n      let hasGhostHref = typeof ghostHref === \"string\";\r\n      let oldHref = hasGhostHref ? ghostHref : linkNode.getAttribute(\"href\")\r\n      let CSSFilePath = relativeToAbsolute(removeTimestamp(oldHref));\r\n      let currentContent = typeof linkNode.cachedContent === \"string\" ? linkNode.cachedContent :\r\n                               await editor.getServer(\"read\", CSSFilePath);\r\n      if(typeof linkNode.cachedContent !== \"string\") {\r\n        linkNode.cachedContent = currentContent;\r\n      }\r\n      if(hasGhostHref) { // Proxied\r\n        console.log(\"Was proxied\");\r\n        let tmpCachedContent = typeof linkNode.tmpCachedContent == \"string\" ? linkNode.tmpCachedContent :\r\n                               await editor.getServer(\"read\", linkNode.getAttribute(\"href\"));\r\n        if(typeof newValue === \"function\") {\r\n          newValue = newValue(tmpCachedContent);\r\n        }\r\n        if(currentContent === newValue) { // We can remove the proxy\r\n          if(!notUndoable) {\r\n            editor.ui.model.outputObserver.disconnect();\r\n          }\r\n          let CSSTmpFilePath = linkNode.getAttribute(\"href\");\r\n          await editor.postServer(\"unlink\", removeTimestamp(CSSTmpFilePath));\r\n          linkNode.setAttribute(\"href\", oldHref);\r\n          linkNode.removeAttribute(\"ghost-href\");\r\n          linkNode.tmpCachedContent = newValue;\r\n        } else { // We keep the proxy, just update the href\r\n          let CSSTmpFilePath = linkNode.getAttribute(\"href\");\r\n          await editor.postServer(\"write\", removeTimestamp(CSSTmpFilePath), newValue);\r\n          linkNode.setAttribute(\"href\", setTimestamp(CSSTmpFilePath));\r\n          linkNode.tmpCachedContent = newValue;\r\n        }\r\n        return tmpCachedContent;\r\n      } else {// Unproxied\r\n        console.log(\"Was not proxied\")\r\n        if(typeof newValue === \"function\") {\r\n          newValue = newValue(currentContent);\r\n        }\r\n        if(currentContent !== newValue) { // Create the proxy file\r\n          console.log(\"Value updated\")\r\n          //add dummy counter, force reload\r\n          linkNode.setAttribute(\"ghost-href\", oldHref);\r\n          let CSSTmpFilePath = getTempCSSName(CSSFilePath);\r\n          await editor.postServer(\"write\", CSSTmpFilePath, newValue);\r\n          linkNode.setAttribute(\"href\", setTimestamp(CSSTmpFilePath));\r\n          linkNode.tmpCachedContent = newValue;\r\n        } // else nothing to change, leave unproxied.\r\n        return currentContent;\r\n      }\r\n    }\r\n    \r\n    function init_css_parser() {\r\n      let thaditorLossLessCss = document.querySelector(\"script#thaditor-losslesscss\");\r\n      if(!thaditorLossLessCss) {\r\n        let script = el(\"script\", {id: \"thaditor-losslesscss\", class:\"editor-interface\", type:\"text/javascript\", src:\"https://cdn.jsdelivr.net/gh/MikaelMayer/lossless-css-parser@@d4d64a4a87f64606794a47ab58428900556c56dc/losslesscss.js\", async:\"true\", onload:\"editor.ui._internals.setLosslessCssParser(losslesscssjs);\", isghost: \"true\"});\r\n        document.head.appendChild(script);\r\n      } else {\r\n        console.log(\"thaditorLossLessCss found\", thaditorLossLessCss);\r\n      }\r\n    }\r\n         \r\n    function init_interfaces() {\r\n      init_css_parser();\r\n      let linkSelect = function() {\r\n        activateNodeSelectionMode(\"to link to\",\r\n          (linkFrom => linkTo => {\r\n            let targetID = linkTo.getAttribute(\"id\");\r\n            if(!targetID) {\r\n              targetID = \"ID\" + editor.ui.model.idNum\r\n              linkTo.setAttribute(\"id\", targetID);\r\n              editor.ui.model.idNum += 1;\r\n            }\r\n            else if(targetID.length > 100) {\r\n              targetID = targetID.trim();\r\n              linkTo.setAttribute(\"id\", targetID);\r\n            }\r\n            linkFrom.setAttribute(\"href\", \"#\" + targetID);\r\n          })(editor.ui.model.clickedElem)\r\n        );\r\n      } \r\n      let createButton = function(innerHTML, attributes, properties) {\r\n        let button = el(\"div\", attributes, [], properties);\r\n        button.onmousedown = button.onmousedown ? button.onmousedown : preventTextDeselection;\r\n        button.classList.add(\"modify-menu-button\");\r\n        button.innerHTML = innerHTML;\r\n        return button;\r\n      } //you can append a createbutton to the element returning in render\r\n      let add_btn_to_div = (div, innerHTML, attributes, properties) => {\r\n        div.append(createButton(innerHTML, attributes, properties));\r\n      };\r\n      if(typeof simple_editor_interface === \"object\") {\r\n        let x = simple_editor_interface[editor.config.EDITOR_VERSION];\r\n        if(typeof x === \"object\") {\r\n          editor.ui.model.interfaces.push(x);\r\n          if(x.alone) {\r\n            return;\r\n          }\r\n        }\r\n      }\r\n      editor.ui.model.interfaces.push({\r\n        title: \"Selected Element Tree\",\r\n        minimized: true,\r\n        priority(editor_model) {\r\n          return undefined;\r\n        },\r\n        enabled(editor_model) {\r\n          return editor_model.clickedElem;\r\n        },\r\n        render: function render(editor_model, innerBox) {\r\n          let domSelector = el(\"div.dom-selector.noselect\"); // create dom selector interface\r\n          const clickedElem = editor_model.clickedElem;\r\n          if (!clickedElem) return \"Click on an element to view its location in DOM tree\";\r\n          domSelector.classList.add(\"dom-selector-style\");\r\n          let mainElemDiv = el(\"div.mainElem\");\r\n          let childrenElemDiv = el(\"div.childrenElem\");\r\n          domSelector.append(\r\n            mainElemDiv, childrenElemDiv\r\n          );\r\n          let displayMainElem = function(elem) {\r\n            mainElemDiv.append(\r\n              el(\"div\", {\"class\":\"mainElemName\", \"type\":\"text\", value: elem.tagName.toLowerCase()}, \"<\" + elem.tagName.toLowerCase() + \">\", {\r\n                onmouseenter: (c => () => { c.setAttribute(\"ghost-hovered\", \"true\") })(elem),\r\n                onmouseleave: (c => () => { c.removeAttribute(\"ghost-hovered\") })(elem)\r\n              }),\r\n              el(\"div\", {\"class\": \"mainElemInfo\"}, textPreview(elem, 50))\r\n            );\r\n          }\r\n          let displayChildrenElem = function(elem) {\r\n            childrenElemDiv.append(\r\n              el(\"div\", {\r\n                  \"class\": \"childrenSelector\" + (elem.matches(\".editor-interface\") ? \" editor-interface-dom-selector\" : \"\") +\r\n                    (editor.isGhostNode(elem) ? \" editor-recorded-ghost-node\" : \"\"),\r\n                  title: elem.matches(\".editor-interface\") ? \"This is part of Editor\" : (editor.isGhostNode(elem) ? \"(temporary) \" : \"\") + textPreview(elem, 20)\r\n                  },\r\n                [\r\n                  el(\"div\", {\"class\": \"childrenSelectorName\"}, \"<\" + elem.tagName.toLowerCase() + \">\", {}),\r\n                  // el(\"div\", {\"class\": \"childrenSelectorInfo\"}, textPreview(elem, 20))\r\n                ], \r\n                {\r\n                  onmouseenter: (c => () => { c.setAttribute(\"ghost-hovered\", \"true\") })(elem),\r\n                  onmouseleave: (c => () => { c.removeAttribute(\"ghost-hovered\") })(elem)\r\n                }\r\n              )\r\n            );\r\n          }\r\n          // show attributes of element on the dom selector\r\n          let displayElemAttr = function(targetDiv, elem) {\r\n            for (let i = 0; elem && elem.attributes && i < elem.attributes.length; i++) {\r\n              let name = elem.attributes[i].name;\r\n              let value = elem.attributes[i].value;\r\n              if (name === \"ghost-clicked\" || name === \"ghost-hovered\") continue;\r\n              targetDiv.append(\r\n                el(\"div\", { \"class\": \"elementAttr\" },\r\n                  [\r\n                    el(\"span\", { title: \"This element has attribute name '\" + name + \"'\" }, name + \": \"),\r\n                    el(\"span\", { title: \"This element has attribute value '\" + value + \"'\" }, value)\r\n                  ]\r\n                )\r\n              );\r\n            }\r\n          }\r\n          // display children and siblings in the second part of selector\r\n          let displayChildrenSiblings = function(middleChild, selectMiddleChild) {\r\n            // display clicked element's previous sibling, clicked element, clicked element's next sibling\r\n            let cnt = 0;\r\n            // display previous sibling\r\n            if (middleChild.previousElementSibling && \r\n                (middleChild.previousElementSibling.id !== \"context-menu\" || middleChild.previousElementSibling.id !== \"modify-menu\" || middleChild.previousElementSibling.id !== \"editbox\")) {\r\n              displayChildrenElem(middleChild.previousElementSibling);\r\n              let qs = childrenElemDiv.querySelectorAll(\".childrenElem > .childrenSelector\");\r\n              console.log ({qs});\r\n              qs[cnt].onclick = function () {\r\n                let c = middleChild.previousElementSibling;\r\n                if ((c.tagName && c.tagName === \"HTML\") || !c.tagName) {\r\n                  return;\r\n                }\r\n                // still in status 2, but clicked element change to previous sibling\r\n                editor_model.displayClickedElemAsMainElem = false;\r\n                editor_model.previousVisitedElem = []; // clear the stack\r\n                editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\r\n                editor_model.clickedElem = c;\r\n                editor_model.notextselection = true;\r\n                if(editor.config.onMobile()) editor_model.savedTextSelection = editor.ui.clearTextSelection();\r\n                editor.ui.refresh();\r\n              }\r\n            } else {\r\n              childrenElemDiv.append(\r\n                el(\"div\", {\"class\": \"childrenSelector no-sibling\"}, \"no sibling\")\r\n              );\r\n            }\r\n            cnt++;\r\n            // display certain child in the middle\r\n            displayChildrenElem(middleChild);\r\n            childrenElemDiv.querySelectorAll(\".childrenElem > .childrenSelector\")[cnt].onclick = function () {\r\n              let c = middleChild;\r\n              if (!c.tagName) {\r\n                return;\r\n              }\r\n\r\n              if (!c.hasChildNodes() || (clickedElem.childNodes.length == 1 && clickedElem.childNodes[0].nodeType === 3)) {\r\n                // still in status 2\r\n                editor_model.displayClickedElemAsMainElem = false;\r\n              } else {\r\n                // switch to status 1\r\n                editor_model.displayClickedElemAsMainElem = true;\r\n              }\r\n              editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\r\n              editor_model.clickedElem = c;\r\n              editor_model.notextselection = true;\r\n              if(editor.config.onMobile()) editor_model.savedTextSelection = editor.ui.clearTextSelection();\r\n              editor.ui.refresh();\r\n            }\r\n            if (selectMiddleChild) {\r\n              childrenElemDiv.querySelectorAll(\".childrenElem > .childrenSelector\")[cnt].classList.add(\"selectedDom\");\r\n            }\r\n            cnt++;\r\n            // display next sibling\r\n            if (middleChild.nextElementSibling && \r\n              (middleChild.nextElementSibling.id !== \"context-menu\" || middleChild.nextElementSibling.id !== \"modify-menu\" || middleChild.nextElementSibling.id !== \"editbox\")) {\r\n              displayChildrenElem(middleChild.nextElementSibling);\r\n              childrenElemDiv.querySelectorAll(\".childrenElem > .childrenSelector\")[cnt].onclick = function () {\r\n                let c = middleChild.nextElementSibling;\r\n                if ((c.tagName && c.tagName === \"HTML\") || !c.tagName) {\r\n                  return;\r\n                }\r\n                // still in status 2, but clicked element change to next sibling\r\n                editor_model.displayClickedElemAsMainElem = false;\r\n                editor_model.previousVisitedElem = []; // clear the stack\r\n                editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\r\n                editor_model.clickedElem = c;\r\n                editor_model.notextselection = true;\r\n                if(editor.config.onMobile()) editor_model.savedTextSelection = editor.ui.clearTextSelection();\r\n                editor.ui.refresh();\r\n              }\r\n            } else {\r\n              childrenElemDiv.append(\r\n                el(\"div\", {\"class\": \"childrenSelector no-sibling\"}, \"no sibling\")\r\n              );\r\n            }\r\n          }\r\n          // editor itself should be invisible\r\n          if (clickedElem.id !== \"context-menu\" || clickedElem.id !== \"modify-menu\" || clickedElem.id !== \"editbox\") {\r\n            console.log(clickedElem);\r\n            if (!clickedElem.hasChildNodes() || (clickedElem.childNodes.length == 1 && clickedElem.childNodes[0].nodeType === 3)) {\r\n              editor_model.displayClickedElemAsMainElem = false;\r\n            }\r\n            // status 1. display clicked element in main part\r\n            if (editor_model.displayClickedElemAsMainElem) {\r\n              displayMainElem(clickedElem);\r\n              domSelector.classList.add(\"selectedDom\");\r\n              mainElemDiv.onclick = function () {\r\n                if (!clickedElem.tagName) {\r\n                  return;\r\n                }\r\n                // When the main element in selector is clicked, selector switch to status 2 so that user can see its parent element\r\n                editor_model.displayClickedElemAsMainElem = false;\r\n                editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\r\n                editor_model.clickedElem = clickedElem;\r\n                editor_model.notextselection = true;\r\n                if(editor.config.onMobile()) editor_model.savedTextSelection = editor.ui.clearTextSelection();\r\n                editor.ui.refresh();\r\n              }\r\n              displayElemAttr(mainElemDiv, clickedElem);\r\n              // display children, if no previous selected child, display first 3 children elements in second part of selector\r\n              if (editor_model.previousVisitedElem.length < 2 ||\r\n                  (editor_model.previousVisitedElem[editor_model.previousVisitedElem.length - 1] != clickedElem)) {\r\n                if (editor_model.previousVisitedElem.length !== 0) {\r\n                  editor_model.previousVisitedElem = [];\r\n                }\r\n                if (clickedElem.children.length > 0) {\r\n                  // only display first 3 children elements\r\n                  let childrenElem = clickedElem.children;\r\n                  for (let i = 0, cnt = 0; i < childrenElem.length && cnt < 3; ++i) {\r\n                    // prevent displaying editor itself\r\n                    if (cnt === 0 && (childrenElem[i].matches(\".editor-interface\") || editor.isGhostNode(childrenElem[i]))) {\r\n                      continue;\r\n                    }\r\n                    displayChildrenElem(childrenElem[i]);\r\n                    let qs = childrenElemDiv.querySelectorAll(\".childrenElem > .childrenSelector\");\r\n                    console.log ({qs});\r\n                    qs[cnt].onclick = function () {\r\n                      let c = childrenElem[i];\r\n                      if (!c.tagName) {\r\n                        return;\r\n                      }\r\n                      if (!c.hasChildNodes() || (clickedElem.childNodes.length == 1 && clickedElem.childNodes[0].nodeType === 3)) {\r\n                        editor_model.displayClickedElemAsMainElem = false;\r\n                      } else {\r\n                        // still in status 1\r\n                        editor_model.displayClickedElemAsMainElem = true;\r\n                      }\r\n                      editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\r\n                      editor_model.clickedElem = c;\r\n                      editor_model.notextselection = true;\r\n                      editor.ui.refresh();\r\n                    }\r\n                    cnt++;\r\n                  }\r\n                }\r\n                // else: bottom of DOM tree\r\n              } else {\r\n                editor_model.previousVisitedElem.pop();\r\n                let middleChild = editor_model.previousVisitedElem[editor_model.previousVisitedElem.length - 1];\r\n                displayChildrenSiblings(middleChild, false);\r\n              }\r\n            } else {\r\n              // status 2. display clicked element's parent element in main part\r\n              // <html> has no parent element\r\n              if(clickedElem.parentElement) {\r\n                displayMainElem(clickedElem.parentElement);\r\n                mainElemDiv.onclick = function () {\r\n                  if (!clickedElem.parentElement.tagName) {\r\n                    return;\r\n                  }\r\n                  // still in status 2 while current clicked element's parent element becomes clicked element so that user can see grandparent element\r\n                  editor_model.displayClickedElemAsMainElem = false;\r\n                  // memoization. when user click parent element:\r\n                  if (editor_model.previousVisitedElem.length === 0) {\r\n                    editor_model.previousVisitedElem.push(clickedElem);\r\n                    editor_model.previousVisitedElem.push(clickedElem.parentElement);\r\n                  } else {\r\n                    if (editor_model.previousVisitedElem[editor_model.previousVisitedElem.length - 1] == clickedElem) {\r\n                      editor_model.previousVisitedElem.push(clickedElem.parentElement);   // continuous storing path\r\n                    } else {\r\n                      editor_model.previousVisitedElem = []; // clear the stack\r\n                    }\r\n                  }\r\n                  editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\r\n                  editor_model.clickedElem = clickedElem.parentElement;\r\n                  editor_model.notextselection = true;\r\n                  if(editor.config.onMobile()) editor_model.savedTextSelection = editor.ui.clearTextSelection();\r\n                  editor.ui.refresh();\r\n                }\r\n                displayElemAttr(mainElemDiv, clickedElem.parentElement);\r\n              } else {\r\n                // for <html>\r\n                displayMainElem(clickedElem);\r\n                displayElemAttr(mainElemDiv, clickedElem);\r\n              } \r\n              displayChildrenSiblings(clickedElem, true);\r\n            }\r\n          }\r\n          return domSelector;\r\n        }\r\n      });\r\n      editor.ui.model.interfaces.push({\r\n        title: \"Attributes\",\r\n        minimized: true,\r\n        priority(editor_model) {\r\n          return undefined;\r\n        },\r\n        enabled(editor_model) {\r\n          return editor_model.clickedElem;\r\n        },\r\n        render: function render(editor_model, innerBox) {\r\n          let keyvalues = el(\"div\", {\"class\":\"keyvalues\"});\r\n          const clickedElem = editor_model.clickedElem;\r\n          if (!clickedElem) return \"Click on an element to see its attributes\";\r\n          // modify tagname\r\n          keyvalues.append(\r\n            el(\"div\", {\"class\": \"keyvalue\"}, [\r\n              el(\"span\", {title: \"This element has tag name '\" + clickedElem.tagName.toLowerCase() + \"'\"}, \"Tag: \"),\r\n              el(\"span\", {class:\"attribute-key-value\"}, [\r\n                el(\"input\", {\"type\": \"text\", value: clickedElem.tagName.toLowerCase(), \"id\": \"newTagName\"}, \r\n                  [], {\r\n                    oninput() {\r\n                      let applyNewTagNameButton = document.querySelector(\"#applyNewTagName\");\r\n                      applyNewTagNameButton.classList.toggle(\"visible\", this.value !== this.getAttribute(\"value\") && this.value.match(/^\\w*$/));\r\n                      applyNewTagNameButton.value = this.value === \"\" ? \"-\" : \"Set\";\r\n                      applyNewTagNameButton.setAttribute(\"title\", this.value === \"\" ? \"Lift element's children and delete element\" :  \"Change tag name to '\"+this.value+\"'\");\r\n                    }\r\n                  }),\r\n                  el(\"input\", {\"type\": \"button\", id: \"applyNewTagName\", value: \"Set\", title: \"Apply new tag name\"}, [], {onclick() {\r\n                        editor.userModifies(() => {\r\n                          let newTagName = document.querySelector(\"#newTagName\").value;\r\n                          let newel;\r\n                          if(newTagName === \"\") {\r\n                            while(clickedElem.childNodes.length) {\r\n                              newel = clickedElem.childNodes[0];\r\n                              clickedElem.parentElement.insertBefore(newel, clickedElem);\r\n                            }\r\n                            clickedElem.remove();\r\n                          } else {\r\n                            newel = el(document.querySelector(\"#newTagName\").value);\r\n                            let elements = clickedElem.childNodes;\r\n                            for(let i = 0; i < elements.length; i++) {\r\n                              newel.append(elements[i].cloneNode(true));\r\n                            }\r\n                            for(let i = 0; i < clickedElem.attributes.length; i++) {\r\n                              newel.setAttribute(clickedElem.attributes[i].name, clickedElem.attributes[i].value);\r\n                            }\r\n                            clickedElem.parentElement.insertBefore(newel, clickedElem);\r\n                            clickedElem.remove();\r\n                          }\r\n                          editor_model.clickedElem = newel;\r\n                          editor.ui.refresh();\r\n                        });\r\n                      }\r\n                    }\r\n                  ),\r\n                  el(\"div\", {id:\"newtagname-align-placeholder\"}, \" \")\r\n                ]\r\n              )\r\n            ])\r\n          );\r\n          let isSpecificGhostAttributeKey = editor.isSpecificGhostAttributeKeyFromNode(clickedElem);\r\n          let isIgnoredAttributeKey = editor.isIgnoredAttributeKeyFromNode(clickedElem);\r\n\r\n          for(let i = 0; clickedElem.attributes && i < clickedElem.attributes.length; i++) {\r\n            let name = clickedElem.attributes[i].name;\r\n            if(name === \"ghost-clicked\" || name === \"ghost-hovered\") continue;\r\n            let value = clickedElem.attributes[i].value;\r\n            // Inline styles incoporated into CSS display editor\r\n            if(name !== \"style\") {\r\n              let isGhost = editor.isGhostAttributeKey(name) || isSpecificGhostAttributeKey(name);\r\n              let isIgnored = isIgnoredAttributeKey(name);\r\n              let isHref = name === \"href\" && clickedElem.tagName === \"A\";\r\n              keyvalues.append(\r\n                el(\"div\", {\"class\": \"keyvalue\" + (isGhost ? \" editor-recorded-ghost-attribute\" : \"\")\r\n                                              + (isIgnored ? \" editor-ignored-attribute\" : \"\"),\r\n                          \"title\": isGhost ? \"Key/value generated by a script\" : isIgnored ? \"key/value ignored after being modified by a script\" : undefined\r\n                }, [\r\n                  el(\"span\", {title: \"Element attribute name\"}, name + \": \"),\r\n                  el(\"span\", {class: \"attribute-key-value\", title: \"Element attribute value of \" + name}, [\r\n                    el(\"input\", {\"type\": \"text\", value: value, \"id\": (\"dom-attr-\" + name)}, [], {\r\n                        oninput: ((name, isHref) => function () {\r\n                            editor.userModifies(() => {\r\n                              clickedElem.setAttribute(name, this.value);\r\n                              if(isHref) {\r\n                                let livelinks = document.querySelectorAll(\".livelink\");\r\n                                for(let livelink of livelinks) {\r\n                                  let finalLink = livelink.matches(\"#context-menu *\") ?\r\n                                    `javascript:if(editor.confirmLeaving()) { editor.navigateTo('${linkToEdit(this.value)}'); }` : this.value;\r\n                                  livelink.setAttribute(\"href\", finalLink);\r\n                                  livelink.setAttribute(\"title\", \"Go to \" + this.value);\r\n                                }\r\n                              }\r\n                            });\r\n                        })(name, isHref)\r\n                      }),\r\n                    isHref ? el(\"div\", {title: \"Go to \" + value, \"class\": \"modify-menu-icon inert\"}, [], {\r\n                      innerHTML: editor.ui.icons.liveLink(value)\r\n                    }) : undefined,\r\n                    isHref ? el(\"div\", {title: \"Select a node on the page to refer to\", \"class\": \"modify-menu-icon inert\"}, [], { \r\n                      innerHTML: editor.ui.icons.linkMode,\r\n                      onclick: linkSelect\r\n                    }) : undefined,\r\n                    el(\"div\", {\"class\":\"modify-menu-icon\", title: \"Delete attribute '\" + name + \"'\"}, [], {\r\n                      innerHTML: editor.ui.icons.wasteBasket,\r\n                      onclick: ((name) => function() {\r\n                        editor.userModifies(() => {\r\n                          clickedElem.removeAttribute(name);\r\n                          editor_model.clickedElem = clickedElem;\r\n                          editor.ui.refresh();\r\n                        });\r\n                        })(name)\r\n                      })\r\n                    ]\r\n                  )\r\n                ]\r\n              ));\r\n            }\r\n            else {\r\n              let styleInterface = getEditorInterfaceByTitle(\"Style\");\r\n              if(styleInterface) {\r\n                styleInterface.minimized = false;\r\n                editor.ui.model.inline = clickedElem.getAttribute(\"style\");\r\n                styleInterface.priority(editor.ui.model);\r\n              }\r\n            }\r\n          }\r\n          let highlightsubmit = function() {\r\n            let attrName = this.parentElement.parentElement.querySelector(\"[name=name]\").value;\r\n            this.parentElement.parentElement.querySelector(\"div.modify-menu-icon\").disabled =\r\n              attrName === \"\" || attrName.trim() !== attrName\r\n          }\r\n\r\n          if(clickedElem.nodeType === 1) {\r\n            keyvalues.append(\r\n              el(\"div\", {\"class\": \"keyvalue keyvalueadder\"}, [\r\n                el(\"span\", {class: \"attribute-key\"}, el(\"input\", {\"type\": \"text\", placeholder: \"key\", value: \"\", name: \"name\"}, [], {oninput: highlightsubmit})),\r\n                el(\"span\", {class: \"attribute-key-value\"}, [\r\n                  el(\"span\", {}, el(\"input\", {\"type\": \"text\", placeholder: \"value\", value: \"\", name: \"value\"}, [], {\r\n                    onfocus: function() {\r\n                      let keyInput = document.querySelector(\"div.keyvalueadder input[name=name]\");\r\n                      if(keyInput && keyInput.value != \"\") {\r\n                        let name = document.querySelector(\"div.keyvalueadder input[name=name]\").value;\r\n                        editor.userModifies(() => {\r\n                          clickedElem.setAttribute(\r\n                            name,\r\n                            document.querySelector(\"div.keyvalueadder input[name=value]\").value\r\n                          );\r\n                        });\r\n                        editor.ui.refresh();\r\n                        let d =  document.querySelector(\"div.keyvalue input#dom-attr-\" + name);\r\n                        if(d) d.focus();\r\n                      }\r\n                    },\r\n                    oninput: highlightsubmit})),\r\n                  el(\"div\", {\"class\":\"modify-menu-icon\", title: \"Add this name/value attribute\"}, [], {innerHTML: editor.ui.icons.plus,\r\n                    disabled: true,\r\n                    onclick() {\r\n                      editor.userModifies(() => {\r\n                        clickedElem.setAttribute(\r\n                          this.parentElement.querySelector(\"[name=name]\").value,\r\n                          this.parentElement.querySelector(\"[name=value]\").value\r\n                        );\r\n                      });\r\n                      editor.ui.refresh();\r\n                    },\r\n                    oninput: highlightsubmit })])\r\n              ])\r\n            );\r\n          }\r\n          return keyvalues;\r\n        }\r\n      });\r\n      \r\n      editor.ui.model.interfaces.push({\r\n        title: \"Style\",\r\n        minimized: true,\r\n        priority(editor_model) {\r\n          if(editor_model.inline) return 1;\r\n          return undefined;\r\n        },\r\n        enabled(editor_model) {\r\n          return editor_model.clickedElem;\r\n        },\r\n        render: function render(editor_model, innerBox) {\r\n          const clickedElem = editor_model.clickedElem;\r\n          if(!clickedElem) {\r\n            return \"Click on an element to see its style\";\r\n          }\r\n          const do_css = (clickedElem && clickedElem.id !== \"context-menu\" && clickedElem.id !== \"modify-menu\" && clickedElem.id !== \"editbox\" &&\r\n                          !editor_model.insertElement);\r\n          let CSSarea = el(\"div\", {id: \"CSS-modification\", value: \"\"}, [], {}); \r\n          if (!do_css) return CSSarea;\r\n          //parse relevant CSS, recording prior and post CSS text as well \r\n\r\n          async function fullParseCSS() {\r\n            var fullCSS = [], keyframes = [], rawCSS = [];\r\n            //console.log(\"All style tags:\", document.querySelectorAll(\"style\"));\r\n            let CSSstyles = document.querySelectorAll(\"link[rel=stylesheet], style\");\r\n            for(let i in CSSstyles) {\r\n              let linkOrStyleNode = CSSstyles[i];\r\n              if(linkOrStyleNode.tagName === \"LINK\" && linkOrStyleNode.getAttribute(\"rel\") === \"stylesheet\" &&\r\n                 linkOrStyleNode.getAttribute(\"href\") && !linkOrStyleNode.getAttribute(\"isghost\")) {\r\n                   let href = linkOrStyleNode.getAttribute(\"href\");\r\n                   if(isAbsolute(href)) continue;\r\n                let CSSFilePath = relativeToAbsolute(removeTimestamp(href));\r\n                if(!(linkOrStyleNode.className && linkOrStyleNode.className === \"editor-interface\") && (CSSFilePath.indexOf(\"http\") < 0)) {\r\n                  let CSSvalue = typeof linkOrStyleNode.tmpCachedContent === \"string\" ?\r\n                        linkOrStyleNode.tmpCachedContent :\r\n                        await editor.getServer(\"read\", CSSFilePath);\r\n                  rawCSS.push({text: CSSvalue, tag: linkOrStyleNode});\r\n                }\r\n              }\r\n              else if(linkOrStyleNode.tagName === \"STYLE\" && !linkOrStyleNode.getAttribute(\"isghost\")) {\r\n                rawCSS.push({text: linkOrStyleNode.textContent, tag: linkOrStyleNode});\r\n              }\r\n            }\r\n            let CSSparserBuilder = await editor.ui._internals.getLosslessCssParser;\r\n            let CSSparser = new CSSparserBuilder();\r\n            function findText(parsed, startIndex, endIndex) { //for css + img replacement\r\n              let textSegment = \"\";\r\n              for(let i = startIndex; i < endIndex; i++) {\r\n                textSegment += parsed ? parsed[0].selector ? CSSparser.unparseCSS([parsed[i]]) :\r\n                  (parsed[0].directive ? CSSparser.unparseRules([parsed[i]]) : \"\") : \"\";\r\n                //console.log(textSegment);\r\n              }\r\n              return textSegment;\r\n            }\r\n            for(let z in rawCSS) {  \r\n              var parsedCSS = CSSparser.parseCSS(rawCSS[z].text);\r\n              for(let i in parsedCSS) {\r\n                if(parsedCSS[i].kind === 'cssBlock' && editor.matches(clickedElem, parsedCSS[i].selector.replace(/:(?=(:?after|:?before|:?hover))[^,]*(?=,|$)/g, \"\"))) {\r\n                  let content = CSSparser.unparseCSS([parsedCSS[i]]);\r\n                  let wsBefore = content.replace(/^(\\s*\\n|)[\\s\\S]*$/g, (m, ws) => ws);\r\n                  let contentTrimmed = content.replace(/\\s*\\n/,\"\");\r\n                  //calculating before and after text\r\n                  fullCSS.push({type: 'cssBlock', content: contentTrimmed, \r\n                    before: findText(parsedCSS, 0, Number(i)) + wsBefore, after: findText(parsedCSS, Number(i) + 1, parsedCSS.length), orgTag: rawCSS[z].tag});\r\n                }\r\n                else if(parsedCSS[i].kind === '@@media' && window.matchMedia(parsedCSS[i].atNameValue).matches) {\r\n                  let curMedia = parsedCSS[i];\r\n                  for(let j in curMedia.content) {\r\n                    if(curMedia.content[j].kind === 'cssBlock' && editor.matches(clickedElem, curMedia.content[j].selector.replace(/:(?=(:?after|:?before|:?hover))[^,]*(?=,|$)/g, \"\"))) {\r\n                      var insertMedia = {type: '@@media', content: CSSparser.unparseCSS([curMedia.content[j]]), \r\n                        mediaSelector: curMedia.wsBefore + curMedia.selector + curMedia.wsBeforeAtNameValue + curMedia.atNameValue + curMedia.wsBeforeOpeningBrace + \"{\",\r\n                        innerBefore: findText(curMedia.content, 0, j), innerAfter: findText(curMedia.content, Number(j) + 1, curMedia.content.length),\r\n                        before: findText(parsedCSS, 0, Number(i)), after: findText(parsedCSS, Number(i) + 1, parsedCSS.length), orgTag: rawCSS[z].tag, bracketAfter: curMedia.wsBeforeClosingBrace + \"}\"};\r\n                      //console.log(\"Insert media:\");\r\n                      //console.log(insertMedia);\r\n                      fullCSS.push(insertMedia);\r\n                      //console.log(\"got here first!\");\r\n                    }\r\n                  }\r\n                }\r\n                else if(parsedCSS[i].kind === '@@charset') {\r\n                  if(!(parsedCSS[i].wsBefore === \"\" && parsedCSS[i].wsBeforeAndSemicolon === \";\" && parsedCSS[i].wsBeforeValue === \" \"\r\n                    && parsedCSS[i].value.startsWith(\"\\\"\") && parsedCSS[i].value.endsWith(\"\\\"\"))) {\r\n                    editor.ui.sendNotification(\"CSS @@charset declaration is invalid due to extraneous white space.\");\t\r\n                  }\r\n                  if(editor_model.clickedElem.tagName != \"STYLE\" && editor_model.clickedElem.tagName != \"LINK\") {\r\n                    fullCSS.push({type: '@@charset', content: CSSparser.unparseCSS([parsedCSS[i]]), \r\n                      before: findText(parsedCSS, 0, i), after: findText(parsedCSS, Number(i) + 1, parsedCSS.length), orgTag: rawCSS[z].tag});\r\n                  }\r\n                }\r\n                else if(parsedCSS[i].kind === '@@keyframes') {\r\n                  keyframes.push({type: '@@keyframes', content: CSSparser.unparseCSS([parsedCSS[i]]), \r\n                    before: findText(parsedCSS, 0, Number(i)), after: findText(parsedCSS, Number(i) + 1, parsedCSS.length), orgTag: rawCSS[z].tag,\r\n                    animationName: parsedCSS[i].atNameValue});\r\n                }\r\n                else if(parsedCSS[i].kind === 'whitespace') { \r\n                  continue;\r\n                }\r\n                if(i === parsedCSS.length - 1 && !fullCSS.length) {\r\n                  console.log(\"Nothing relevant in style tag: \", rawCSS[z].tag);\r\n                }\r\n              }\r\n              //console.log(\"The parsed text looks like:\", curCSS);\r\n            }\r\n            for(i in keyframes) {\r\n              for(j in fullCSS) {\r\n                let parsedSection = CSSparser.parseCSS(fullCSS[j].content);\r\n                for(k in parsedSection.content) {\r\n                  for(l in parsedSection.content[k].rules) {\r\n                    if(Number(parsedSection.content[k].rules[l].search(keyframes[i].animationName)) >= 0) {\r\n                      fullCSS.push(keyframes[i]);\r\n                    }\r\n                  }\r\n                }\r\n                for(k in parsedSection.rules) {\r\n                  if(Number(parsedSection.rules[k].search(keyframes[i].animationName)) >= 0) {\r\n                    fullCSS.push(keyframes[i]);\r\n                  }\r\n                }\r\n              }\r\n            }\r\n            //console.log(fullCSS);\r\n            return fullCSS;\r\n          } // fullParseCSS\r\n          \r\n          function fullUnparseCSS(curCSS) {\r\n            let curTag = curCSS.orgTag;\r\n            let CSSString = \"\";\r\n            if(curCSS.type === 'cssBlock' || curCSS.type === \"@@charset\") {\r\n              //console.log(curCSS.content);\r\n              CSSString = curCSS.before + curCSS.content + curCSS.after;\r\n              //console.log(CSSString);\r\n            }\r\n            else if(curCSS.type === '@@media') { \r\n              console.log(curCSS);\r\n              CSSString = curCSS.before + curCSS.mediaSelector + curCSS.innerBefore + curCSS.content + curCSS.innerAfter + curCSS.bracketAfter + curCSS.after;   \r\n            }\r\n            if(curTag.tagName === \"LINK\") {\r\n              return CSSString;\r\n            }\r\n            // Style elements\r\n            //console.log(\"Text is:\" + CSSString);\r\n            editor.userModifies(() => {\r\n              curTag.textContent = CSSString;\r\n            });\r\n            //debugger\r\n            //consolw.log(\"After\");\r\n          } // fullUnparseCSS\r\n          var curCSSWindow = undefined;\r\n\r\n          function setCSSAreas() {\r\n            //console.log(CSSarea.firstChild);\r\n            while(CSSarea.firstChild) {\r\n              console.log(\"Removed child:\", CSSarea.firstChild);\r\n              CSSarea.removeChild(CSSarea.firstChild);\r\n            }\r\n            //if there is linked CSS text\r\n            if(clickedElem.tagName === \"LINK\" && clickedElem.getAttribute(\"rel\") === \"stylesheet\" && clickedElem.getAttribute(\"href\")) {\r\n              let oldHref = clickedElem.getAttribute(\"href\"); // Even if it's a temporary href\r\n              let CSSFilePath = relativeToAbsolute(oldHref);\r\n              (async () => {\r\n                let CSSvalue = await editor.getServer(\"read\", \"CSSFilePath\");\r\n                CSSarea.append(el(\"div\", {\"class\": \"CSS-chain\"}, [], {innerHTML: \"STYLE TEXT:\"}));\r\n                CSSarea.append(\r\n                  el(\"div\", {\"class\": \"CSS-modify-unit\"}, [\r\n                    el(\"textarea\", {\"class\": \"linked-CSS\"}, [], {\r\n                      value: CSSvalue,\r\n                      onfocusout() {\r\n                        setCSSAreas();\r\n                      },\r\n                      oninput() {\r\n                        (async () => { // Maybe create a new temporary CSS file.\r\n                          await assignTmpCss(clickedElem, this.value);\r\n                        })();\r\n                      }\r\n                    })\r\n                  ])\r\n                );\r\n              })();\r\n            }\r\n            //inline styles \r\n            editor_model.inline = clickedElem.getAttribute(\"style\"); //? CSSparser.parseCSS(clickedElement.getAttribute(\"style\")) : undefined;\r\n            if(editor_model.inline) {\r\n              console.log(\"We have inline CSS!\");\r\n              let inlineCSS = el(\"div\", {\"class\": \"CSS-modify-unit\"}, [\r\n                el(\"textarea\", {\"class\": \"inline-CSS\"}, [], {\r\n                  value: editor_model.inline,\r\n                  onfocusout() {\r\n                    setCSSAreas();\r\n                  },\r\n                  oninput() {\r\n                    editor.userModifies(() => {\r\n                      clickedElem.setAttribute(\"style\", this.value);\r\n                    });\r\n                  }\r\n                }),\r\n                el(\"div\", {\"class\": \"CSS-buttons\", title: \"Apply this style to other elements by creating a rule\"}, [\r\n                  el(\"div\", {\"class\": \"CSS-action-button\"}, [], {\r\n                    innerHTML: editor.ui.icons.clone,\r\n                    onclick() {\r\n                      let stylesLinks = document.querySelectorAll(\"style, link[rel=stylesheet]\");\r\n                      let i = stylesLinks.length - 1;\r\n                      let lastStyleLink = stylesLinks[i];\r\n                      while(i >= 0 && lastStyleLink.matches(\".editor-interface, .editor-interface *\")) {\r\n                        i--;\r\n                        lastStyleLink = stylesLinks[i];\r\n                      }\r\n                      if(lastStyleLink && (lastStyleLink.isghost || lastStyleLink.tagName === \"LINK\" && lastStyleLink.tagName.indexOf(\"http\") >= 0)) {\r\n                        lastStyleLink = undefined;\r\n                      }\r\n                      console.log(\"Closest CSS source:\", lastStyleLink);\r\n                      let inline_CSS = document.querySelectorAll(\".inline-CSS\");\r\n                      console.log(\"Finding inline CSS textarea:\", inline_CSS);  \r\n                      let postIndentCSS = \"\";\r\n                      let preIndentCSS = inline_CSS[0].value.split(\"\\n\");\r\n                      for(let i = 0; i < preIndentCSS.length; i++) {\r\n                        if(i !== preIndentCSS.length-1) {\r\n                          postIndentCSS += \"  \" + preIndentCSS[i] + \"\\n\";\r\n                        }\r\n                        else {\r\n                          postIndentCSS += \"  \" + preIndentCSS[i]; \r\n                        }\r\n                      }\r\n                      let curSelector = getShortestUniqueSelector(clickedElem);\r\n                      postIndentCSS = \"\\n\" + curSelector + \" {\\n\" + postIndentCSS + \"\\n}\";   \r\n                      console.log(\"lastStyleLink is:\", lastStyleLink);     \r\n                      if(lastStyleLink) {\r\n                        if(lastStyleLink.tagName === \"LINK\") {\r\n                          (async () => {\r\n                            await assignTmpCss(lastStyleLink, oldValue => oldValue + postIndentCSS);\r\n                            editor.userModifies(() => {\r\n                              clickedElem.removeAttribute(\"style\");\r\n                            });\r\n                            setCSSAreas();\r\n                          })();\r\n                        }\r\n                        else { // lastStyleLink is a <style>\r\n                          let curValue = lastStyleLink.textContent;\r\n                          lastStyleLink.textContent = curValue + postIndentCSS;\r\n                          editor.userModifies(() => {\r\n                            clickedElem.removeAttribute(\"style\");\r\n                          });\r\n                          setCSSAreas();\r\n                        }\r\n                      }\r\n                      else {\r\n                        //just default to style node for now\r\n                        editor.userModifies(() => {\r\n                          document.body.appendChild(el(\"style.inserted-CSS\", {}, postIndentCSS));\r\n                          clickedElem.removeAttribute(\"style\");\r\n                        });\r\n                        setCSSAreas();\r\n                      }\r\n                    }\r\n                  }),\r\n                  el(\"div\", {\"class\": \"CSS-action-button\"}, [], {\r\n                    innerHTML: editor.ui.icons.wasteBasket,\r\n                    onclick() {\r\n                      editor.userModifies(() => {\r\n                        let inline_CSS = document.querySelectorAll(\".inline-CSS\");\r\n                        inline_CSS.value = \"\";\r\n                        clickedElem.setAttribute(\"style\", inline_CSS.value);\r\n                      });\r\n                      setCSSAreas();\r\n                    }\r\n                  })\r\n                ])\r\n              ]);\r\n              CSSarea.append(el(\"div\", {\"class\": \"CSS-chain\"}, [], {innerHTML: \"Inline styles:\"}));\r\n              CSSarea.append(inlineCSS);\r\n            } // inline style present\r\n            else{\r\n              CSSarea.append(el(\"button.action-button#add-inline-style\", {}, [], {\r\n                innerHTML: \"Add inline style\",\r\n                onclick() {\r\n                  editor.userModifies(() => {\r\n                    clickedElem.setAttribute(\"style\", \" \");\r\n                  });\r\n                  editor.ui.refresh();\r\n                }}));\r\n            }\r\n            (async () => {\r\n            //rest of CSS\r\n            editor_model.CSSState = await fullParseCSS();\r\n            //console.log(\"CSS state is:\", editor_model.CSSState);\r\n            const count = (str) => {\r\n              const re = /\\n/g\r\n              return ((str || '').match(re) || []).length\r\n            }\r\n            for(let i in editor_model.CSSState) {\r\n              let cssState = editor_model.CSSState[i];\r\n              let orgTag = cssState.orgTag;\r\n              //console.log(\"cssState\", cssState);\r\n              let headerStr = orgTag.tagName.toLowerCase() + (orgTag.tagName === \"LINK\" ? \" (\" + removeTimestamp(orgTag.getAttribute(\"ghost-href\") || orgTag.getAttribute(\"href\"))+\":\" + (count(cssState.before) + 1) + \")\" : \"\");\r\n              for(let curElem = orgTag.parentElement; curElem; curElem = curElem.parentElement) {\r\n                headerStr =  curElem.tagName.toLowerCase() + \" > \" + headerStr; \r\n              }\r\n              CSSarea.append(el(\"div\", {\"class\": \"CSS-chain\"}, [], {\r\n                innerHTML: headerStr,\r\n                onclick: () => {\r\n                  editor_model.clickedElem = orgTag;\r\n                  editor.ui.refresh();\r\n                }\r\n                }));\r\n              if(cssState.type === '@@media') {\r\n                CSSarea.append(el(\"div\", {\"class\": \"@@media-selector\", \"contenteditable\": true}, [], {\r\n                oninput: (cssState => function() {\r\n                  (async () => {\r\n                    if(window.matchMedia(cssState.selector).matches ? editor.matches(clickedElem, cssState.content.selector) : false) {\r\n                      //implement throwError;\r\n                    }\r\n                    cssState.mediaSelector = this.textContent;\r\n                    if(cssState.orgTag.tagName != \"LINK\") {\r\n                      fullUnparseCSS(cssState);\r\n                    } else {\r\n                      await assignTmpCss(cssState.orgTag, fullUnparseCSS(cssState));\r\n                    }\r\n                  })();\r\n                })(cssState),\r\n                innerHTML: cssState.mediaSelector\r\n                }))\r\n              }\r\n              let eachCSS = el(\"div\", {\"class\": \"CSS-modify-unit\"}, [\r\n                el(\"textarea\", {\"class\": \"CSS-selectors\" }, [], {\r\n                  defaultValue: cssState.content,\r\n                  onfocusout() {\r\n                    if(this.storedCSS.orgTag.tagName != \"LINK\") {\r\n                      setCSSAreas();\r\n                    }\r\n                  },\r\n                  oninput: function() {\r\n                    console.log(\"oninput called\");\r\n                    (async () => {\r\n                      if(this.storedCSS.orgTag.tagName != \"LINK\") { // style node\r\n                        let throwError = false;\r\n                        let CSSparserBuilder = await editor.ui._internals.getLosslessCssParser;\r\n                        let CSSparser = new CSSparserBuilder();\r\n                        let curCSSState = CSSparser.parseCSS(this.value);\r\n                        //console.log(curCSSState);\r\n                        //check to make sure CSS is still relevant to clicked element.\r\n                        if(curCSSState && curCSSState.length && curCSSState[0].kind === 'cssBlock' && !editor.matches(clickedElem, curCSSState[0].selector)) {\r\n                          editor.ui.sendNotification(\"CSS selector does not match\");\r\n                          this.setAttribute(\"wrong-selector\", true);\r\n                          this.setAttribute(\"title\", \"The first CSS selector does not apply to the selected element!\");\r\n                        }\r\n                        else {\r\n                          this.setAttribute(\"wrong-selector\", false);\r\n                          this.removeAttribute(\"title\");\r\n                        }\r\n                        this.storedCSS.content = this.value;\r\n                        fullUnparseCSS(this.storedCSS);\r\n                        //setCSSAreas();\r\n                      }\r\n                      else { // Link\r\n                        this.storedCSS.content = this.value;\r\n                        await assignTmpCss(this.storedCSS.orgTag, fullUnparseCSS(this.storedCSS));\r\n                      }\r\n                    })();\r\n                  },\r\n                  storedCSS: cssState\r\n                }),\r\n                orgTag.tagName === \"LINK\" ?\r\n                  el(\"div\", {\"class\": \"CSS-action-button\", \"title\": \"Delete this snippet of CSS\"}, [], {\r\n                    innerHTML: editor.ui.icons.wasteBasket,\r\n                    onclick() {\r\n                      (async () => {\r\n                        let linked_CSS = this.parentElement.childNodes[0];\r\n                        linked_CSS.value = \"\";\r\n                        linked_CSS.storedCSS.content = linked_CSS.value;\r\n                        await assignTmpCss(linked_CSS.storedCSS.orgTag, fullUnparseCSS(linked_CSS.storedCSS));\r\n                        setCSSAreas();\r\n                      }) ();\r\n                    }\r\n                  }) : // inline style case\r\n                  el(\"div\", {\"class\": \"CSS-action-button\", \"title\": \"Delete this CSS snippet\"}, [], {\r\n                    innerHTML: editor.ui.icons.wasteBasket,\r\n                    onclick() {\r\n                      let linked_CSS = this.parentElement.childNodes[0];\r\n                      //console.log(this.parentElements.childNodes);\r\n                      linked_CSS.value = \"\";\r\n                      linked_CSS.storedCSS.content = linked_CSS.value;\r\n                      fullUnparseCSS(linked_CSS.storedCSS);\r\n                      setCSSAreas();\r\n                    }\r\n                  })\r\n              ]);\r\n              CSSarea.append(eachCSS);\r\n            }\r\n            })(); // Async css set.\r\n          } // function setCSSAreas()\r\n          setCSSAreas();   \r\n          return CSSarea;\r\n        }\r\n      });\r\n      editor.ui.model.interfaces.push({\r\n        title: \"Image Tools\",\r\n        minimized: true,\r\n        priority(editor_model) {\r\n          return this.enabled(editor_model) ? 1 : undefined; // It's likely we want to modify this image above all.\r\n        },\r\n        findURLS(styleStr) {\r\n          var urls = [];\r\n          var diffPics = styleStr.split(\",\");\r\n          for(let k in diffPics) {\r\n            //extracts only url(...)\r\n            let regex = new RegExp(\"(url\\\\([\\\"']?)([^\\\\)'\\\"]+?)([\\\"']?\\\\))\", \"g\");\r\n            let m;\r\n            let remainStr = diffPics[k];\r\n            while(m = regex.exec(remainStr)) {\r\n              let sIndex = m.index + m[1].length;\r\n              //extracting the rest of the string \r\n              let afterStr = remainStr.slice(sIndex + m[2].length);\r\n              let beforeStr = remainStr.slice(0, sIndex);\r\n              urls.push({remainderBefore: beforeStr, url: m[2], remainderAfter: afterStr});  \r\n            }\r\n          }\r\n          return urls;\r\n        },\r\n        //checks the inline CSS of the clicked node/element to see if background or background-image is a rule, and if \r\n        //a link to an image is provided as part of the value for this rule;\r\n        //TODO: expand the set of CSS being checked to any style tags as well.\r\n        checkForBackgroundImg(clickedElem, findURLS) {\r\n          function findText(parsed, startIndex, endIndex) { //for css + img replacement\r\n            let textSegment = \"\";\r\n            for(let i = startIndex; i < endIndex; i++) {\r\n              textSegment += parsed ? parsed[0].selector ? editor.ui.CSSparser.unparseCSS([parsed[i]]) :\r\n                (parsed[0].directive ? editor.ui.CSSparser.unparseRules([parsed[i]]) : \"\") : \"\";\r\n              //console.log(textSegment);\r\n            }\r\n            return textSegment;\r\n          }\r\n          //console.log(\"clicked element is:\", clickedElem);\r\n          //clickedElem ? console.log(clickedElem.getAttribute(\"style\")) : console.log(\"nothing clicked\");\r\n          var clickedStyle = clickedElem  && clickedElem.getAttribute ? editor.ui.CSSparser.parseRules(clickedElem.getAttribute(\"style\")) : []; \r\n          //console.log(clickedStyle);\r\n          //inefficient way of doing things, but since background takes precedence over background-image, we need to process the \r\n          //former first, if it contains a url. for now, I am looping through the CSS rules twice.\r\n          //console.log(\"^parsed rules \");\r\n          for(let i in clickedStyle) {\r\n            for(let j in clickedStyle[i]) {\r\n              if(clickedStyle[i][j].directive === \"background\") {\r\n                clickedStyle[i][j].value = findURLS(clickedStyle[i][j].value);  \r\n                if(clickedStyle[i][j].value.length) {\r\n                  //console.log(clickedStyle[i][j]);\r\n                  return {beforeCSS: findText(clickedStyle[i], 0, Number(j)), relCSS: clickedStyle[i][j], \r\n                    imageSelection: 0, afterCSS: findText(clickedStyle[i], Number(j) + 1, clickedStyle[i].length)};\r\n                }\r\n              }\r\n            }\r\n          }\r\n          for(let i in clickedStyle) {\r\n            for(let j in clickedStyle[i]) {\r\n              if(clickedStyle[i][j].directive === \"background-image\") {\r\n                //console.log(\"hello?\");\r\n                //console.log(clickedStyle[i][j].value);\r\n                clickedStyle[i][j].value = findURLS(clickedStyle[i][j].value);  \r\n                if(clickedStyle[i][j].value.length) {\r\n                  return {beforeCSS: findText(clickedStyle[i], 0, Number(j)), relCSS: clickedStyle[i][j], \r\n                    imageSelection: 0, afterCSS: findText(clickedStyle[i], Number(j) + 1, clickedStyle[i].length)};\r\n                }\r\n              }\r\n            }\r\n          } \r\n          //console.log(\"unsuccessful\");\r\n          return undefined;\r\n        },\r\n        enabled(editor_model) {\r\n          let clickedElem = editor_model.clickedElem;\r\n          if(typeof clickedElem === \"object\" && clickedElem.tagName === \"IMG\") return true;\r\n          if(!editor.ui.CSSparser) return false;\r\n          let backgroundImgSrc = this.checkForBackgroundImg(clickedElem, this.findURLS);\r\n          const do_img_rpl = (clickedElem && (clickedElem.tagName === \"IMG\" || backgroundImgSrc));\r\n          this.backgroundImgSrc = backgroundImgSrc;\r\n          return do_img_rpl;\r\n        },\r\n        \r\n        // enabled has been called before, clickedElem is not empty and it contains a background image\r\n        render: function render(editor_model, innerBox) {\r\n          if(!this.enabled(editor_model)) {\r\n            return \"Click an element with a background image.\";\r\n          }\r\n          //extract url and extraneous text from specified CSS value (which is originally part of a rule)\r\n          const clickedElem = editor_model.clickedElem;\r\n          let ret = el(\"div\", {\"class\": \"information\"});\r\n          if (!clickedElem) return ret;\r\n          let backgroundImgSrc = this.backgroundImgSrc;\r\n          //unparse the background/background-image object\r\n          function unparseBackgroundImg(backImgObj) {\r\n            var textSegment = \"\";\r\n            let valueText = \"\";\r\n            for(let i in backImgObj.relCSS.value) {\r\n              valueText += (Number(i) !== 0 ? \", \" : \"\") + backImgObj.relCSS.value[i].remainderBefore + backImgObj.relCSS.value[i].url + backImgObj.relCSS.value[i].remainderAfter;\r\n              //console.log(valueText);\r\n            }\r\n            //console.log(\"Object about to be unparsed:\");\r\n            //console.log(backImgObj);\r\n            return backImgObj.beforeCSS + findText([{...backImgObj.relCSS, value: valueText}], 0, 1) + backImgObj.afterCSS;\r\n          }\r\n          function uploadImagesAtCursor(files, srcName, backImgObj) {\r\n            for (var i = 0, file; file = files[i]; i++) {\r\n              var targetPathName =  editor.getStorageFolder(file) + file.name;\r\n              editor.uploadFile(targetPathName, file, (targetPathName, file) => {\r\n                if(backImgObj) {\r\n                  backImgObj.imageSelection = backImgObj.relCSS.value.length == 1 ? 0 : (() => {\r\n                    let radios = document.querySelectorAll(\".background-img-radio\");\r\n                    let defaultValue = 0;\r\n                    for (let i in radios) {\r\n                      //hopefully there aren't more than 10 images!\r\n                      if (radios[i].checked) defaultValue = Number(radios[i].getAttribute(\"value\").match(/[0-9]/g));\r\n                    }\r\n                    return defaultValue;\r\n                  })();\r\n                  backImgObj.relCSS.value[backImgObj.imageSelection].url = targetPathName;\r\n                  editor.userModifies(() => {\r\n                    clickedElem.setAttribute(\"style\", unparseBackgroundImg(backImgObj));\r\n                  });\r\n                }\r\n                else {\r\n                  let d = document.querySelector(\"#modify-menu #dom-attr-src\");\r\n                  if(d) { d.setAttribute(\"value\", file.name); }\r\n                  editor.userModifies(() => {\r\n                    clickedElem.setAttribute(\"src\", targetPathName);\r\n                  });\r\n                }\r\n                // adapt to HTML5 new attribute 'srcset'\r\n                // IF website use 'srcset', we force to set this attribute to null then replace image using 'src'\r\n                if (clickedElem.getAttribute(\"srcset\") != undefined) {\r\n                  editor.userModifies(() => {\r\n                    clickedElem.setAttribute(\"srcset\", \"\");\r\n                  });\r\n                }\r\n              });\r\n            }\r\n            // refresh images list\r\n            showListsImages(targetPathName);  // targetPathName is the last file of files array, but it seems that user can only upload one file once\r\n            // automatically select upload image\r\n            let selectedImage = document.querySelectorAll(\"div#modify-menu .imgFolder > img\");\r\n            for (let i = 0; i < selectedImage.length; ++i) {\r\n              let imgName = selectedImage[i].getAttribute(\"src\").split(\"/\").pop();\r\n              if (imgName === files[files.length - 1].name) {\r\n                selectedImage[i].parentElement.classList.add(\"highlight-select-image\");\r\n              } else {\r\n                selectedImage[i].parentElement.classList.remove(\"highlight-select-image\");\r\n              }\r\n            }\r\n          }\r\n          async function showListsImages(srcName, backImgObj, checkBackImgObj, findURLS) {\r\n            if (isAbsolute(srcName)) {\r\n              return;\r\n            }\r\n            console.log(\"Source name is:\", srcName);\r\n            srcName = relativeToAbsolute(srcName)\r\n            let dir = \"\";\r\n            for(let i = 0, arr = srcName.split(/\\\\|\\//); i < arr.length - 1; ++i) {\r\n              dir += (arr[i] + \"/\");\r\n            }\r\n            files = await editor.fs.listdir(dir);\r\n            \r\n            let images = [];\r\n            let currentSelectedImage;\r\n            files.forEach(file => {\r\n              let ext = file.split('.').pop().toLowerCase();\r\n              if (ext == 'jpeg' || ext == 'jpg' || ext == 'png' || ext == 'gif' || ext == 'svg' || ext == 'bmp') {\r\n                if (file.split('/').pop() === srcName.split(\"/\").pop().split(\"?\")[0]) {   // note that srcName maybe \"/1.jpg?raw=true\"\r\n                  currentSelectedImage = file;\r\n                } else {\r\n                  images.push(file);\r\n                }\r\n              }\r\n            });\r\n            // sometimes website use 'srcset' as the url of image, we cannot find currentSelectedImage precisely\r\n            if (currentSelectedImage != null) {\r\n              images.unshift(currentSelectedImage);   // currentSelectedImage should be placed as the first one\r\n            }\r\n\r\n            // init: clear image list\r\n            let selectedImage = document.querySelectorAll(\"#modify-menu .imgFolder\");\r\n            selectedImage.forEach(e => e.remove());\r\n\r\n            let imgDiv = el(\"div\", { \"id\": \"imgGallery\" });\r\n            if (!document.getElementById(\"imgGallery\")) {\r\n              ret.append(imgDiv);\r\n            } else {\r\n              imgDiv = document.getElementById(\"imgGallery\");\r\n            }\r\n\r\n            for (let i = 0; i < images.length; ++i) {\r\n              imgDiv.append(\r\n                el(\"div\", { \"class\": \"imgFolder\" }, el(\"img\", { \"src\": dir + images[i], \"title\": images[i], \"alt\": images[i] },  [], {}), {\r\n                  onclick() {\r\n                    //console.log(\"At the beginning:\");\r\n                    //console.log(JSON.stringify(backImgObj));\r\n                    // highlight the selected image\r\n                    let otherImages = document.querySelectorAll(\"#modify-menu .imgFolder\");\r\n                    console.log ({otherImages, document});\r\n                    for (let i = 0; i < otherImages.length; ++i) {\r\n                      otherImages[i].classList.remove(\"highlight-select-image\");\r\n                    }\r\n                    console.log (\"thru\");\r\n                    // replace image\r\n                    if(backImgObj) {\r\n                      backImgObj.imageSelection = (() => {\r\n                        let radios = document.querySelectorAll(\"#modify-menu .background-img-radio\");\r\n                        let defaultValue = 0;\r\n                        for (let i in radios) {\r\n                          //hopefully there aren't more than 10 images!\r\n                          if (radios[i].checked) defaultValue = Number(radios[i].getAttribute(\"value\").match(/[0-9]/g));\r\n                        }\r\n                        return defaultValue;\r\n                      })();\r\n                      //console.log(\"Here?\");\r\n                      //console.log(JSON.stringify(backImgObj));\r\n                      if(!(typeof backImgObj.relCSS.value === 'string')){\r\n                        //console.log(\"Here?\");\r\n                        //console.log(JSON.stringify(backImgObj));\r\n                        //console.log(backImgObj.relCSS.value.length);\r\n                        backImgObj.relCSS.value[backImgObj.imageSelection].url = this.children[0].getAttribute(\"src\");\r\n                      }\r\n                      else {\r\n                        console.log(\"Second time around:\");\r\n                        backImgObj = checkBackImgObj(clickedElem, findURLS);\r\n                        backImgObj.relCSS.value[backImgObj.imageSelection].url = this.children[0].getAttribute(\"src\");\r\n                      }\r\n                      //console.log(\"current link\", this.children[0].getAttribute(\"src\"));\r\n                      //console.log(\"current section number is:\", backImgObj.imageSelection);\r\n                      //console.log(\"current selection is:\", backImgObj.relCSS.value[backImgObj.imageSelection].url); \r\n                      editor.userModifies(() => {\r\n                        clickedElem.setAttribute(\"style\", unparseBackgroundImg(backImgObj));\r\n                      });\r\n                      //console.log(\"new style attribute is:\", clickedElem.getAttribute(\"style\"));\r\n\r\n                      console.log(JSON.stringify(backImgObj));\r\n\r\n                    }\r\n                    // adapt to HTML5 new attribute 'srcset'\r\n                    // IF website use 'srcset', we force to set this attribute to null then make image replacemenet\r\n                    else if (clickedElem.getAttribute(\"srcset\") != undefined) {\r\n                      editor.userModifies(() => {\r\n                        clickedElem.setAttribute(\"srcset\", \"\");\r\n                      });\r\n                    }\r\n                    else {\r\n                      editor.userModifies(() => {\r\n                        clickedElem.setAttribute(\"src\", this.children[0].getAttribute(\"src\"));\r\n                      document.querySelector(\"#modify-menu #dom-attr-src\").setAttribute(\"value\", this.children[0].getAttribute(\"src\"));\r\n                      });\r\n                    }\r\n                    // this.style.outline = \"2px solid white\";\r\n                    console.log (\"pre1\");\r\n                    this.classList.add(\"highlight-select-image\");\r\n                    console.log (\"post1\");\r\n                  }\r\n                })\r\n              );\r\n            }\r\n            if (currentSelectedImage != null) {\r\n              console.log (\"pre2\");\r\n              ret.querySelectorAll(\".imgFolder\")[0].classList.add(\"highlight-select-image\");\r\n              console.log (\"post2\");\r\n            }\r\n          \r\n          }\r\n          let srcName = backgroundImgSrc ? backgroundImgSrc.relCSS.value[0].url : clickedElem.getAttribute(\"src\");\r\n\r\n          //console.log(srcName);\r\n          //console.log(backgroundImgSrc.relCSS.value[0].url);\r\n          clickedElem.ondragover = function (e) {\r\n            e.preventDefault();\r\n          }\r\n          clickedElem.ondrop = function (e) {\r\n            // upload and replace the image \r\n            e.stopPropagation();\r\n            e.preventDefault();\r\n            var files = e.dataTransfer.files; // FileList object\r\n            if (files && files[0]) {\r\n              uploadImagesAtCursor(files, srcName, backgroundImgSrc);\r\n            }\r\n          }\r\n          // radio buttons for cases when there are two background images\r\n          if(backgroundImgSrc && backgroundImgSrc.relCSS.value.length > 1) {\r\n            for(let i in backgroundImgSrc.relCSS.value) {\r\n              ret.append(el(\"span\", {class: \"insertOption\"}, [\r\n                el(\"input\", {type: \"radio\", class: \"background-img-radio\", id: `radio${i}`, name: \"\", value: `Image {i}`}, [], {checked: Number(i) === 0}),\r\n                el(\"label\", {\"for\": \"radio${i}\"}, `Image {i}`)]),);\r\n            }         \r\n          }\r\n          // upload image button\r\n          ret.append(\r\n            el(\"a\", \r\n              { \"id\": \"upload-image-btn-a\" }, \r\n              el(\r\n                \"input\", {\"id\": \"upload-image-btn-input\", \"type\": \"file\", value: \"Please upload images...\"}, \r\n                [], \r\n                { onchange: function(evt) { uploadImagesAtCursor(evt.target.files, srcName, backgroundImgSrc); }}\r\n              ), \r\n              {}\r\n            )\r\n          );\r\n          if(srcName == undefined) {\r\n            ret.append(\r\n              el(\"button\", {}, \"Add src attribute\", {onclick: () => {\r\n                editor.userModifies(() => {\r\n                  clickedElem.setAttribute(\"src\", \"\");\r\n                });\r\n                editor.ui.refresh();\r\n              }}));\r\n          } else {\r\n            showListsImages(srcName, backgroundImgSrc, this.checkForBackgroundImg, this.findURLS);\r\n            // show lists of images in selected image's folder\r\n          }\r\n          return ret;\r\n        }\r\n      });\r\n      editor.ui.model.interfaces.push({\r\n        title: \"Text Editing\",\r\n        minimized: true,\r\n        priority(editor_model) {\r\n          return undefined;\r\n        },\r\n        enabled(editor_model) {\r\n          const clickedElem = editor_model.clickedElem;\r\n          if(!clickedElem) return false;\r\n          for(let i = 0; i < clickedElem.childNodes.length; i++) {\r\n            let node = clickedElem.childNodes[i];\r\n            if(node.nodeType === 3 && node.textContent.trim() !== \"\") {\r\n              return true;\r\n            }\r\n          }\r\n        },\r\n        render: function render(editor_model, innerBox) {\r\n          if(!this.enabled(editor_model)) {\r\n            delete editor.ui._internals.saveBetweenReloads[\"TextEditing\"];\r\n            return \"Click on an element that contains some text.\";\r\n          }\r\n          const clickedElem = editor_model.clickedElem;\r\n          //textarea textChildNodeContent\r\n          let ret = el(\"div\", {id: \"textChildNodeContentDiv\"}, []);\r\n          for(let i = 0; i < clickedElem.childNodes.length; i++) {\r\n            let node = clickedElem.childNodes[i];\r\n            if(node.nodeType === 3 && (node.textContent.trim() !== \"\" || node.textContent.trim() === \"\" && clickedElem.childNodes.length == 0)) { // Non-empty text nodes.\r\n              let txtAreaNode = el(\"textarea\", {class:\"textChildNodeContent\"},\r\n                [], {\r\n                  value: node.textContent,\r\n                  oninput: (node => function() { editor.userModifies(() => { node.textContent = this.value;}); })(node)\r\n                });\r\n              ret.append(txtAreaNode)\r\n              console.log(\"appending text area node\", txtAreaNode);\r\n            } else if(node.nodeType === 1) { // Make this a shortcut for the node\r\n              ret.append(\r\n                el(\"div.childrenSelector\", {}, \r\n                  el(\"div.childrenSelectorName\", {}, \"<\" + node.tagName + \">\"),\r\n                  {\r\n                    onclick: (node => () => {\r\n                      editor_model.clickedElem = node;\r\n                      editor.ui.refresh();\r\n                    })(node)\r\n                  }\r\n                )\r\n              )\r\n            }\r\n          }\r\n          \r\n          if(\"TextEditing\" in editor_model.restoredAfterReload) {\r\n            let restored = editor_model.restoredAfterReload[\"TextEditing\"];\r\n            //\r\n            console.log(\"restored\", restored);\r\n            console.log(\"ret.childNodes\", ret.childNodes);\r\n            setTimeout((ret => () => {\r\n              var tmp = ret;\r\n              while(tmp && tmp.tagName != \"BODY\") tmp = tmp.parentNode;\r\n              if(!tmp) return;\r\n              console.log(\"ret\", ret);\r\n              for(let i = 0; i < restored.length && i < ret.childNodes.length; i++) {\r\n                var child = ret.childNodes[i];\r\n                if(child.tagName === \"TEXTAREA\") {\r\n                  console.log(\"restoring selection on \", child);\r\n                  console.log(\"data \", restored[i]);\r\n                  child.scrollTop = restored[i].scrollTop;\r\n                  var minimum = Math.min(restored[i].selectionStart, restored[i].selectionEnd);\r\n                  var maximum = Math.max(restored[i].selectionStart, restored[i].selectionEnd);\r\n                  var direction = restored[i].selectionStart < restored[i].selectionEnd ? \"forward\" : \"backward\";\r\n                  if(restored[i].focus) {\r\n                    child.focus();\r\n                  }\r\n                  child.setSelectionRange(minimum, maximum, direction);\r\n                }\r\n              }\r\n              delete editor_model.restoredAfterReload[\"TextEditing\"];\r\n            })(ret), 0);\r\n          } else {\r\n            console.log(\"No restoration data\");\r\n          }\r\n          \r\n          editor.ui._internals.saveBetweenReloads[\"TextEditing\"] = (ret => () => {\r\n            let res = [];\r\n            for(let i = 0; i < ret.childNodes.length; i++) {\r\n              if(ret.childNodes[i].tagName === \"TEXTAREA\") {\r\n                res[i] = {\r\n                  scrollTop: ret.childNodes[i].scrollTop,\r\n                  selectionEnd: ret.childNodes[i].selectionStart,\r\n                  selectionStart: ret.childNodes[i].selectionEnd,\r\n                  focus: ret.childNodes[i] === document.activeElement\r\n                };\r\n              }\r\n            }\r\n            return res;\r\n          })(ret);\r\n          \r\n          return ret;\r\n        }\r\n      });\r\n      editor.ui.model.interfaces.push({\r\n        title: \"Create\",\r\n        minimized: true,\r\n        priority(editor_model) {\r\n          return editor_model.insertElement ? 1 : undefined;\r\n        },\r\n        enabled(editor_model) {\r\n          return editor_model.clickedElem;\r\n        },\r\n        render: function render(editor_model, innerBox) {\r\n          if(!this.enabled(editor_model)) {\r\n            return \"Click on an element to view insert options.\";\r\n          }\r\n          let ret = el(\"div\", {\"class\": \"information\"});\r\n          const clickedElem = editor_model.clickedElem;\r\n          if (!clickedElem) return ret;\r\n          ret.classList.add(\"insert-information-style\");\r\n          ret.classList.add(\"information-style\");\r\n          let insertOption = function(value, msg, checked, title) {\r\n            return el(\"span\", {class: \"insertOption\"}, [\r\n              el(\"input\", {type: \"radio\", id: \"radioInsert\" + value, name: \"insertionPlace\", value: value}, [], {checked: checked || false}),\r\n              el(\"label\", {\"for\": \"radioInsert\" + value, title: title}, msg)], {onclick: restoreCaretPosition});\r\n          }\r\n          let t = clickedElem.tagName;\r\n          let isHTML = t === \"HTML\";\r\n          let isTop = isHTML || t === \"BODY\" || t === \"HEAD\";\r\n          let caretBlinks = editor_model.caretPosition;\r\n          ret.append(el(\"div\", {id: \"insertionPlace\"}, [\r\n            isTop ? undefined : insertOption(\"before\", \"Before node\"),\r\n            isHTML ? undefined : insertOption(\"first-child\", \"As first child\"),\r\n            isHTML || !caretBlinks ? undefined : insertOption(\"caret\", \"At caret\", !isTop && caretBlinks),\r\n            isHTML ? undefined : insertOption(\"last-child\", \"As last child\", isTop || !caretBlinks),\r\n            isTop ? undefined : insertOption(\"after\", \"After node\"),\r\n            isTop ? undefined : insertOption(\"wrap\", \"Wrap node\", false, \"Put the selected node inside the newly inserted node\"),\r\n            clickedElem.childNodes && clickedElem.childNodes.length ? insertOption(\"wrap-children\", \"Wrap children\", false, \"Insert all node's children as children of element, then add element as a child.\") : undefined\r\n          ]));\r\n          let getInsertionPlace = () => {\r\n            let radios = document.querySelectorAll('#insertionPlace input[name=insertionPlace]');\r\n            let value = \"after\";\r\n            for (let i = 0, length = radios.length; i < length; i++) {\r\n              if (radios[i].checked) return radios[i].getAttribute(\"value\");\r\n              value = radios[i].getAttribute(\"value\");\r\n            }\r\n            return value;\r\n          };\r\n          let insertTag = function(event, newElement, insertionStyle) {\r\n            newElement = newElement || (() => {\r\n              let parent = this;\r\n              while(parent && !parent.classList.contains(\"tagName\")) parent = parent.parentElement;\r\n              let m = parent.querySelector(\".templateengine\");\r\n              if(typeof m.innerHTMLCreate === \"string\") return m.innerHTMLCreate;\r\n              return el(m.createParams.tag, m.createParams.attrs, m.createParams.children, m.createParams.props);\r\n            })();\r\n            editor.userModifies(() => {\r\n              if(insertionStyle === \"after\") {\r\n                if(typeof newElement === \"string\") {\r\n                  clickedElem.insertAdjacentHTML(\"afterend\", newElement);\r\n                  newElement = clickedElem.nextElementSibling;\r\n                } else {\r\n                  clickedElem.parentElement.insertBefore(newElement, clickedElem.nextSibling);\r\n                }\r\n              } else if(insertionStyle === \"before\") {\r\n                if(typeof newElement === \"string\") {\r\n                  clickedElem.insertAdjacentHTML(\"beforebegin\", newElement);\r\n                  newElement = clickedElem.previousElementSibling;\r\n                } else {\r\n                  clickedElem.parentElement.insertBefore(newElement, clickedElem);\r\n                }\r\n              } else if(insertionStyle === \"wrap\") {\r\n                if(typeof newElement === \"string\") {\r\n                  clickedElem.insertAdjacentHTML(\"beforebegin\", newElement);\r\n                  newElement = clickedElem.previousElementSibling;\r\n                } else {\r\n                  clickedElem.parentElement.insertBefore(newElement, clickedElem);\r\n                }\r\n                newElement.appendChild(clickedElem);\r\n                console.log(\"newElement's parent HTML\", newElement.parentElement.outerHTML);\r\n              } else if(insertionStyle === \"wrap-children\") {\r\n                if(typeof newElement === \"string\") {\r\n                  clickedElem.insertAdjacentHTML(\"afterbegin\", newElement);\r\n                  newElement = clickedElem.children[0];\r\n                } else {\r\n                  clickedElem.insertBefore(newElement, clickedElem.childNodes[0]);\r\n                }\r\n                while(newElement.nextSibling) {\r\n                  newElement.append(newElement.nextSibling);\r\n                }\r\n              } else if(insertionStyle === \"caret\") {\r\n                let s = editor_model.caretPosition;\r\n                let txt = s.startContainer;\r\n                if(txt.textContent.length > s.startOffset && s.startOffset > 0) { // split\r\n                  // Need to split the text node.\r\n                  txt.parentElement.insertBefore(document.createTextNode(txt.textContent.substring(s.startOffset)), txt.nextSibling);\r\n                  txt.textContent = txt.textContent.substring(0, s.startOffset);\r\n                }\r\n                if(typeof newElement === \"string\") {\r\n                  let tmpSpan = el(\"span\");\r\n                  clickedElem.insertBefore(tmpSpan, txt.nextSibling)\r\n                  tmpSpan.insertAdjacentHTML(\"afterend\", newElement);\r\n                  newElement = tmpSpan.nextElementSibling;\r\n                  tmpSpan.remove();\r\n                } else {\r\n                  clickedElem.insertBefore(newElement, txt.nextSibling)\r\n                }\r\n              } else if(insertionStyle === \"last-child\") { // Insert at the end of the selected element, inside.\r\n                if(typeof newElement === \"string\") {\r\n                  let tmpSpan = el(\"span\");\r\n                  clickedElem.insertBefore(tmpSpan, null);\r\n                  tmpSpan.insertAdjacentHTML(\"afterend\", newElement); // afterend or beforeend same, tmpSpan to be removed.\r\n                  newElement = tmpSpan.nextElementSibling;\r\n                  tmpSpan.remove();\r\n                } else {\r\n                  console.log(\"insert at the end\");\r\n                  // Insert at the end.\r\n                  clickedElem.insertBefore(newElement, null);\r\n                }\r\n              } else if(insertionStyle === \"first-child\") { // Insert at the end of the selected element, inside.\r\n                if(typeof newElement === \"string\") {\r\n                  let tmpSpan = el(\"span\");\r\n                  clickedElem.insertBefore(tmpSpan, clickedElem.children[0]);\r\n                  tmpSpan.insertAdjacentHTML(\"afterend\", newElement);// afterend or beforeend same, tmpSpan to be removed.\r\n                  newElement = tmpSpan.nextElementSibling;\r\n                  tmpSpan.remove();\r\n                } else {\r\n                  console.log(\"insert at the beginning\");\r\n                  // Insert at the beginning.\r\n                  clickedElem.prepend(newElement);\r\n                }\r\n              }\r\n            });\r\n            editor_model.insertElement = false;\r\n            editor_model.visible = true;\r\n            editor_model.clickedElem  = typeof newElement !== \"string\" && typeof newElement !== \"undefined\" ?\r\n              newElement : clickedElem;\r\n            editor.ui.refresh();\r\n          }\r\n          let addElem = function(name, createParams) {\r\n            ret.append(\r\n              el(\"div\", {\"class\": \"tagName\", title: createParams.title},\r\n                el(\"span\", { \"class\": \"templateengine\"}, name, {createParams: createParams}), {\r\n                    onclick: function(event) {\r\n                      let insertionStyle = getInsertionPlace();\r\n                      insertTag.call(this, event, undefined, insertionStyle);\r\n                  }}\r\n              )\r\n            );\r\n          }\r\n          if(clickedElem.tagName === \"HEAD\") {\r\n            addElem(\"Title\", {tag:\"title\", children: \"Page_title\", title: \"Insert <title>\"});\r\n            addElem(\"Meta\", {tag:\"meta\", attrs:{name:\"\", content: \"\"}, props: {}, title: \"Insert <meta>\"});\r\n            addElem(\"Link\", {tag:\"link\", attrs:{rel:\"\", href: \"\"}, props: {}, title: \"Insert <link>\"});\r\n          }\r\n          if(clickedElem.tagName !== \"HEAD\") {\r\n            ret.append(el(\"input\", {\"type\": \"file\", multiple: \"\", value: \"Images or files...\"}, [], {\r\n              onchange: function(evt) { editor.uploadFilesAtCursor(evt.target.files); }})\r\n            );\r\n            ret.append(\r\n              el(\"div\", {\"class\":\"modify-menu-icon\", id: \"selectExistingNodeToMove\", title: \"Select an existing node to move\"}, [], {\r\n                  innerHTML: editor.ui.icons.linkMode + \"<span>Move node</span>\",\r\n                  onclick: function(event) {\r\n                    editor_model.insertElement = false;\r\n                    let insertionStyle = getInsertionPlace();\r\n                    activateNodeSelectionMode(\r\n                      \"to move\",\r\n                      node => insertTag.call(this, event, node, insertionStyle),\r\n                      addPinnedModifyMenuIcon => {\r\n                        addPinnedModifyMenuIcon(editor.ui.icons.clone + \"<span class='modify-menu-icon-label-link'>Clone</span>\", \r\n                          {\"class\": \"link-select-button\", title: \"Confirm to clone\",\r\n                            id: \"selectbutton\"\r\n                          },\r\n                          {onclick: function(event) {\r\n                            let node = editor_model.clickedElem;\r\n                            let clonedNode = editor.duplicate(node, {ignoreText: true});\r\n                            insertTag.call(this, event, clonedNode, insertionStyle);\r\n                            escapeLinkMode();\r\n                            editor_model.clickedElem = clonedNode;\r\n                            }\r\n                          }\r\n                        );\r\n                      }\r\n                    )\r\n                  }\r\n                })\r\n            )\r\n            // TODO: Filter and sort which one we can add, also depending on where to insert.\r\n            addElem(\"List item\", {tag:\"li\", props: { innerHTML: \"<br>\" }, title: \"Insert <li>\"});\r\n            addElem(\"Bulleted list\", {tag:\"ul\", props: { innerHTML: \"<ul>\\n<li><br></li>\\n</ul>\" }, title: \"Insert <ul>\"});\r\n            addElem(\"Numbered list\", {tag:\"ol\", props: { innerHTML: \"<ol>\\n<li><br></li>\\n</ol>\" }, title: \"Insert <ol>\"});\r\n            addElem(\"Button\", {tag: \"button\", props: {innerHTML: \"Button name\" }, title: \"Insert <button>\"});\r\n            addElem(\"Link\", {tag: \"a\", props: { innerHTML: \"Link name\", href: \"\" }, title: \"Insert <a href=''>\"});\r\n            addElem(\"Paragraph\", {tag: \"p\", props: { innerHTML: \"Your text here\" }, title: \"Insert <p>\"});\r\n            addElem(\"Division content\", {tag: \"div\", title: \"Insert <div>\"});\r\n            addElem(\"Section\", {tag: \"section\", title: \"Insert <section>\"});\r\n            addElem(\"Image\", {tag: \"img\", title: \"Insert <img>\", attrs: {src: \"\"}});\r\n            addElem(\"Preformatted text\", {tag: \"pre\", title: \"Insert <pre>\"});\r\n            for(let i = 1; i <= 6; i++) {\r\n              addElem(\"Header \" + i, {tag:\"h\" + i, props: { innerHTML: \"Title\" + i }, title: \"Insert <h\"+i+\">\"});\r\n            }\r\n            addElem(\"Newline\", {tag: \"br\", title: \"Insert <br>\"});\r\n          }\r\n          addElem(\"Stylesheet\", {tag:\"style\", children: \"/*Your CSS there*/\", title: \"Insert <style>\"});\r\n          addElem(\"JavaScript\", {tag:\"script\", children: \"/*Your CSS below*/\", title: \"Insert <script>\"});\r\n\r\n          ret.append(\r\n            el(\"div\", {\"class\": \"tagName\", id: \"customHTML\"}, [\r\n              el(\"textarea\", {id: \"customHTMLToInsert\", placeholder: \"Custom HTML here...\", \"class\": \"templateengine\", oninput: \"this.innerHTMLCreate = this.value\"}),\r\n              el(\"div\", {\"class\":\"modify-menu-icon\", title: \"Insert HTML\", style: \"display: inline-block\"}, [], {\r\n                  innerHTML: editor.ui.icons.plus, \r\n                  onclick: function(event) {\r\n                      let insertionStyle = getInsertionPlace();\r\n                      insertTag.call(this, event, undefined, insertionStyle);\r\n                  }\r\n                }\r\n              )\r\n            ])\r\n          );\r\n          //document.querySelector(\"#modify-menu\").classList.toggle(\"visible\", true);\r\n          return ret;\r\n        }\r\n      });\r\n      if (editor.config.thaditor) {\r\n        editor.ui.model.interfaces.push({\r\n          title: \"Drafts\",\r\n          minimized: true,\r\n          priority(editor_model) {\r\n            return undefined;\r\n          },\r\n          enabled(editor_model) {\r\n            return true;\r\n          },\r\n          render: (editor_model, innerBox) => {\r\n            \r\n            let draftListDiv = el(\"div\", {\"class\":\"draftList\"}, [], {});\r\n\r\n            (async () => {\r\n            const verzExist = JSON.parse(await editor.getServer(\"isdir\", \"Thaditor/versions\"));\r\n\r\n            const get_switch_btn_for = (nm) => {\r\n              return el(\"button\", {\"class\":\"draft-switch\", title: \"Open version '\" + nm + \"'\"}, [nm], \r\n              {\r\n                onclick: (event) => {\r\n                  editor_model.version = nm;\r\n                  editor.navigateTo(\"/Thaditor/versions/\" + nm + \"/?edit\");\r\n                  setTimeout(() => editor.ui.sendNotification(\"Switched to \" + nm), 2000);\r\n                }\r\n              });\r\n            };\r\n\r\n            const get_switch_btn_live = () => {\r\n              return el(\"button\", {class:\"draft-switch-live draft-switch\"}, [\"Open live website\"],\r\n              {\r\n                onclick: (event) => {\r\n                  editor_model.version = \"Live\";\r\n                  editor.navigateTo(\"/?edit\");\r\n                  setTimeout(() => editor.ui.sendNotification(\"Switched to Live version\"), 2000);\r\n                }\r\n              })\r\n            }\r\n\r\n            const get_clone_btn_for = (nm) => {\r\n              return el(\"button\", {\"class\":\"draft-clone\", title: \"Clone \" + nm + \" to a new version\"}, [\"Clone\"],\r\n              {\r\n                onclick: (event) => {\r\n                  cloneSite(nm, verzExist); //confirms + sends notif inside method\r\n                }\r\n              })  \r\n            }\r\n\r\n            const get_delete_btn_for = (nm) => {\r\n              return el(\"button\", {\"class\":\"draft-delete\", title: \"Delete version \" + nm}, [\"Delete\"],\r\n              {\r\n                onclick: (event) => {\r\n                  deleteDraft(nm); //confirms + sends notif inside the method\r\n                }\r\n              })  \r\n            }\r\n\r\n            const get_rename_btn_for = (nm) => {\r\n              return el(\"button\", {\"class\":\"draft-publish\", title: \"Rename \" + nm}, [\"Rename\"],\r\n              {\r\n                onclick: (event) => { \r\n                  renameDraft(nm, verzExist); //confirms + sends notif inside\r\n                }\r\n              })\r\n            }\r\n\r\n            const get_publish_btn_for = (nm) => {\r\n              return el(\"button\", {\"class\":\"draft-publish\", title: \"Publish \" + nm + \" to live\"}, [\"Publish\"],\r\n              {\r\n                onclick: (event) => { \r\n                  publishDraft(nm); //confirms + sends notif inside\r\n                }\r\n              })\r\n            };\r\n\r\n            const get_current_label = () => {\r\n              return el(\"div\", {\"class\":\"draft-row\", \"id\": \"draft-title\"},\r\n                      [\r\n                        el(\"label\", {}, [editor_model.version], {}),\r\n                        (isLive() ? el(\"label\", {}, [\"\"]) : get_rename_btn_for(editor_model.version)),\r\n                        get_clone_btn_for(editor_model.version),\r\n                        (isLive() ? el(\"label\", {}, [\"Can't delete live\"]):\r\n                                                          el(\"button\", {}, [\"Delete\"],\r\n                                                          {\r\n                                                            onclick: (event) => {\r\n                                                              deleteDraft(editor_model.version);\r\n                                                            }\r\n                                                          })),\r\n\r\n                      ],\r\n                      {\r\n                        onclick: (event) => {\r\n                          //pass\r\n                        },\r\n                      })\r\n            };\r\n\r\n            const get_current_label_live = () => {\r\n              return el(\"div\", {\"class\":\"draft-row\", \"id\": \"draft-title\"},\r\n                      [\r\n                        el(\"label\", {style:\"font-style:italic\"}, [\"Currently viewing live website\"], {}),\r\n                        get_clone_btn_for(\"Live\"),\r\n                        \r\n\r\n                      ],\r\n                      {\r\n                        onclick: (event) => {\r\n                          //pass\r\n                        },\r\n                      })\r\n            };\r\n\r\n            const get_current_label_for = (nm) => {\r\n              return el(\"div\", {\"class\":\"draft-row\", \"id\": \"draft-title\"},\r\n                      [\r\n                        el(\"label\", {title: \"Currently viewing \" + nm + \" version\"}, [nm], {}),\r\n                        get_rename_btn_for(editor_model.version),\r\n                        get_clone_btn_for(nm),\r\n                        get_delete_btn_for(nm),\r\n                        get_publish_btn_for(nm),\r\n                      ],\r\n                      {\r\n                        onclick: (event) => {\r\n                          //pass\r\n                        },\r\n                      })\r\n            };\r\n            \r\n\r\n            const get_row_for_draft = (nm) => {\r\n              return el(\"div\", {\"class\": \"draft-row\"},\r\n              [\r\n                get_switch_btn_for(nm),\r\n                get_rename_btn_for(nm),\r\n                get_clone_btn_for(nm),\r\n                get_delete_btn_for(nm),\r\n              ]);\r\n            };\r\n\r\n            const get_row_for_live = () => {\r\n              return el(\"div\", {\"class\": \"draft-row\", \"id\": \"draft-row-live\"},\r\n              [\r\n                get_switch_btn_live(),\r\n                get_clone_btn_for(\"Live\")\r\n              ])\r\n            }\r\n\r\n            if (isLive()) {\r\n              draftListDiv.append(get_current_label_live());\r\n            } else {\r\n              draftListDiv.append(get_current_label_for(editor_model.version));\r\n              draftListDiv.append(get_row_for_live());\r\n            }\r\n            if (verzExist) {\r\n              const vers = JSON.parse(await editor.getServer(\"listdir\", \"Thaditor/versions/\"));\r\n              vers.forEach(ver => {\r\n                if (!(ver == editor_model.version)){\r\n                  draftListDiv.append(get_row_for_draft(ver));\r\n                }\r\n              });\r\n            }\r\n            })();\r\n            return draftListDiv;\r\n          }\r\n        });\r\n      } // End of if apache_server\r\n      \r\n      editor.ui.model.interfaces.push({\r\n        title: \"SEO\",\r\n        minimized: true,\r\n        priority(editor_model) {\r\n          if(!document.querySelector(\"meta[name=viewport]\")) {\r\n            return 1;\r\n          }\r\n          return undefined;\r\n        },\r\n        enabled(editor_model) {\r\n          return true;\r\n        },\r\n        render: function render(editor_model, innerBox) {\r\n          function oneClickFix(msg, buttonName, callback, parameters) {\r\n            return el(\"div\", {class:\"seo-fix\"}, [\r\n              el(\"p\", {class:\"seo-fix-description\"}, msg),\r\n              parameters,\r\n              el(\"button.action-button\", {type: \"\"}, buttonName, {\r\n                onclick: function() {\r\n                  callback();\r\n                  editor.ui.refresh();\r\n                }\r\n              })]);\r\n          }\r\n          let title = document.querySelector(\"head > title\");\r\n          let description = document.querySelector(\"head > meta[name=description]\")\r\n          let ret = el(\"div\", {}, [\r\n            document.querySelector(\"head > meta[name=viewport]\") ? undefined :\r\n            oneClickFix(\"Viewport not set on this page. This might make this page not display properly on mobile devices.\",\r\n              \"Add missing <meta name='viewport'...>\", () => \r\n                editor.userModifies(() => \r\n                  document.head.appendChild(el(\"meta\", {name: \"viewport\", content:\"width=device-width, initial-scale=1.0\"})))),\r\n            document.querySelector(\"head > meta[charset]\") ? undefined :\r\n            oneClickFix(\"Character encoding not set on this page. The display of non-breaking spaces would be compromized on many browsers.\", \"Add missing <meta charset='UTF-8'>\", () =>\r\n                  editor.userModifies(() => {\r\n                  document.head.insertBefore(el(\"meta\", {charset: \"UTF-8\" }), document.head.childNodes[0])})),\r\n            el(\"div\", {class:\"seo-fix\"}, [\r\n              el(\"p\", {class:\"seo-fix-description\"}, !title ?\r\n                \"Page title not set. Search engines do prefer a title.\" :\r\n                \"Title of the page:\"\r\n              ),\r\n              el(\"input\", {type:\"text\", value: title ? title.textContent : \"\", placeholder: \"Title of the page\"}, [], {\r\n                onchange: function() {\r\n                  editor.userModifies(() => {\r\n                    if(!title) {\r\n                      title = el(\"title\");\r\n                      document.head.appendChild(title);\r\n                    }\r\n                    title.textContent = this.value;\r\n                  });\r\n                }\r\n              })\r\n            ]),\r\n            el(\"div\", {class:\"seo-fix\"}, [\r\n              el(\"p\", {class:\"seo-fix-description\"}, !description ?\r\n                \"Page description not set. Search engines do prefer a page description to show on their results.\" :\r\n                \"Description of the page:\"\r\n              ),\r\n              el(\"textarea\", {type:\"text\", class: \"textChildNodeContent\", placeholder: \"Description of the page\"}, [], {\r\n                onchange: function() {\r\n                  editor.userModifies(() => {\r\n                    if(!description) {\r\n                      description = el(\"meta\", {name: \"description\"});\r\n                      document.head.appendChild(description);\r\n                    }\r\n                    description.setAttribute(\"content\") = this.value;\r\n                  });\r\n                },\r\n                value: description ? description.getAttribute(\"content\") || \"\" : \"\"\r\n              })\r\n            ]),\r\n          ]);\r\n          return ret;\r\n        }\r\n      });\r\n      editor.ui.model.interfaces.push({ \r\n        title: \"Advanced\",\r\n        minimized: true,\r\n        priority(editor_model) {\r\n          return editor_model.disambiguationMenu ? 0 : undefined;\r\n        },\r\n        enabled(editor_model) {\r\n          return true;\r\n        },\r\n        render: function render(editor_model, innerBox) {\r\n          let retDiv = el(\"div\", {\"class\":\"modify-menu-icons\"});\r\n          //We need 3 btns: refresh, filesystem + help.\r\n          add_btn_to_div(retDiv, editor.ui.icons.reload,\r\n            {\"class\": \"tagName\", title: \"Reload the current page\"},\r\n              {onclick: function(event) {\r\n                if(editor.confirmLeaving()) {\r\n                  editor.reload();\r\n                }\r\n              } }\r\n            );\r\n          add_btn_to_div(retDiv, editor.ui.icons.folder,\r\n            {\"class\": \"tagName\", title: \"List files in current directory\"},\r\n              {onclick: function(event) {\r\n                let u =  new URL(location.href);\r\n                u.pathname = u.pathname.replace(/[^\\/]*$/, \"\");\r\n                u.searchParams.set(\"ls\", \"true\");\r\n                if(editor.confirmLeaving()) {\r\n                  editor.navigateTo(u.href);\r\n                }\r\n              }\r\n            }\r\n          );\r\n          if(editor.config.thaditor) {\r\n            retDiv.append(\r\n              el(\"button.action-button#update-thaditor-btn\", {type: \"\"}, \"Update Thaditor\", {onclick() {\r\n                if(confirm(\"Are you ready to upgrade Thaditor?\")) {\r\n                  editor._internals.doWriteServer(\"updateversion\", \"latest\", \"\", response => {\r\n                    console.log(\"Result from Updating Thaditor to latest:\");\r\n                    console.log(response);\r\n                    if(response.endsWith(\"Done.\")) {\r\n                      location.reload(true);\r\n                    } else {\r\n                      alert(\"Update failed. Please navigate to /ThaditorInstaller.php and re-install Thaditor. You will not loose any drafts.\");\r\n                    }\r\n                  });\r\n                }\r\n              } })\r\n            );\r\n          }\r\n          retDiv.append(\r\n            el(\"label\", {class:\"switch\", title: \"If off, ambiguities are resolved automatically. Does not apply for HTML pages\"},\r\n              [el(\"input\", {class: \"global-setting\", id: \"input-question\", type: \"checkbox\"}, [], {\r\n                onchange: function() { editor_model.askQuestions = this.checked; },\r\n                checked: editor_model.askQuestions}),\r\n              el(\"span\", {class:\"slider round\"})]));\r\n          retDiv.append(\r\n            el(\"label\", {\"for\": \"input-question\", class: \"label-checkbox\"}, \"Ask questions\"));\r\n          \r\n          retDiv.append(\r\n            el(\"label\", {class:\"switch\", title: \"If on, changes are automatically propagated 1 second after the last edit\"}, [\r\n              el(\"input\", {class: \"global-setting\", id: \"input-autosave\", type:\"checkbox\"}, [], {\r\n                onchange: function() { editor_model.autosave = this.checked; },\r\n              checked: editor_model.autosave}),\r\n              el(\"span\", {class:\"slider round\"})])\r\n          );\r\n          retDiv.append(\r\n            el(\"label\", {\"for\": \"input-autosave\", class: \"label-checkbox\"}, \"Auto-save\"));\r\n          \r\n          if(editor.config.thaditor) {\r\n            retDiv.append(\r\n              el(\"a\", {href:\"javascript:0\", id:\"thaditor-sign-out-button\", style:\"display:block\"}, \"Sign out of Google\", {\r\n                onclick() {\r\n                  let onOk = () => thaditor_sign_out(() => {\r\n                    retDiv.append(\r\n                      el(\"a\", {href:\"javascript:0\", id:\"thaditor-google-log-in-button\", style:\"display:block\"}, \"Sign in with Google\",\r\n                      {onclick: thaditor_sign_in()}));\r\n                    document.querySelector(\"#thaditor-sign-out-button\").remove();\r\n                  });\r\n                  if(!gapi.auth2) {\r\n                    thaditor_gapi_onload(onOk);\r\n                  } else {\r\n                    onOk();\r\n                  }\r\n                }})\r\n            );\r\n          }\r\n          if(editor_model.disambiguationMenu) {\r\n            retDiv.append(editor_model.disambiguationMenu);\r\n          }\r\n          return retDiv;\r\n        }\r\n      });\r\n      \r\n      editor.ui.model.interfaces.push({\r\n        title: \"Log\",\r\n        minimized: true,\r\n        priority(editor_model) {\r\n          return undefined;\r\n        },\r\n        enabled(editor_model) {\r\n          return true;\r\n        },\r\n        currentBox: undefined,\r\n        render: function render(editor_model, innerBox) {\r\n          let retDiv = el(\"div#fullLog\", {\"class\":\"modify-menu-icons\"});\r\n          let logtxt = \"\";\r\n          const elog = editor_model.editor_log;\r\n          for (let i = 0; i < elog.length; i++) {\r\n            const l = elog[i];\r\n            logtxt = logtxt + (i > 0 ? \"<br>\" : \"\") + l;\r\n          }\r\n          retDiv.innerHTML = logtxt;\r\n          this.currentBox = retDiv;\r\n          return retDiv;\r\n        },\r\n        refresh() {\r\n          let currentBox = this.currentBox;\r\n          let newBox = this.render(editor.ui.model);\r\n          currentBox.parentNode.insertBefore(newBox, currentBox);\r\n          currentBox.remove();\r\n        }\r\n      });\r\n      if(typeof thaditor !== \"undefined\" && thaditor.customInterfaces) {\r\n        editor.ui.model.interfaces.push(...thaditor.customInterfaces);\r\n      }\r\n    }\r\n    \r\n    function getEditorInterfaceByTitle(title) {\r\n      return editor.ui.model.interfaces.find(x => x.title == title);\r\n    }\r\n \r\n    // First time: We add the interface containers.\r\n    if(!ifAlreadyRunning) {\r\n      init_interfaces();\r\n    }\r\n    \r\n    //if no ID, tag/name, or class (if h1, h2, etc..., probably fine)\r\n    //split between common (section, div, span, p, ul,  etc...) and rare/better semantically defined tags (pre)\r\n    //check if selector applies to any ancestors or descendants, then its ok\r\n    //else add class or use > selector until it is precise \r\n    function getShortestUniqueSelector(clickedElem) {\r\n      console.log(\"clickedElem\", clickedElem);\r\n      let curSelector = getSelectorOf(clickedElem);\r\n      //checking ancestors\r\n      let consideredParent = clickedElem.parentNode;\r\n      do {\r\n        var selectorIsOrg = true;\r\n        for(let curAncestor = clickedElem.parentNode; curAncestor; curAncestor = curAncestor.parentNode) {\r\n          if(editor.matches(curAncestor, curSelector)) {\r\n            selectorIsOrg = false;\r\n          }\r\n        }\r\n        //checking descendants\r\n        if(clickedElem.querySelector(curSelector)) {\r\n          selectorIsOrg = false;\r\n        }\r\n        if(!selectorIsOrg) {\r\n          curSelector =  consideredParent.tagName.toLowerCase() + \" > \" + curSelector; \r\n          consideredParent = consideredParent.parentNode;\r\n        }\r\n      } while(!selectorIsOrg && consideredParent);\r\n      return curSelector;\r\n    }\r\n    \r\n\r\n    function reorderCompatible(node1, node2){\r\n      let topLevelOrderableTags = {TABLE:1, P:1, LI:1, UL:1, OL:1, H1:1, H2:1, H3:1, H4:1, H5:1, H6:1, DIV:1, SECTION: 1, IMG: 1, PRE: 1};\r\n      let metaOrderableTags = {META:1, TITLE:1, SCRIPT: 1, LINK: 1, STYLE: 1};\r\n      return node1.tagName === node2.tagName && node1.tagName !== \"TD\" && node1.tagName !== \"TH\" ||\r\n        topLevelOrderableTags[node1.tagName] && topLevelOrderableTags[node2.tagName] ||\r\n        metaOrderableTags[node1.tagName] && metaOrderableTags[node2.tagName];\r\n    }\r\n    function preventTextDeselection(e){\r\n      e = e || window.event;\r\n      e.preventDefault();\r\n    }\r\n    function restoreCaretPosition() {\r\n      if(typeof editor_model.caretPosition != \"undefined\") {\r\n        var sel = window.getSelection();\r\n        sel.removeAllRanges();\r\n        var range = document.createRange();\r\n        range.setStart(editor_model.caretPosition.startContainer, editor_model.caretPosition.startOffset);\r\n        range.setEnd(editor_model.caretPosition.endContainer, editor_model.caretPosition.endOffset);\r\n        sel.addRange(range);\r\n      }\r\n    }\r\n    // This function activates the node selection mode, in which one DOM node can be selected,\r\n    // After clicking on confirm, the callback is called with the selected node.\r\n    // callbackUI is invoked to render other buttons along with the confirmation button.\r\n    function activateNodeSelectionMode(msg, callback, callbackUI) {\r\n      editor_model.visible = false;\r\n      \r\n      editor_model.linkSelectMode = true;\r\n      editor_model.clickedElem = document.body; //\"center\" clicked element on document body\r\n      //removes all context menu stuff \r\n      document.querySelector(\"#context-menu\").classList.remove(\"visible\");\r\n      editor_model.linkSelectCallback = callback;\r\n      editor_model.linkSelectMsg = \"Confirm \" + msg;\r\n      editor_model.linkSelectOtherMenus = callbackUI;\r\n      editor.ui.refresh();\r\n      editor.ui.sendNotification(editor_model.linkSelectMsg);\r\n      document.body.addEventListener('mouseover', linkModeHover1, false);\r\n      document.body.addEventListener('mouseout', linkModeHover2, false);\r\n    }\r\n\r\n    \r\n\r\n    function copy_website(source, dest) {\r\n      let website_files = JSON.parse(editor._internals.doReadServer(\"fullListDir\", source));\r\n      let is_dest_valid = editor._internals.doReadServer(\"isdir\", dest)\r\n      if (!website_files) throw \"copy_website(): invalid source\";\r\n      if (!is_dest_valid) throw \"copy_website(): invalid dest\";\r\n      \r\n      //filter out Thaditor files\r\n      website_files = website_files.filter(val => !thaditor_files.includes(val[0]));\r\n      website_files = website_files.filter(val => val[0][0] != \".\");\r\n      //cpy website_files to to dest\r\n      website_files.forEach(val => {\r\n        let [nm, isdir] = val;\r\n        const s = (source + nm);\r\n        const d = (dest + nm);\r\n        if (isdir) {\r\n          editor._internals.doWriteServer(\"fullCopy\", s, d);\r\n        } else {\r\n          editor._internals.doWriteServer(\"copy\", d, s);\r\n        }\r\n      });\r\n      let dh = editor._internals.doReadServer(\"read\", source + \"/.thaditor_meta\");\r\n      let draft_history = (dh == \"\" ? undefined : JSON.parse(dh));\r\n      const get_date_meta = () => (new Date).toString();\r\n      if (draft_history == undefined) {\r\n        draft_history = [\"live:\" + get_date_meta()];\r\n      } else {\r\n        draft_history.push(editor_model.version + \":\" + get_date_meta());\r\n      }\r\n      editor._internals.doWriteServer(\"write\", dest + \"/.thaditor_meta\", JSON.stringify(draft_history));\r\n      return 1;\r\n    }\r\n    \r\n    function deleteDraftDef(nm) { //definitely delete the draft, without a prompt\r\n      //the path of the folder we want to delete is and always will be Thaditor/versions/$nm/\r\n      const pth_to_delete = \"Thaditor/versions/\" + nm + \"/\";\r\n      //here we want to hand editor._internals.doWriteServer to the worker in editor.js\r\n\r\n      const data = {action:\"drafts\",\r\n                    subaction:\"deletermrf\",\r\n                    pth_to_delete:pth_to_delete,\r\n                    nm:nm, thaditor_files:thaditor_files, version:editor_model.version};\r\n      if (editor_model.version == nm) {\r\n        editor._internals.doWriteServer(\"deletermrf\", pth_to_delete);\r\n        editor.navigateTo(\"/?edit\");\r\n        editor.ui.refresh();\r\n      } else {\r\n        thaditor.do(data).then(data => {\r\n          editor.ui.sendNotification(\"Permanently deleted draft named: \" + data.nm);\r\n          editor.ui.refresh()});\r\n      }\r\n    }\r\n\r\n    function deleteDraft(nm) {\r\n      if (nm == \"Live\") throw \"Shouldn't be able to call deleteDraft on live\";\r\n      const ans = window.confirm(\"Are you sure you want to permanently delete \" + nm + \"?\");\r\n      if (!ans) return;\r\n      deleteDraftDef(nm);\r\n    }\r\n\r\n\r\n    function getNewDraftName(nm, verzExist) {\r\n      const draft_name = window.prompt (\"Please provide the name for the new draft. Leave blank to cancel\");\r\n      if (!draft_name) {\r\n        return 0;\r\n      }\r\n      \r\n      let is_draft_name_valid = (nm) => {\r\n        return !(nm.startsWith(\"[^a-zA-Z0-9]\"));\r\n      };\r\n\r\n      if (!is_draft_name_valid(draft_name)) {\r\n        window.alert(\"Invalid draft name\");\r\n        return 0;\r\n      }\r\n      \r\n      let fail = false;\r\n      if (!verzExist) {\r\n        editor._internals.doWriteServer(\"mkdir\", \"Thaditor/versions\");\r\n      } else {\r\n        let versionsList = JSON.parse(editor._internals.doReadServer(\"fullListDir\", \"Thaditor/versions/\"));\r\n        versionsList.forEach(val => {\r\n          let [nm, isdir] = val;\r\n          if (isdir) {\r\n            if (nm == draft_name) {\r\n              fail = window.confirm(\"Overwrite existing draft?\");\r\n            }\r\n          }\r\n        });\r\n      }\r\n      if (fail) return 0;\r\n      return draft_name;\r\n    }\r\n\r\n\r\n    function cloneSite(nm, verzExist) {\r\n      //verzExist tells us if we need to mkdir versions\r\n      //nm could be live or any draft ==> make f_pth\r\n      const draft_name = getNewDraftName(nm, verzExist);\r\n      if (!draft_name) return 0;\r\n      //all of that above ^^ needs to happen in the UI thread.\r\n      const t_pth = \"Thaditor/versions/\" + draft_name + \"/\"\r\n      const f_pth = (nm == \"Live\" ? \"\" : \"Thaditor/versions/\" + nm + \"/\");\r\n      const data = {action:\"drafts\", subaction:\"clone\",\r\n                    draft_name:draft_name,\r\n                    t_pth:t_pth, f_pth:f_pth,\r\n                    nm:nm,thaditor_files:thaditor_files,version:editor_model.version};\r\n      editor.ui.sendNotification(\"Creating draft \" + draft_name + \" from \" + nm);\r\n      thaditor.do(data).then(data => {\r\n        //just send a notif, no more naving to the clone\r\n        editor.ui.refresh();\r\n        editor.ui.sendNotification(\"Successfully cloned \" + data.nm + \" to \" + data.draft_name);\r\n      });\r\n    }\r\n    \r\n    function renameDraft(nm, verzExist) {\r\n      //verzExist tells us if we need to mkdir versions\r\n      //nm could be live or any draft ==> make f_pth\r\n      const draft_name = getNewDraftName(nm, verzExist);\r\n      if (!draft_name) return 0;\r\n      //all of that above ^^ needs to happen in the UI thread.\r\n      const t_pth = \"Thaditor/versions/\" + draft_name + \"/\"\r\n      const f_pth = (nm == \"Live\" ? \"\" : \"Thaditor/versions/\" + nm + \"/\");\r\n      const data = {action:\"drafts\", subaction:\"rename\",\r\n                    draft_name:draft_name,\r\n                    t_pth:t_pth, f_pth:f_pth,\r\n                    nm:nm,thaditor_files:thaditor_files,version:editor_model.version};\r\n      editor.ui.sendNotification(\"Renaming draft \" + nm + \" to \" + draft_name);\r\n      thaditor.do(data).then(data => {\r\n        let marker = false;\r\n        if (data.nm == data.version) {\r\n          editor.navigateTo(\"/Thaditor/versions/\" + data.draft_name + \"/?edit\");\r\n          marker = true;\r\n        }\r\n        if(marker) {\r\n          setTimeout(editor.ui.sendNotification(\"Successfully renamed \" + data.nm + \" to \" + data.draft_name), 2000)\r\n        } else {\r\n          editor.ui.refresh();\r\n          editor.ui.sendNotification(\"Successfully renamed \" + data.nm + \" to \" + data.draft_name);\r\n        }\r\n      });\r\n    }\r\n\r\n    function publishDraft(nm) {\r\n      //We're copying out Thaditor/versions/$nm/ to \"\".\r\n      if (nm == \"Live\") throw \"Can't publish live to live\";\r\n      const conf = window.confirm(\"Are you sure you want to publish \" + nm + \" to live?\");\r\n      if (!conf) {\r\n        return;\r\n      }\r\n      let t_src = \"Thaditor/versions/\" + nm + \"/\";\r\n      const data = {action:\"drafts\",\r\n                    subaction:\"publish\",\r\n                    t_src:t_src,\r\n                    nm:nm,thaditor_files:thaditor_files,\r\n                    version:editor_model.version};\r\n      thaditor.do(data).then(data => {\r\n        editor.ui.sendNotification(\"Successfully published \" + data.nm + \" to live.\");\r\n      });\r\n    }\r\n    \r\n    editor.ui.refresh = function refresh() {\r\n      const menuholder = document.querySelector(\"#modify-menu-holder\");\r\n      const old_scroll = menuholder ? menuholder.scrollTop : 0;\r\n      \r\n      // Set up\r\n      let editor_model = editor.ui.model;\r\n      var clickedElem = editor_model.clickedElem;\r\n      var contextMenu = document.querySelector(\"#context-menu\");\r\n      var modifyMenuDiv = document.querySelector(\"#modify-menu\");\r\n      \r\n      if(!modifyMenuDiv || !contextMenu) { // After some reloading, none of them might exist.\r\n        editor.ui.init();\r\n        contextMenu = document.querySelector(\"#context-menu\");\r\n        modifyMenuDiv = document.querySelector(\"#modify-menu\");\r\n      }\r\n      modifyMenuDiv.classList.toggle(\"editor-interface\", true);\r\n      contextMenu.classList.toggle(\"editor-interface\", true);\r\n\r\n      // Display the interface or not\r\n      modifyMenuDiv.classList.toggle(\"visible\", editor_model.visible); //Mikael what does this do? -B\r\n\r\n      // Make sure at most one element is marked as ghost-clicked.\r\n      document.querySelectorAll(\"[ghost-clicked=true]\").forEach(e => e.removeAttribute(\"ghost-clicked\"));\r\n      if(clickedElem && clickedElem.nodeType === 1) {\r\n        clickedElem.setAttribute(\"ghost-clicked\", \"true\");\r\n      }\r\n      \r\n      // Recover selection if it exists\r\n      editor_model.selectionRange = editor_model.notextselection ? undefined : (() => {\r\n        let selection = window.getSelection();\r\n        if(!selection || !selection.rangeCount) return;\r\n        let f = selection.getRangeAt(0); \r\n        if(!f || !f.getBoundingClientRect ||\r\n            f.startOffset === f.endOffset && f.startContainer === f.endContainer) return;\r\n        return f;\r\n      })();\r\n      \r\n      // Recover caret position if it exists\r\n      editor_model.caretPosition = editor_model.notextselection || clickedElem && clickedElem.tagName === \"HEAD\" ? undefined : (() => {\r\n        let selection = window.getSelection();\r\n        if(!selection || !selection.rangeCount) return;\r\n        let f = selection.getRangeAt(0);\r\n        if(!f || f.startOffset !== f.endOffset && f.startContainer !== f.endContainer) return;\r\n        return f;\r\n      })();\r\n      \r\n      // We render the content of modifyMenuDiv from scratch\r\n      modifyMenuDiv.innerHTML = \"\";\r\n      let modifyMenuPinnedIconsDiv = el(\"div\", {\"class\":\"modify-menu-icons pinned\"}); // Icons always visible\r\n      let modifyMenuIconsDiv = el(\"div\", {\"class\":\"modify-menu-icons\"}); // Top-level icons on the top bar\r\n      let domSelector = el(\"div\", {\"class\": \"dom-selector noselect\"}); // create dom selector interface\r\n      let modifyMenuHolder = el(\"div\", {\"class\": \"modify-menu-holder\", \"id\":\"modify-menu-holder\"});\r\n      modifyMenuDiv.append(modifyMenuPinnedIconsDiv); // Keep this one as it.\r\n      \r\n      /*\r\n        Render interfaces / containers\r\n      */\r\n      for(let i = 1; i < editor_model.interfaces.length; i++) {\r\n        let x = editor_model.interfaces[i];\r\n        let priority = x.priority(editor_model);\r\n        if(i > 0 && typeof priority === \"number\") {\r\n          x.minimized = false;\r\n          let previous = editor_model.interfaces[i-1]\r\n          let beforePriority = previous.priority(editor_model);\r\n          if(typeof beforePriority === \"undefined\" && (!previous.enabled(editor_model) || previous.minimized)) {\r\n            var tmp = editor_model.interfaces[i];\r\n            editor_model.interfaces[i] = editor_model.interfaces[i-1];\r\n            editor_model.interfaces[i-1] = tmp;\r\n            i -= 2; // Bubble up\r\n          }\r\n        }\r\n      }\r\n      for(let i = 0; i < editor_model.interfaces.length; i++) {\r\n        let x = editor_model.interfaces[i];\r\n        let priority = x.priority(editor_model);\r\n        let initMinimized = typeof priority == \"number\" ? false :\r\n                            x.enabled(editor_model) ? x.minimized : true;\r\n        let renderedContent = x.render(editor_model);\r\n        let class_str = x.title.replace(\" \", \"_\");\r\n        let menu = el(\r\n          \"div\", {\r\n            class:\"editor-container\" + (x.enabled(editor_model) ? \"\" : \" disabled\") + (x.minimized ? \" minimized\" : \"\") + \" \" + class_str},\r\n          [ el(\"div.editor-container-title\", {\r\n                 title: typeof renderedContent === \"string\" ? renderedContent : undefined\r\n               },\r\n               [ el(\"div\", {title: \"Expand menu\", class: \"expand-menu\"}, x.title),\r\n                 el(\"div.editor-container-icon#displayarrow\", {}, [], {innerHTML: editor.ui.icons.boxArrowExpand}),\r\n                 el(\"div.editor-container-icon.arrowdown\", {title: \"Move menu down\"}, [], {innerHTML: editor.ui.icons.boxArrowDown,\r\n                   onclick: function(event) {\r\n                     let d = this.parentElement.parentElement;\r\n                     var tmp = editor_model.interfaces[d.i];\r\n                     editor_model.interfaces[d.i] = editor_model.interfaces[d.i+1];\r\n                     editor_model.interfaces[d.i+1] = tmp;\r\n                     d.nextElementSibling.i = d.i;\r\n                     d.i = d.i + 1;\r\n                     d.parentElement.insertBefore(d.nextElementSibling, d);\r\n                     event.preventDefault();\r\n                     event.stop = true;\r\n                     return false;\r\n                   }}),\r\n                 el(\"div.editor-container-icon.arrowup\", {title: \"Move menu up\"}, [], {innerHTML: editor.ui.icons.boxArrowUp,\r\n                   i: i,\r\n                   onclick: function(event) {\r\n                     let d = this.parentElement.parentElement;\r\n                     var tmp = editor_model.interfaces[d.i];\r\n                     editor_model.interfaces[d.i] = editor_model.interfaces[d.i-1];\r\n                     editor_model.interfaces[d.i-1] = tmp;\r\n                     d.previousElementSibling.i = d.i;\r\n                     d.i = d.i - 1;\r\n                     d.parentElement.insertBefore(d, d.previousElementSibling);\r\n                     event.preventDefault();\r\n                     event.stop = true;\r\n                     return false;\r\n                   }})\r\n               ],\r\n               {\r\n                onclick: ((x) => event => {\r\n                  console.log(event);\r\n                  if(event.stop) return;\r\n                  let target = event.target;\r\n                  while(!target.matches(\".editor-container\")) target = target.parentNode;\r\n                  //console.log(\"onclick\", event.target);\r\n                  x.minimized = target.classList.contains(\"minimized\");\r\n                  x.minimized = !x.minimized;\r\n                  target.classList.toggle(\"minimized\", x.minimized);\r\n                })(x)\r\n               }),\r\n            el(\"div.editor-container-content\", {}, renderedContent),\r\n          ],\r\n        {i: i});\r\n        modifyMenuHolder.append(menu);\r\n      }\r\n      \r\n      //console.log ({old_scroll, modifyMenuHolder});\r\n      modifyMenuDiv.append(modifyMenuHolder);\r\n      if(modifyMenuHolder) modifyMenuHolder.scrollTop = old_scroll;\r\n\r\n      let createButton = function(innerHTML, attributes, properties) {\r\n        let button = el(\"div\", attributes, [], properties);\r\n        button.onmousedown = button.onmousedown ? button.onmousedown : preventTextDeselection;\r\n        button.classList.add(\"modify-menu-button\");\r\n        button.innerHTML = innerHTML;\r\n        return button;\r\n      }\r\n      let addPinnedModifyMenuIcon = function(innerHTML, attributes, properties) {\r\n        modifyMenuPinnedIconsDiv.append(createButton(innerHTML, attributes, properties));\r\n      }\r\n      var panelOpenCloseIcon = function() {\r\n        return document.querySelector(\"#modify-menu\").classList.contains(\"visible\") ?\r\n            editor.config.onMobile() ? editor.ui.icons.closeBottom : editor.ui.icons.closeRight + \"<span class='modify-menu-icon-label'>Close</span>\"\r\n          : editor.config.onMobile() ? editor.ui.icons.openTop : editor.ui.icons.openLeft + \"<span class='modify-menu-icon-label'>Open</span>\";\r\n      }\r\n      var alwaysVisibleButtonIndex = 0;\r\n      function nextVisibleBarButtonPosStyle() {\r\n        let result = \"position: absolute;\" +\r\n          (editor.config.onMobile() ? \"top:-\"+editor.config.buttonHeight()+\"px;left:\"+alwaysVisibleButtonIndex*editor.config.buttonWidth()+\"px\" :\r\n                        \"left:-\"+editor.config.buttonWidth()+\"px;top:\"+alwaysVisibleButtonIndex*editor.config.buttonHeight()+\"px\")\r\n        alwaysVisibleButtonIndex++;\r\n        return result;\r\n      }\r\n      if(!editor_model.linkSelectMode) {\r\n        addPinnedModifyMenuIcon(\r\n          panelOpenCloseIcon(),\r\n          {title: \"Open/close settings tab\", \"class\": \"inert\" },\r\n          {onclick: function(event) {\r\n              document.querySelector(\"#modify-menu\").classList.toggle(\"visible\");\r\n              editor_model.visible = !editor_model.visible;\r\n              setTimeout(maybeRepositionContextMenu, 500);\r\n              this.innerHTML = panelOpenCloseIcon();\r\n              if(editor.config.onMobile() && editor_model.savedTextSelection) {\r\n                window.getSelection().addRange(editor_model.savedTextSelection);\r\n                editor_model.savedTextSelection = undefined;\r\n              }\r\n            }\r\n        });\r\n        if(editor.config.EDITOR_VERSION & 1) {\r\n          addPinnedModifyMenuIcon(editor.ui.icons.undo + \"<span class='modify-menu-icon-label'>Undo</span>\", \r\n            {\"class\": \"inert\" + (editor.ui.canUndo() ? \"\" : \" disabled\"), title: \"Undo most recent change\",\r\n              id: \"undobutton\"\r\n            },\r\n            {onclick: function(event) {\r\n              if(!editor.ui.undo()) editor.ui.sendNotification(\"Nothing to undo!\");\r\n              }\r\n            }   \r\n          );\r\n          addPinnedModifyMenuIcon(editor.ui.icons.redo + \"<span class='modify-menu-icon-label'>Redo</span>\",\r\n            {\"class\": \"inert\" + (editor.ui.canRedo() ? \"\" : \" disabled\"), title: \"Redo most recent undo\",\r\n              id: \"redobutton\"\r\n            },\r\n            {onclick: function(event) {\r\n             if(!editor.ui.redo()) editor.ui.sendNotification(\"Nothing to redo!\");\r\n              }\r\n            }\r\n          );\r\n        }\r\n        addPinnedModifyMenuIcon(editor.ui.icons.save + \"<span class='modify-menu-icon-label'>Save</span>\",\r\n        {title: editor_model.disambiguationMenu ? \"Accept proposed solution\" : \"Save\", \"class\": \"saveButton\" + (editor.ui.canSave() || editor_model.disambiguationMenu ? \"\" : \" disabled\") + (editor_model.isSaving ? \" to-be-selected\" : \"\"),\r\n          id: \"savebutton\"\r\n        },\r\n          {onclick: editor_model.disambiguationMenu ? \r\n            ((ambiguityKey, selected) => () => editor.ambiguity.accept(ambiguityKey, selected))(\r\n              editor_model.disambiguationMenu.ambiguityKey, editor_model.disambiguationMenu.selected)\r\n            : editor.ui.save\r\n          }\r\n        )\r\n      }\r\n      else {\r\n        addPinnedModifyMenuIcon(editor.ui.icons.escape + \"<span class='modify-menu-icon-label-link'>Cancel</span>\", \r\n          {\"class\": \"link-select-button\", title: \"Go back to original screen\",\r\n            id: \"escapebutton\"\r\n          },\r\n          {onclick: function(event) {\r\n              escapeLinkMode();\r\n            }\r\n          }\r\n        );\r\n        addPinnedModifyMenuIcon(editor.ui.icons.check + \"<span class='modify-menu-icon-label-link'>Select</span>\", \r\n          {\"class\": \"link-select-button\", title: editor_model.linkSelectMsg || \"Select target\",\r\n            id: \"selectbutton\"\r\n          },\r\n          {onclick: function(event) {\r\n              editor_model.linkSelectCallback(editor_model.clickedElem);\r\n              escapeLinkMode();\r\n            }\r\n          }\r\n        );\r\n        if(editor_model.linkSelectOtherMenus) {\r\n          editor_model.linkSelectOtherMenus(addPinnedModifyMenuIcon)\r\n        }\r\n      }\r\n\r\n      if(!editor_model.linkSelectMode) {\r\n        contextMenu.innerHTML = \"\";\r\n        var whereToAddContextButtons = contextMenu;\r\n        var noContextMenu = false;\r\n        // What to put in context menu?\r\n        if(editor.config.onMobile() || (editor_model.clickedElem && editor_model.clickedElem.matches(\"html, head, head *, body\")) || !editor_model.selectionRange && !editor_model.clickedElem) {\r\n          modifyMenuPinnedIconsDiv.parentElement.insertBefore(modifyMenuIconsDiv, modifyMenuPinnedIconsDiv.nextSibling);\r\n          whereToAddContextButtons = modifyMenuIconsDiv;\r\n          noContextMenu = true;\r\n        }\r\n        let numButtons = 0;\r\n        let addContextMenuButton = function(innerHTML, attributes, properties) {\r\n          let button = el(\"div\", attributes, [], properties);\r\n          button.onmousedown = button.onmousedown ? button.onmousedown : preventTextDeselection;\r\n          button.classList.add(\"context-menu-button\");\r\n          button.innerHTML = innerHTML;\r\n          whereToAddContextButtons.append(button);\r\n          numButtons++;\r\n        }\r\n        if(editor_model.link) {\r\n          addContextMenuButton(editor.ui.icons.liveLink(linkToEdit(editor_model.link)),\r\n            {title: \"Go to \" + editor_model.link, \"class\": \"inert\"});\r\n        }\r\n        if(!editor_model.selectionRange && clickedElem && clickedElem.parentNode && editor.config.EDITOR_VERSION & 1) {\r\n          addContextMenuButton(editor.ui.icons.parentUp,\r\n          {title: \"Select parent\", \"class\":\"inert\"},\r\n            {onclick: (c => event => {\r\n              editor_model.clickedElem = c;\r\n              refresh();\r\n            })(clickedElem.parentNode)}\r\n          );\r\n        }\r\n        \r\n        var computedStyle = clickedElem && window.getComputedStyle(clickedElem);\r\n        var isDisplayInline = computedStyle && (computedStyle.display.startsWith(\"inline\") || computedStyle.display === \"table-cell\");\r\n        if(!editor_model.selectionRange && clickedElem && clickedElem.matches && !clickedElem.matches(\".editor-interface\") && clickedElem.previousElementSibling && !clickedElem.previousElementSibling.matches(\".editor-interface\") && reorderCompatible(clickedElem.previousElementSibling, clickedElem) && editor.config.EDITOR_VERSION & 1) {\r\n          addContextMenuButton(isDisplayInline ? editor.ui.icons.arrowLeft : editor.ui.icons.arrowUp,\r\n          {title: \"Move selected element \" + (isDisplayInline ? \"to the left\" : \"up\")},\r\n          {onclick: (c => event => {\r\n              let wsTxtNode = c.previousSibling && c.previousSibling.nodeType == 3 &&\r\n                c.previousSibling.textContent.trim() === \"\" ? c.previousSibling : undefined;\r\n              // There is whitespace before this element, we try to reinsert\r\n              c.parentElement.insertBefore(c, c.previousElementSibling);\r\n              if(wsTxtNode) { // We move the whitespace as well.\r\n                c.parentElement.insertBefore(wsTxtNode, c.previousElementSibling);\r\n              }\r\n              editor_model.clickedElem = c;\r\n              refresh();\r\n            })(clickedElem)\r\n          });\r\n        }\r\n        if(!editor_model.selectionRange && clickedElem && clickedElem.matches && !clickedElem.matches(\".editor-interface\") && clickedElem.nextElementSibling && !clickedElem.nextElementSibling.matches(\".editor-interface\") && reorderCompatible(clickedElem, clickedElem.nextElementSibling) && editor.config.EDITOR_VERSION & 1) {\r\n          addContextMenuButton(isDisplayInline ? editor.ui.icons.arrowRight : editor.ui.icons.arrowDown,\r\n          {title: \"Move selected element \" + (isDisplayInline ? \"to the right\" : \"down\")},\r\n          {onclick: (c => (event) => {\r\n              let wsTxtNode = c.nextSibling && c.nextSibling.nodeType == 3 && \r\n                c.nextSibling.textContent.trim() === \"\" ? c.nextSibling : undefined;\r\n              let nodeToInsertAfter = c.nextElementSibling;\r\n              nodeToInsertAfter.insertAdjacentElement(\"afterend\", c);\r\n              if(wsTxtNode) { // We move the whitespace as well\r\n                nodeToInsertAfter.parentElement.insertBefore(wsTxtNode, nodeToInsertAfter.nextSibling);\r\n              }\r\n              editor_model.clickedElem = c;\r\n              refresh();\r\n            })(clickedElem)\r\n          });\r\n        }\r\n        if(!editor_model.selectionRange && clickedElem && clickedElem.tagName !== \"HTML\" && clickedElem.tagName !== \"BODY\" && clickedElem.tagName !== \"HEAD\" && editor.config.EDITOR_VERSION & 1) {\r\n          addContextMenuButton(editor.ui.icons.clone,\r\n            {title: \"Clone selected element\"},\r\n            {onclick: ((c, contextMenu) => event => {\r\n                c.removeAttribute(\"ghost-clicked\");\r\n                let cloned = duplicate(c);\r\n                if(cloned) {\r\n                  editor_model.clickedElem = cloned;\r\n                  refresh();\r\n                } else contextMenu.classList.remove(\"visible\");\r\n              })(clickedElem, contextMenu)\r\n            });\r\n          addContextMenuButton(editor.ui.icons.wasteBasket,\r\n            {title: \"Delete selected element\"},\r\n            {onclick: (c => event => {\r\n                if(editor_model.clickedElem.nextElementSibling) editor_model.clickedElem = editor_model.clickedElem.nextElementSibling;\r\n                else editor_model.clickedElem = editor_model.clickedElem.previousElementSibling;\r\n                c.remove();\r\n                refresh();\r\n              })(clickedElem)\r\n            });\r\n        }\r\n        if(editor_model.selectionRange && (editor_model.selectionRange.startContainer === editor_model.selectionRange.endContainer || editor_model.selectionRange.startContainer.parentElement === editor_model.selectionRange.commonAncestorContainer && editor_model.selectionRange.endContainer.parentElement === editor_model.selectionRange.commonAncestorContainer) && editor.config.EDITOR_VERSION & 1) {\r\n          addContextMenuButton(editor.ui.icons.plus,\r\n              {title: \"Wrap selection\"},\r\n              {onclick: (s => event => {\r\n                let elements = [];\r\n                let tmp = s.startContainer;\r\n                let nodeToInsertAfter = s.startContainer;\r\n                let parent = nodeToInsertAfter.parentElement;\r\n                while(tmp && tmp !== s.endContainer.nextSibling) {\r\n                  if(tmp.nodeType === 3) {\r\n                    elements.push(tmp === s.startContainer ? tmp === s.endContainer ? tmp.textContent.substring(s.startOffset, s.endOffset) : tmp.textContent.substring(s.startOffset) :\r\n                      tmp === s.endContainer ? tmp.textContent.substring(0, s.endOffset) :\r\n                      tmp.textContent);\r\n                    if(tmp === s.startContainer) {\r\n                      if(tmp === s.endContainer && tmp.textContent.length > s.endOffset) {\r\n                        // Need to split the text node.\r\n                        tmp.parentElement.insertBefore(document.createTextNode(tmp.textContent.substring(s.endOffset)), tmp.nextSibling);\r\n                      }\r\n                      if(s.startOffset === 0) {\r\n                        nodeToInsertAfter = nodeToInsertAfter.previousSibling;\r\n                        tmp.remove();\r\n                      } else {\r\n                        tmp.textContent = tmp.textContent.substring(0, s.startOffset);\r\n                      }\r\n                    } else if(tmp === s.endContainer) {\r\n                      if(s.endOffset === s.endContainer.textContent.length) {\r\n                        tmp.remove();\r\n                      } else {\r\n                        tmp.textContent = tmp.textContent.substring(s.endOffset);\r\n                      }\r\n                    } else {\r\n                      tmp.remove();\r\n                    }\r\n                  } else {\r\n                    elements.push(tmp);\r\n                    tmp.remove();\r\n                  }\r\n                  tmp = tmp.nextSibling;\r\n                }\r\n                let insertedNode = el(\"span\", {\"ghost-clicked\": \"true\"});\r\n                for(let k of elements) {\r\n                  insertedNode.append(k);\r\n                }\r\n                let nodeToInsertBefore = nodeToInsertAfter ? nodeToInsertAfter.nextSibling : parent.childNodes[0];\r\n                parent.insertBefore(insertedNode, nodeToInsertBefore);\r\n                document.querySelector(\"#modify-menu\").classList.toggle(\"visible\", true);\r\n                editor_model.visible = true;\r\n                editor_model.clickedElem = insertedNode;\r\n                refresh();\r\n              })(editor_model.selectionRange)}\r\n              )\r\n        }\r\n        if(!editor_model.selectionRange && editor_model.clickedElem && editor.config.EDITOR_VERSION & 1) {\r\n          addContextMenuButton(editor.ui.icons.plus,\r\n              {title: \"Insert element\", contenteditable: false},\r\n              {onclick: event => {\r\n                editor_model.clickedElem = clickedElem;\r\n                editor_model.displayClickedElemAsMainElem = true;\r\n                editor_model.insertElement = true;\r\n                editor_model.visible = true;\r\n                getEditorInterfaceByTitle(\"Create\").minimized = false;\r\n                refresh();\r\n                restoreCaretPosition();\r\n              }});\r\n        }\r\n        if(editor_model.clickedElem) {\r\n          // Thaditor-defined custom context menu buttons\r\n          if(typeof thaditor === \"object\") {\r\n            for(let button of thaditor.customContextMenuButtons(editor_model.clickedElem)) {\r\n              addContextMenuButton(button.innerHTML, button.attributes, button.properties)\r\n            }\r\n          }\r\n          // Page-defined custom context menu buttons\r\n          for(let custom of editor.customContextMenuButtons) {\r\n            for(let button of custom(editor_model.clickedElem)) {\r\n              addContextMenuButton(button.innerHTML, button.attributes, button.properties)\r\n            }\r\n          }\r\n        }\r\n\r\n        let baseElem = clickedElem;\r\n        while(baseElem && (baseElem.tagName == \"SCRIPT\" || baseElem.tagName == \"STYLE\")) {\r\n          baseElem = baseElem.nextElementSibling;\r\n        }\r\n        baseElem = editor_model.selectionRange || baseElem || clickedElem;\r\n      \r\n        if(baseElem && !noContextMenu) {\r\n          let clientRect = baseElem.getBoundingClientRect();\r\n          // Find out where to place context menu.\r\n          let clickedElemLeft = window.scrollX + clientRect.left;\r\n          let clickedElemTop = window.scrollY + clientRect.top;\r\n          let clickedElemBottom = window.scrollY + clientRect.bottom;\r\n          let clickedElemRight = window.scrollX + clientRect.right;\r\n          let desiredWidth = numButtons * editor.config.buttonWidth();\r\n          let desiredLeft = (clickedElemLeft + clickedElemRight) / 2 - desiredWidth;\r\n          if(desiredLeft < clickedElemLeft) desiredLeft = clickedElemLeft;\r\n          let desiredTop = clickedElemTop - editor.config.buttonHeight(); \r\n          if(desiredTop - window.scrollY < 9) {\r\n            desiredTop = clickedElemBottom;\r\n            if(desiredTop + editor.config.buttonHeight() > window.innerHeight) {\r\n              desiredTop = window.innerHeight - editor.config.buttonHeight(); \r\n            }\r\n          }\r\n          if(desiredLeft < 0) desiredLeft = 0;\r\n          if(desiredTop < 0) desiredTop = 0;\r\n          contextMenu.style.left = desiredLeft + \"px\";\r\n          contextMenu.style.top = desiredTop + \"px\";\r\n          contextMenu.style.width = desiredWidth + \"px\";\r\n          contextMenu.classList.add(\"visible\");\r\n          setTimeout(maybeRepositionContextMenu, 0);\r\n        }\r\n        if(noContextMenu) {\r\n          contextMenu.classList.remove(\"visible\");\r\n        }\r\n      }\r\n      \r\n      return true;\r\n\r\n    } // editor.ui.refresh\r\n\r\n    editor.refresh = function() {\r\n      console.log(\"Please prefer editor.ui.refresh() instead of editor.refresh()\");\r\n      editor.ui.refresh()\r\n    };\r\n    editor.ui.refresh();\r\n\r\n    function maybeRepositionContextMenu() {\r\n      //move the context menu if overlaps with modify-menu\r\n       let contextMenu = document.querySelector(\"#context-menu\");\r\n       let modifyMenuDiv = document.querySelector(\"#modify-menu\");\r\n       let pinnedIcons = document.querySelector(\".modify-menu-icons.pinned\")\r\n       let pcr = pinnedIcons.getBoundingClientRect();\r\n       let ccr = contextMenu.getBoundingClientRect();\r\n       let mcr = modifyMenuDiv.getBoundingClientRect();\r\n       if(editor.config.onMobile()) {\r\n         if(ccr.bottom > pcr.top) {\r\n           contextMenu.style.top = (ccr.y - (ccr.bottom - pcr.top)) + \"px\"\r\n         } else if(ccr.bottom > mcr.top) {\r\n           contextMenu.style.top = (ccr.y - (ccr.bottom - mcr.top)) + \"px\"\r\n         }\r\n       } else {\r\n         if(ccr.right > pcr.left && ccr.top < pcr.bottom) { // Overlap with icons.\r\n           contextMenu.style.left = (ccr.x - (ccr.right - pcr.left)) + \"px\"\r\n         } else if(ccr.right > mcr.left) {\r\n           contextMenu.style.left = (ccr.x - (ccr.right - mcr.left)) + \"px\"\r\n         }\r\n       }\r\n    } //maybeRepositionContextMenu\r\n    \r\n    editor.ui.close = function editor_close() {\r\n      if(editor.ui.model.visible) {\r\n        editor.ui.model.visible = false;\r\n        editor.ui.refresh();\r\n        //Hide the menu\r\n        //This is also working fine\r\n        return false;\r\n      }\r\n      return true;\r\n    } //editor.ui.close \r\n    editor.close = editor.ui.close;\r\n    \r\n    editor.ui._internals.onBeforeuninit = function editor_onbeforeuninit(e) {\r\n      e = e || window.event;\r\n      if(editor.config.onMobile() && editor.ui.model.visible) { // Hack to ask before saving.\r\n        e.preventDefault();\r\n        e.returnValue = '';\r\n        return editor.ui.close();\r\n      }\r\n      var askConfirmation = editor.ui.canSave() || editor.ui.model.isSaving || editor.ui.model.disambiguationMenu;\r\n      const confirmation = 'You have unsaved modifications. Do you still want to exit?';\r\n      // For IE and Firefox prior to version 4\r\n      if (e) {\r\n        if(askConfirmation) {\r\n          e.returnValue = confirmation;\r\n        }\r\n      }\r\n      if(askConfirmation) {\r\n        // For Safari\r\n        return confirmation;\r\n      } else if(!editor.config.thaditor) { // Send a close message in case this was a file opened from Desktop\r\n        var xmlhttp = new XMLHttpRequest();\r\n        xmlhttp.onreadystatechange = editor.ui._internals.handleServerResponse(xmlhttp);\r\n        xmlhttp.open(\"POST\", location.pathname + location.search, false); // Async\r\n        xmlhttp.setRequestHeader(\"close\", \"true\");\r\n        xmlhttp.send(\"{\\\"a\\\":3}\");\r\n      }\r\n    } // End of editor.ui._internals.onBeforeuninit\r\n    \r\n  }; // editor.ui._internals.loadInterface\r\n\r\n  function dataToRecoverElement(oldNode) {\r\n    if(!oldNode) return undefined;\r\n    if(oldNode.nodeType == 1 && oldNode.getAttribute(\"id\") && document.getElementById(oldNode.getAttribute(\"id\"))) {\r\n      return {id: oldNode.getAttribute(\"id\")};\r\n    }\r\n    let tentativeSelector = [];\r\n    let t = oldNode;\r\n    let isText = false, textIndex = 0;\r\n    while(t && t.parentNode) {\r\n      let index = Array.prototype.slice.call( t.parentNode.children ).indexOf(t);\r\n      if(t.nodeType === 1) {\r\n        tentativeSelector.unshift(t.tagName + \":nth-child(\" + (index + 1) + \")\" );\r\n      } else {\r\n        isText = true;\r\n        textIndex = Array.prototype.slice.call( t.parentNode.childNodes ).indexOf(t);\r\n      }\r\n      t = t.parentNode;\r\n    }\r\n    return {tentativeSelector: tentativeSelector, isText: isText, textIndex: textIndex};\r\n  }\r\n  \r\n  // Returns the new node that matches the old node the closest.\r\n  // For text nodes, try to recover the text node, if not, returns the parent node;\r\n  function recoverElementFromData(data) {\r\n    if(!data) return undefined;\r\n    if(typeof data === \"object\" && data.id) {\r\n      return document.getElementById(data.id);\r\n    }\r\n    if(typeof data == \"object\" && Array.isArray(data.tentativeSelector)) {\r\n      let tentativeSelector = data.tentativeSelector;\r\n      while(tentativeSelector.length >= 1) {\r\n        let newNode = document.querySelector(tentativeSelector.join(\" \"));\r\n        if(newNode) {\r\n          return data.isText && newNode.childNodes && newNode.childNodes[data.textIndex] || newNode;\r\n        }\r\n        tentativeSelector.shift();\r\n      }\r\n      return undefined;\r\n    }\r\n  }\r\n  function setCaretPositionIn(node, position) {\r\n    position = Math.min(position, node.textContent.length);\r\n    if (node.nodeType == 3) {\r\n      let sel  = window.getSelection()\r\n      setTimeout( () => sel.collapse(node, position), 0);\r\n    } else {\r\n      let p = position\r\n      let n = node.firstChild\r\n      while(n != null && p > n.textContent.length) {\r\n        p = p - n.textContent.length\r\n        n = n.nextSibling\r\n      }\r\n      if(n != null) {\r\n        setCaretPositionIn(n, p)\r\n      } else {\r\n        console.log(\"Could not find position. Reached node and position \", [n, p])\r\n      }\r\n    }\r\n  }\r\n  function dataToRecoverCaretPosition(caretPosition) {\r\n    if(!caretPosition) return undefined;\r\n    return {target: editor.toTreasureMap(caretPosition.startContainer), startOffset: caretPosition.startOffset};\r\n  }\r\n  function recoverCaretPositionFromData(data) {\r\n    if(!data) return;\r\n    let newTextNodeOrParent = editor.fromTreasureMap(data.target);\r\n    if(newTextNodeOrParent) setCaretPositionIn(newTextNodeOrParent, data.startOffset)\r\n  }\r\n  function dataToRecoverSelectionRange(selectionRange) { // TODO\r\n    if(!selectionRange) return undefined;\r\n    return undefined;\r\n  }\r\n  function recoverSelectionRangeFromData(data) { // TODO\r\n    if(!data) return;\r\n    return undefined;\r\n  }\r\n\r\n  // Initialize Editor's interface.\r\n  editor.ui.init = function() {\r\n    editor.ui.model = { // Change this and call editor.ui.refresh() to get something consistent.\r\n      visible: ifAlreadyRunning ? editor.ui.model.visible : false, //here\r\n      clickedElem: ifAlreadyRunning ? editor.fromTreasureMap(editor.ui.model.clickedElem) : undefined,\r\n      displayClickedElemAsMainElem: true, // Dom selector status switch signal\r\n      previousVisitedElem: [], // stack<DOM node> which helps showing previous selected child in the dom selector\r\n      notextselection: false, // When using the relative DOM selector, set to true to avoid considering the caret (e.g. for insertions and deletions)\r\n      savedTextSelection: undefined, // Text range to restore when the edition bar closes, on mobile\r\n      restoredAfterReload: ifAlreadyRunning ? editor.ui.model.restoredAfterReload : {},\r\n      selectionRange: ifAlreadyRunning ? recoverSelectionRangeFromData(editor.ui.model.selectionRange) : undefined,\r\n      caretPosition: ifAlreadyRunning ? recoverCaretPositionFromData(editor.ui.model.caretPosition) : undefined,\r\n      link: undefined,\r\n      disambiguationMenu: undefined, //here\r\n      isSaving: false,\r\n      undosBeforeSave: ifAlreadyRunning ? editor.ui.model.undosBeforeSave : 0,\r\n      //data structures to represent undo/redo \"stack\"\r\n      undoStack: ifAlreadyRunning ? editor.ui.model.undoStack : [],\r\n      redoStack: ifAlreadyRunning ? editor.ui.model.redoStack : [],\r\n      actionsDuringSave: ifAlreadyRunning ? editor.ui.model.actionsDuringSave : [],\r\n      isDraftSwitcherVisible : ifAlreadyRunning ? editor.ui.model.isDraftSwitcherVisible : false,\r\n      //observer to listen for muts\r\n      outputObserver: ifAlreadyRunning ? editor.ui.model.outputObserver : undefined,\r\n      //worker for interface with the server\r\n      send_notif:ifAlreadyRunning ? editor.ui.model.send_notif : \"\",\r\n      //editor log\r\n      editor_log: ifAlreadyRunning ? editor.ui.model.editor_log : [],\r\n      show_log: ifAlreadyRunning ? editor.ui.model.show_log : false, //here\r\n      linkSelectMode: false, //here\r\n      linkSelectCallback: undefined, // Callback that is going to be called with the selected node.\r\n      idNum: ifAlreadyRunning ? editor.ui.model.idNum : 1,\r\n      //new attribute to keep menu state after reload\r\n      textareaPropertiesSaved: ifAlreadyRunning ? editor.ui.model.textareaPropertiesSaved : [],\r\n      askQuestions: ifAlreadyRunning ? editor.ui.model.askQuestions : editor.config.askQuestions,\r\n      autosave: ifAlreadyRunning ? editor.ui.model.autosave : editor.config.autosave,\r\n      path: editor.config.path,\r\n      version : computeDraftVersion(),\r\n      interfaces: ifAlreadyRunning ? editor.ui.model.interfaces : [],\r\n      disambiguationMenu: ifAlreadyRunning ? editor.ui.model.disambiguationMenu : undefined,\r\n      userIsModifying: false // Set to true only when user is clearly modifying something\r\n    }\r\n    \r\n    // Loads all the Editor interfaces.\r\n    editor.ui._internals.loadInterface();\r\n    \r\n    // Register the output observer\r\n    if (typeof editor.ui.model === \"object\" && typeof editor.ui.model.outputObserver !== \"undefined\") {\r\n      editor.ui.model.outputObserver.disconnect();\r\n    }\r\n    editor.ui.model.outputObserver = new MutationObserver(editor.ui._internals.handleMutations);\r\n    editor.ui.model.outputObserver.observe\r\n      ( document.body.parentElement\r\n      , { attributes: true\r\n        , childList: true\r\n        , characterData: true\r\n        , attributeOldValue: true\r\n        , characterDataOldValue: true\r\n        , subtree: true\r\n        }\r\n      );\r\n    \r\n    // Opens Editor's uI\r\n    editor.ui.refresh();\r\n    \r\n    // Register navigation to compute pages in background.\r\n    window.onpopstate = function(e){\r\n      console.log(\"onpopstate\", e);\r\n      if(e.state && e.state.localURL) {\r\n        editor.navigateTo(location, true);\r\n      } else {\r\n        editor.navigateTo(location.pathname + location.search, true);\r\n      }\r\n    };\r\n    \r\n    // Fix selection when it happens\r\n    document.addEventListener(\"selectionchange\", editor.ui.fixSelection);\r\n    \r\n    // File dropping\r\n    var dropZone = document.body;\r\n    dropZone.addEventListener('dragover', editor.ui.handleDragOver, false);\r\n    dropZone.addEventListener('drop', editor.ui.handleDroppedFiles, false);\r\n      \r\n    // Key Shortcuts\r\n    var lastKeyPress = 0;\r\n    var onKeyDown = function(e) {\r\n      var key = e.which || e.keyCode;\r\n      if (e.which == 83 && (e.ctrlKey || e.metaKey)) { // CTRL+S or CMD+S: Save\r\n        if(document.getElementById(\"savebutton\") && document.getElementById(\"savebutton\").onclick) {\r\n          document.getElementById(\"savebutton\").onclick();\r\n        }\r\n        e.preventDefault();\r\n      }\r\n      if(e.which == 75 && (e.ctrlKey || e.metaKey)) { // CTRL+K: Insert link\r\n        if(new Date().valueOf() - lastKeyPress > 100) {\r\n          document.execCommand('createLink', false, 'http://');\r\n          e.preventDefault();\r\n          var s = getSelection();\r\n          s = s ? s.anchorNode : s;\r\n          s = s ? s.parentNode : s;\r\n          lastKeyPress = new Date().valueOf();\r\n          editor.ui._internals.onClick({target: s, modify: true});\r\n        }\r\n        // Open link.\r\n      }\r\n      // CTRL+Z: Undo\r\n      if(e.which == 90 && (e.ctrlKey || e.metaKey)) {\r\n        e.preventDefault();\r\n        if(!editor.ui.undo()) editor.ui.sendNotification(\"Nothing to undo!\");\r\n      }\r\n      // CTRL+Y: Redo\r\n      if(e.which == 89 && (e.ctrlKey || e.metaKey)) {\r\n        e.preventDefault();\r\n        if(!editor.ui.redo()) editor.ui.sendNotification(\"Nothing to redo!\");\r\n      }\r\n      //in link select mode, escape on the keyboard can be\r\n      //used to exit the link select mode (same as escape button)\r\n      if(editor.ui.model.linkSelectMode) {\r\n        if(e.which == 27) { // Escape, Esc\r\n          escapeLinkMode();\r\n        }\r\n      } else {\r\n        if(e.which == 27) { // Escape, Esc.\r\n          if(editor.ui.model.clickedElem) {\r\n            editor.ui.model.clickedElem = undefined;\r\n            editor.ui.refresh();\r\n          } else {\r\n            editor.ui.uninit();\r\n          }\r\n        }\r\n      }\r\n    };\r\n    document.addEventListener(\"keydown\", onKeyDown);\r\n    \r\n    // Events after a key is pressed.\r\n    var bodyeditable = document.querySelector(\"body\");\r\n    var onKeypress = e => {\r\n      if(e.keyCode==13 && !e.shiftKey){ // [Enter] key without SHIFT\r\n          // If we are inside a paragraph, we split the paragraph.\r\n          // If we are directly inside a div, we add a <br> separator.\r\n          // We delete everything between anchorNode and focusNode\r\n          // TODO: Handle ul and li\r\n          // TODO: Handle tab to indent and dedent.\r\n          var caretSelection = document.getSelection();\r\n          var x = caretSelection.anchorNode;\r\n          if(x && x.nodeType == 3 && caretSelection.rangeCount) { // text node\r\n            if(x.parentNode && getComputedStyle(x.parentNode).display == \"block\") {\r\n              e.preventDefault(); //Prevent default browser\r\n              var range = caretSelection.getRangeAt(0);\r\n              range.deleteContents();\r\n              caretSelection = document.getSelection();\r\n              x = caretSelection.anchorNode;\r\n              if(x.parentNode.tagName == \"p\") { // Split the p\r\n                var newPar = document.createElement(\"p\");\r\n                \r\n                var fo = caretSelection.anchorOffset;\r\n                if(fo < x.text.length) {\r\n                  newPar.append(document.createTextNode(x.text.substring(fo)));\r\n                  x.deleteData(fo,x.text.length - fo);\r\n                }\r\n                var y = x.nextSibling;\r\n                while(y) {\r\n                  var yy = y;\r\n                  y = y.nextSibling;\r\n                  newPar.append(yy); // Moves yy\r\n                }\r\n                x.parentNode.insertAdjacentElement(\"afterend\", newPar);\r\n              } else { // insert br\r\n                range.insertNode(document.createElement(\"br\"))\r\n              }\r\n            }\r\n          }\r\n      }\r\n    }\r\n    if(bodyeditable && !bodyeditable.configured) {\r\n      bodyeditable.configured = true;\r\n      bodyeditable.addEventListener(\"keypress\", onKeypress, true);\r\n    }\r\n    \r\n    document.addEventListener('mousedown', editor.ui._internals.onMouseDown, false);\r\n    document.addEventListener('click', editor.ui._internals.onClick, false);\r\n    \r\n    \r\n    var onDeviceReady = function onDeviceReady(){\r\n      document.addEventListener(\"backbutton\", editor.ui.close, false);\r\n    };\r\n    // Mobile only. Experiment not working. We want the back button to close the editor when it is opened.\r\n    document.addEventListener(\"deviceready\", onDeviceReady, false);\r\n\r\n    var onError = function (message, source, lineno, colno, error) {\r\n      let msg;\r\n      if(message instanceof ErrorEvent) {\r\n        msg = message.message;\r\n      } else {\r\n        msg = message + \" from \" + source + \" L\" + lineno + \"C\" + colno;\r\n      }\r\n      editor.ui.model.editor_log.push(msg);\r\n    };\r\n    window.addEventListener(\"error\", onError);\r\n    \r\n    window.onbeforeuninit = editor.ui._internals.onBeforeuninit;\r\n    \r\n    editor.ui.uninit = function() {\r\n      if(!editor.confirmLeaving()) return;\r\n      if(editor.ui._internals.contextMenu) {\r\n        editor.ui._internals.contextMenu.remove();\r\n      }\r\n      if(editor.ui._internals.modifyMenu) {\r\n        editor.ui._internals.modifyMenu.remove();\r\n      }\r\n      // Register the output observer\r\n      if (typeof editor.ui.model === \"object\" && typeof editor.ui.model.outputObserver !== \"undefined\") {\r\n        editor.ui.model.outputObserver.disconnect();\r\n      }\r\n      window.onpopstate = undefined;\r\n      document.removeEventListener(\"selectionchange\", editor.ui.fixSelection);\r\n      dropZone.removeEventListener('dragover', editor.ui.handleDragOver);\r\n      dropZone.removeEventListener('drop', editor.ui.handleDroppedFiles);\r\n      document.removeEventListener(\"keydown\", onKeyDown);\r\n      bodyeditable.removeEventListener(\"keypress\", onKeypress);\r\n      \r\n      document.removeEventListener('mousedown', editor.ui._internals.onMouseDown);\r\n      document.removeEventListener('click', editor.ui._internals.onClick);\r\n      \r\n        // Mobile only. Experiment not working. We want the back button to close the editor when it is opened.\r\n      document.removeEventListener(\"backbutton\", editor.ui.close);\r\n      document.removeEventListener(\"deviceready\", onDeviceReady);\r\n      window.removeEventListener(\"error\", onError);\r\n      \r\n      window.onbeforeuninit = undefined;\r\n      \r\n      document.body.removeAttribute(\"contenteditable\");\r\n      document.body.insertBefore(editor.ui._internals.switchEditBox(true), document.body.childNodes[0]);\r\n    };\r\n    \r\n    // Store the current child list of nodes that ignore their children totally\r\n    (function() {\r\n      var elems = document.querySelectorAll(\"*\");\r\n      for(var i = 0; i < elems.length; i++) {\r\n        if(editor.isIgnoringChildNodes(elems[i])) {\r\n          editor.storeIgnoredChildNodes(elems[i]);\r\n        }\r\n      }\r\n    })();\r\n    \r\n    // The thing that makes everything live editable.\r\n    // Make sure we give the time to the page to register the change\r\n    setTimeout(() => {\r\n      if(typeof editor.config.canEditPage == \"boolean\" && editor.config.canEditPage) {\r\n        document.body.setAttribute(\"contenteditable\", \"true\");\r\n      }\r\n    }, 1);\r\n  } // editor.ui.init\r\n\r\n  document.addEventListener(\"DOMContentLoaded\", function(event) { \r\n    if(editor.config.canEditPage) {\r\n      editor.ui.init();\r\n    }\r\n  });\r\n})(editor);\r\n\r\neditor.init(); // Hook into navigation, copy/paste, listen to insertions.\r\n\r\n// editor.ui.init() can be called afterwards.</script>,\n-- The following is replaced by an inline <style> for when Editor runs as a file opener.\n-- And the path is modified when Editor runs as Thaditor.\n<style>div.seo-fix > input[type=text] {\n  padding: 4px;\n  width: 98%;\n  color: black;\n  font-size: 16px;\n}\n\np.seo-fix-description {\n  margin-bottom: 0px;\n  margin-top: 10px;\n}\n\n/* The switch - the box around the slider */\n\n.switch {\n    position: relative;\n    display: inline-block;\n    width: 30px;\n    height: 17px;\n    vertical-align: middle;\n    margin-left: 0.6rem;\n}\n\n/* Hide default HTML checkbox */\n\n.switch input {\n    display: none;\n}\n\n/* The slider */\n\n.slider {\n    position: absolute;\n    cursor: pointer;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background-color: #ccc;\n    -webkit-transition: .4s;\n    transition: .4s;\n}\n\n.slider:before {\n    position: absolute;\n    content: \"\";\n    height: 13px;\n    width: 13px;\n    left: 2px;\n    bottom: 2px;\n    background-color: white;\n    -webkit-transition: .4s;\n    transition: .4s;\n}\n\n/* Remove all input default border and shadow in modify-menu*/\n\n#modify-menu input[type=text] {\n    outline-color: invert;\n    outline-style: none;\n    outline-width: 0px;\n    border: none;\n    border-style: none;\n    text-shadow: none;\n    -webkit-appearance: none;\n    -webkit-user-select: text;\n    outline-color: transparent;\n    box-shadow: none;\n    color: black;\n}\n\ninput:checked+.slider {\n    background-color: #2196F3;\n}\n\ninput:focus+.slider {\n    box-shadow: 0 0 1px #2196F3;\n}\n\ninput:checked+.slider:before {\n    -webkit-transform: translateX(13px);\n    -ms-transform: translateX(13px);\n    transform: translateX(13px);\n}\n\n.textarea {\n    color: white;\n    font-family: Arial;\n}\n.notifs {\n    background-color: var(--context-color);\n    /* transform: translateX(44px); */\n    position: absolute;\n    top: 0px;\n    width:256px;\n    height:128px;\n    font-size: 1.4rem;\n    resize: none;\n    text-align: center;\n    border: none;\n    border-radius: 0.4rem;\n    font-weight: bold;\n    padding-top: 1em;\n    animation: notifs-invisible 0.5s forwards, fadeOut 0.5s forwards;\n}\n.notifs.visible {\n  animation: notifs-visible 0.5s forwards, fadeIn 0.5s forwards;\n}\n@@keyframes notifs-visible {\n  0% {transform:translateX(-128px);}\n  100% {transform: translateX(calc(-256px - 48px));}\n}\n@@keyframes notifs-invisible {\n  0% {transform:translateX(calc(-256px - 48px));}\n  100% {transform: translateX(-128px);}\n}\n@@keyframes fadeIn {\n  0% {opacity:0;}\n  100% {opacity: 1;}\n}\n@@keyframes fadeOut {\n  0% {opacity:1;}\n  100% {opacity: 0;}\n}\n\n.logger {\n    background-color: transparent;\n    width: 100%;\n    height: 50px;\n    border: none;\n}\n\n/* Rounded sliders */\n\n.slider.round {\n    border-radius: 17px;\n}\n\n.slider.round:before {\n    border-radius: 50%;\n}\n\n.switch+label {\n    cursor: pointer;\n    padding-top: 5px;\n    padding-bottom: 5px;\n}\n\n.filename {\n    color: #FFF;\n    padding-left: 3px;\n    vertical-align: top;\n    display: block;\n    font-weight: bold;\n    font-size: 1.2rem;\n}\n\ndiv.imgFolder {\n    text-align: center;\n    padding: 0.6em;\n}\n\ndiv.imgFolder > img {\n    max-width: 100%;\n    min-width: 2em;\n}\n\na.troubleshooter {\n    position: absolute;\n    top: 1rem;\n    /* top: calc(100% - 3em); */\n    display: inline-block;\n    right: 2em;\n    text-decoration: none;\n    color: white;\n    font-weight: bold;\n}\n\n.editor-menu {\n    display: initial !important;\n}\n\n.disabled {\n    color: #BBB;\n}\n\ninput.global-setting[type=checkbox] {\n    display: none;\n}\n\ninput.global-setting[type=checkbox]:checked+span.label-checkbox {\n    background: #bcbbff;\n}\n\nspan.label-checkbox {\n    padding: 2px;\n    border-radius: 10px;\n}\n\nspan.label-checkbox:hover {\n    background-color: rgba(0, 0, 0, 0.06);\n    cursor: pointer;\n}\n\nspan#ambiguity-id {\n    color: #9dff00;\n    display: block;\n}\n\n.solution {\n    display: block;\n    padding: 3px;\n}\n\n.solution.selected {\n    background: rgba(255, 255, 255, 0.2);\n}\n\n.solution:not(.selected):hover {\n    background: rgba(255, 255, 255, 0.1);\n    cursor: pointer;\n}\n\n.solution.notfinal {\n    color: #f6f6aa;\n}\n\n.add {\n    background: lightgreen\n}\n\n.remove {\n    background: #f8a7a7;\n    text-decoration: line-through\n}\n\ndiv.disambiguationMenu {\n    height: 40%;\n    overflow-y: auto;\n    padding-left: 0.3em;\n    padding-top: 0.3em;\n    padding-bottom: 0.3em;\n    border: 2px solid #f6f6aa;\n}\n\n.codepreview {\n    font-family: monospace;\n    padding: 3px;\n    background: white;\n    color: black;\n    margin-left: 0.1em;\n}\n\n.solution:not(.selected) .codepreview {\n    background: rgba(255, 255, 255, 0.8);\n}\n\n#modify-menu button.modifyMenuButton {\n    background-color: var(--context-button-color);\n    min-height: var(--context-button-width);\n    color: var(--context-dom-text-color);\n    border-style: none;\n    margin-top: 5px;\n    padding: 0.4em;\n    font-weight: bold;\n    cursor: pointer;\n}\n\n#modify-menu button.modifyMenuButton:hover {\n    background-color: var(--context-button-color-hover);\n}\n\n#editor_codepreview, #manualsync-menuitem {\n    display: none;\n    z-index: 999;\n}\n\n[ghost-visible=true] {\n    display: initial !important;\n}\n\n[ghost-disabled=true] {\n    opacity: 0.5 !important;\n    cursor: initial;\n    pointer-events: none !important;\n}\n\n[ghost-disabled=false] {\n    opacity: 1 !important;\n    pointer-events: auto !important;\n}\n\n#manualsync-menuitem[ghost-disabled=false]>button {\n    cursor: pointer !important;\n    opacity: 1 !important;\n    pointer-events: auto !important;\n}\n\n#manualsync-menuitem[force-visible=true] {\n    display: initial;\n}\n\n[ghost-visible=false] {\n    display: none !important;\n}\n\n#manualsync-menuitem>button {\n    vertical-align: top;\n    opacity: 0.5;\n    cursor: initial;\n    pointer-events: none;\n}\n\n#editor_codepreview {\n    width: 100%;\n    height: 600px;\n}\n\n@@media screen and (max-width: 800px) {\n    body {\n        font-size: 48px;\n    }\n    menu.edittoolbar {\n        right: 10px;\n    }\n    menuitem.filename {\n        display: none;\n    }\n    /*menuitem {\n      font-size: 2.5em;\n    }*/\n    button {\n        font-size: 1em;\n    }\n    menuitem#question-menuitem {\n        display: none;\n    }\n    menuitem#autosave-menuitem {\n        display: none;\n    }\n    #editor_codepreview {\n        width: 100%;\n        height: 600px;\n    }\n    @@keyframes notifs-visible {\n      0% {transform:translateY(-64px);}\n      100% {transform: translateY(calc(-128px - 48px));}\n    }\n    @@keyframes notifs-invisible {\n      0% {transform:translateY(calc(-128px - 48px));}\n      100% {transform: translateY(-64px);}\n    }\n\n}\n\ndiv#modify-menu textarea.inline-CSS {\n    width: 100%;\n    height: 100px;\n    margin-bottom: 6px;\n    overflow-y: auto;\n    color: black;\n}\n\ndiv#modify-menu #CSS-modification {\n    width: 100%;\n    overflow-y: auto;\n    display: flex;\n    flex-direction: column;\n    flex: 1;\n}\n\ndiv#modify-menu button.action-button {\n    color: white;\n    background: var(--context-dom-children-selector-color);\n    font-size: 1em;\n    margin-top: 6px;\n    margin-bottom: 6px;\n    display: block;\n    border-radius: 0.4em;\n    height: 2em;\n    font-weight: normal;\n    padding: 6px;\n    border: none;\n}\n\n\ndiv#modify-menu button.action-button:hover {\n    -webkit-filter: contrast(125%);\n    /* Chrome, Opera */\n    -moz-filter: blur(125%);\n    -ms-filter: blur(125%);\n    filter: blur(125%);\n    border: none;\n}\n\n\ndiv#modify-menu #CSS-modification > button#add-inline-style:hover {\n    -webkit-filter: contrast(125%);\n    /* Chrome, Opera */\n    -moz-filter: blur(125%);\n    -ms-filter: blur(125%);\n    filter: blur(125%);\n}\n\ndiv#modify-menu #CSS-modification .linked-CSS {\n    width: 100%;\n    height: 250px;\n}\n\ndiv#modify-menu #CSS-modification>.CSS-modify-unit {\n    display: flex;\n    align-items: center;\n    margin-bottom: 5px;\n}\n\ndiv#modify-menu #CSS-modification>.CSS-modify-unit>.CSS-buttons{\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n}\n\ndiv#modify-menu #CSS-modification>.CSS-modify-unit > textarea {\n    width: 100%;\n    height: 100px;\n    overflow-y: auto;\n    font-family: monospace;\n    color: black;\n    border-radius: 0.2em;\n    border: none;\n    font-size: 16px;\n    padding: 6px;\n}\n\ndiv#modify-menu #CSS-modification>div.CSS-chain {\n    margin-bottom: 6px;\n}\n\ndiv#modify-menu #CSS-modification>.CSS-modify-unit .CSS-action-button:hover {\n    background-color: var(--context-button-color-hover);\n}\n\ndiv#modify-menu #CSS-modification>.CSS-modify-unit .CSS-selectors {\n    width: 100%;\n    height: 100px;\n    overflow-y: auto;\n    font-family: monospace;\n    color: black;\n    border-radius: 0.2em;\n    border: none;\n    font-size: 0.8em;\n    padding: 6px;\n}\n\ndiv#modify-menu div#fullLog {\n  max-height: 50%;\n}\n\n.summary {\n    color: green;\n}\n\ndiv#modify-menu {\n    -webkit-box-shadow: 0px 0px 34px 0px rgba(0, 0, 0, 0.75);\n    -moz-box-shadow: 0px 0px 34px 0px rgba(0, 0, 0, 0.75);\n    box-shadow: 0px 0px 34px 0px rgba(0, 0, 0, 0.75);\n    position: fixed;\n    top: 0px;\n    right: 0px;\n    width: 400px;\n    height: 100%;\n    background-color: var(--context-color);\n    color: var(--context-dom-text-color);\n    padding: 5px;\n    font-size: 16px;\n    transform: translate(100%, 0px);\n    transition-property: transform;\n    transition-duration: 0.5s;\n    z-index: 100001;\n}\n\n.modify-menu-holder {\n    width: 100%;\n    height: calc(100% - 10px);\n    overflow-y: auto;\n    font-family: Arial, Helvetica, sans-serif;\n}\ndiv.modify-menu-icons:not(.pinned) ~ div.modify-menu-holder {\n  height: calc(100% - 50px);\n}\n\n.modify-menu-icon {\n    vertical-align: middle;\n    cursor: pointer;\n    width: var(--context-menu-button-width);\n}\n\n.modify-menu-icon:hover {\n    background-color: var(--context-button-color-hover);\n}\n\ndiv#modify-menu>div.modify-menu-icons:not(.pinned) {\n    width: 100%;\n    height: 30px;\n    overflow-x: auto;\n    margin: 5px;\n}\n\ndiv#modify-menu>div.modify-menu-icons.pinned {\n    width: var(--context-menu-button-width);\n    position: absolute;\n    left: calc(0px - var(--context-menu-button-width));\n}\n\ndiv#modify-menu>div.information {\n    overflow-y: auto;\n    max-height: calc(100% - var(--context-menu-height) - 15%);\n    margin: 2%;\n    margin-top: 0;\n    border-radius: 0.3em;\n}\n\ndiv#modify-menu>div.information-style {\n    padding: 0.4rem;\n}\n\n/* information part scroll bar */\n.information.information-style::-webkit-scrollbar {\n    background: transparent;\n    width: 8px;\n}\n\n.information.information-style::-webkit-scrollbar-thumb {\n    background: rgba(255, 255, 255, 0.5);\n    border-radius: 10px;\n}\n\ndiv.information>textarea {\n    font-size: 1em;\n}\n\ndiv#modify-menu.visible {\n    transform: translate(0%, 0%);\n}\n\ndiv#modify-menu h3 {\n    margin-top: 2px;\n    margin-bottom: 2px;\n}\n\ndiv#modify-menu button.CSSbutton {\n    width: 98%; \n    height: 7%;\n    padding: 4px;\n    margin-left: 4px;\n}\n\ndiv#modify-menu div.keyvalues {\n    margin-top: 6px;\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue {\n    font-size: 16px;\n    padding: 2px;\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-items: center;\n    padding-left: 8px;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue .attribute-key-value {\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    width: 60%;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue .attribute-key {\n    width: 39%;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalueadder {\n    opacity: 0.5;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalueadder:hover {\n    opacity: 1;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalueadder .attribute-key-value{\n    display: flex;\n    flex-direction: row;\n}\n\ndiv#modify-menu div.keyvalue input {\n    padding: 4px;\n    width: 98%;\n    color: black;\n    font-size: 16px;\n}\n\ndiv#modify-menu .codefont {\n    font-size: 1.4em;\n    font-family: monospace;\n}\n\ndiv#modify-menu .tagname-input {\n    padding: 4px;\n    flex: 1;\n}\n\ndiv#modify-menu .tagname-input input {\n    display: inline-block;\n}\n\ndiv#modify-menu .tagname-info {\n    display: inline-block;\n    border-radius: 4px;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    background: transparent;\n    color: var(--context-dom-text-color);\n    flex: 2;\n    line-height: 3.5em;\n}\n\ndiv#modify-menu input[type=radio] {\n    width: initial;\n    font-size: 1em;\n}\n\ndiv#modify-menu span.insertOption {\n    display: block;\n}\n\ndiv.keyvalue span>input {\n    border-radius: 4px;\n    margin: 2px;\n}\n\ndiv.tagname-summary {\n    display: flex;\n    background-color: var(--context-dom-selector-color);\n    border-radius: 0.4em;\n    padding: 4px;\n    margin: 2%;\n}\n\n.inline-input {\n    background: transparent;\n    color: var(--context-dom-text-color);\n    border: none;\n}\n\n/* dom selector css */\n\ndiv.dom-selector-style {\n    margin: 2%;\n    margin-top: 0;\n    margin-bottom: 0;\n    border-radius: 0.4em;\n    padding: 0.4rem;\n}\n\ndiv.childrenElem {\n    display: flex;\n    height: 30px;\n    margin-top: 4px;\n}\n\ndiv.mainElemName {\n    color: var(--context-dom-text-color);\n    font-family: monospace;\n}\n\ndiv.childrenSelectorName {\n    font-family: monospace;\n}\n\ndiv.childrenSelector {\n    min-width: 50px;\n    position: relative;\n    flex: 1;\n    text-align: center;\n    overflow: hidden;\n    padding: 2px;\n    margin: 2px;\n    border-radius: 0.3rem;\n    background-color: var(--context-dom-children-selector-color);\n    transition: all 0.5s;\n    text-decoration: none;\n    cursor: pointer;\n}\n\ndiv.childrenSelector:hover {\n    -webkit-filter: contrast(125%);\n    /* Chrome, Opera */\n    -moz-filter: blur(125%);\n    -ms-filter: blur(125%);\n    filter: blur(125%);\n}\n\ndiv.editor-interface-dom-selector {\n  opacity: 0.5;\n  color: #ffe5b5;\n}\ndiv.editor-recorded-ghost-node {\n  opacity: 0.5;\n}\ndiv.editor-recorded-ghost-attribute {\n  opacity: 0.5;\n}\ndiv.editor-ignored-attribute {\n  background: #a2a2a2;\n}\n\n\ndiv.mainElem {\n    height: 62px;\n    position: relative;\n    text-align: center;\n    overflow: hidden;\n    font-size: 1.3em;\n    text-overflow: ellipsis;\n}\n\ndiv.mainElemInfo {\n    font-size: 0.6em;\n    color: var(--context-dom-text-color);\n    height: 20px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\ndiv.childrenSelectorInfo {\n    text-overflow: ellipsis;\n    overflow: hidden;\n    color: var(--context-dom-text-color);\n    height: 38px;\n    font-size: 0.8em;\n}\n\ndiv.elementAttr {\n    margin-left: 6px;\n    display: inline-block;\n    font-size: 0.6em;\n    line-height: 1.02em;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    color: var(--context-dom-text-color);\n}\n\ndiv.no-children, div.no-parent {\n    background-color: transparent;\n    text-align: center;\n    text-transform: uppercase;\n    color: black;\n    border-radius: 0.3rem;\n    font-weight: bold;\n    line-height: 36px;\n    font-size: 0.8rem;\n    pointer-events: none;\n}\n\ndiv.no-children {\n    width: 100%;\n}\n\ndiv.no-sibling {\n    background-color: transparent;\n    color: black;\n    width: 20%;\n    text-transform: uppercase;\n    font-size: 0.8em;\n    line-height: 20px;\n    font-weight: bold;\n    min-width: 50px;\n    pointer-events: none;\n}\n\n/* make button's text unselectable for better user experience */\n\n.noselect {\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -khtml-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n\n.selectedDom {\n    background-color: var(--context-dom-selector-color) !important;\n    border: none;\n}\n\n#upload-image-btn-a {\n    margin-left: 0;\n    margin-top: 10px;\n    margin-bottom: 10px;\n    height: 20px;\n    position: relative;\n    color: black;\n    background: transparent;\n    border-radius: 4px;\n    display: inline-block;\n    height: 20px;\n    width: 280px;\n}\n\n#upload-image-btn-input {\n    position: absolute;\n    top: -7px; /* alignment */\n    left: 0;\n    width: 100%;\n}\n\n/* highlight selected image */\n\ndiv.highlight-select-image {\n    border: 1px solid white;\n    border-radius: 0.76em;\n}\n\n:root {\n    --context-color: rgba(0, 128, 128, 0.8);\n    --context-color-next: rgba(0, 158, 158, 0.8);\n    --context-button-color: rgba(0, 192, 192, 0.8);\n    --context-button-color-hover: rgba(0, 232, 232, 0.8);\n    --context-button-color-inert: rgba(128, 128, 128, 0.8);\n    --context-button-color-inert-hover: rgba(150, 150, 150, 0.8);\n    --context-button-color-inert-active: rgba(182, 182, 182, 0.8);\n    --context-dom-selector-color: rgba(0, 212, 159, 0.8);\n    --context-dom-children-selector-color: rgba(0, 178, 179, 0.8);\n    --context-dom-text-color: whitesmoke;\n    --context-menu-height: 30px;\n    --context-menu-button-width: 40px;\n    --context-menu-padding-top: 0px;\n    --context-menu-padding-left: 0px;\n    --context-button-selected: rgba(0, 212, 212, 0.8);\n    --context-editor-container-title: rgba(0, 178, 179, 0.6);\n}\n\ndiv.tagName {\n    margin-top: 0.24rem;\n    /* padding: 4px; */\n    cursor: pointer;\n    /* background: var(--context-button-color); */\n    vertical-align: text-bottom;\n}\n\ndiv.tagName:not(.nohover):hover {\n    background: var(--context-button-color-hover);\n}\n\n\n#customHTML {\n    height: 6%;\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n}\n\n[ghost-hovered=true] {\n    outline: 2px dashed var(--context-color-next);\n}\n\n[ghost-clicked=true] {\n    outline: 2px solid var(--context-color);\n}\n\n[wrong-selector=true]{\n    background-color: #fbcaca;\n}\n\ndiv#context-menu {\n    position: absolute;\n    display: none;\n    background-color: var(--context-color);\n    color: white;\n    font-weight: bold;\n    z-index: 10001;\n}\n\ndiv#context-menu.visible {\n    display: block;\n    height: var(--context-menu-height);\n    width: 200px;\n}\n\ndiv#context-menu .context-menu-button, div#modify-menu .modify-menu-button, div#modify-menu .modify-menu-icons .context-menu-button {\n    background: var(--context-button-color);\n    display: inline-block;\n    width: var(--context-menu-button-width);\n    cursor: pointer;\n}\n\ndiv.modify-menu-icons:not(.pinned) > div.modify-menu-button {\n    background-color: transparent !important;\n    border-radius: 0.4rem;\n    margin-right: 0.2rem;\n}\n\ndiv.modify-menu-icons:not(.pinned) > div.modify-menu-button:hover {\n    background-color: var(--context-button-color) !important;\n}\n\ndiv#context-menu .context-menu-button, div#modify-menu .modify-menu-icons:not(.pinned) .modify-menu-button {\n    height: var(--context-menu-height);\n}\n\ndiv#modify-menu .modify-menu-icons.pinned .modify-menu-button {\n    border-bottom: 1px solid black;\n}\n\ndiv#modify-menu .modify-menu-icons.pinned .modify-menu-button:last-child {\n    border-bottom: none;\n}\n\ndiv#context-menu .context-menu-button.selected, div#modify-menu .modify-menu-button.selected {\n    background: var(--context-button-selected);\n}\n\ndiv#modify-menu .modify-menu-button.inert.active {\n    background: var(--context-button-color-inert-active)\n}\n\ndiv#modify-menu .modify-menu-button.disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\ndiv#modify-menu .modify-menu-icon-label {\n    display: block;\n    color: white;\n    font-size: calc(var(--context-menu-button-width) / 3);\n    text-align: center;\n}\n\ndiv#modify-menu .modify-menu-icon-label-link {\n    display: block;\n    color: white;\n    font-size: calc(var(--context-menu-button-width) / 4);\n    text-align: center;\n}\n\n/* div#context-menu .context-menu-button>svg, div#modify-menu .modify-menu-button>svg {\n    padding: 5px;\n    padding-bottom: 2px;\n    padding-top: 2px;\n} */\n\ndiv#context-menu .context-menu-button.inert, div#modify-menu .modify-menu-icons.modify-menu-icons .modify-menu-button.inert {\n    background: var(--context-button-color-inert)\n}\n\nsvg.context-menu-icon>path {\n    fill: none;\n    stroke: #FFFFFF;\n    stroke-width: 2px;\n    stroke-linecap: butt;\n    -linejoin: miter;\n    stroke-opacity: 1;\n}\n\nsvg.context-menu-icon.fill>path {\n    fill: #FFFFFF;\n    fill-rule: evenodd;\n    stroke-width: 1px;\n}\n\ndiv#context-menu .context-menu-button:hover, div#modify-menu .modify-menu-button:hover:not(.disabled) {\n    background: var(--context-button-color-hover);\n}\n\ndiv#context-menu .context-menu-button.inert:hover, div#modify-menu .modify-menu-button.inert:hover:not(.disabled) {\n    background: var(--context-button-color-inert-hover)\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue #applyNewTagName {\n    display: none;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue #applyNewTagName.visible {\n    display: flex;\n    width: var(--context-menu-button-width);\n    padding: 4px;\n}\ndiv#modify-menu div.keyvalues>div.keyvalue #newTagName {\n    background: none;\n    color: white;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue #newTagName:focus {\n    background: white;\n    color: initial;\n}\n\n\ndiv#modify-menu div.keyvalues>div.keyvalue #applyNewTagName + div#newtagname-align-placeholder {\n  display: flex;\n  width: calc(var(--context-menu-button-width) - 8px);\n  padding: 4px;\n  margin: 2px;\n  border-radius: 4px;\n  border-width: 2px;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue #applyNewTagName.visible + div#newtagname-align-placeholder {\n  display: none;\n}\n\ntextarea.textChildNodeContent {\n  width: 95%;\n  height: 100px;\n  border-radius: 0.4em;\n  border: 0;\n  margin-top: 6px;\n  padding: 10px;\n  color: black;\n  resize: vertical;\n  min-height: 50px;\n  font-size: 0.8em;\n}\n\ntextarea.templateengine {\n    width: 100%;\n    height: 100%;\n    max-height: 50%;\n    color: black;\n    border-radius: 0.4rem;\n    border: 0;\n    padding: 0.4em;\n    font: normal 0.8em Consolas, Monaco, monospace;\n    resize: none;\n    opacity: 0.8;\n}\n\ntextarea.templateengine:focus {\n    outline: none;\n    opacity: 1;\n}\n\n#modify-menu span.insertOption label {\n  display: inline-block;\n}\n\n\n.to-be-selected {\n    animation: OrangeWait 3s linear infinite;\n    background: linear-gradient(90deg, orange 0%, gold 5%, gold 10%, orange 15%) !important;\n    background-size: 200% 100% !important;\n}\n\n@@keyframes OrangeWait { \n    0% { \n      background-position: 30% 0%;\n    }\n    30%, 100% {\n      background-position: -100% 0%;\n    }\n}\n\ndiv.editor-container {\n  margin-top: 3px;\n}\n\ndiv.editor-container-title > div.expand-menu {\n  float: left;\n  line-height: 30px;\n  padding-left: 6px;\n}\ndiv.editor-container:first-of-type div.arrowup, div.editor-container:last-of-type div.arrowdown {\n  visibility: hidden;\n}\ndiv.editor-container.minimized div.editor-container-content {\n  display: none;\n}\ndiv.editor-container.disabled div.editor-container-title {\n  color: #BBB;\n}\ndiv.editor-container:not(.disabled) > div.editor-container-title:hover {\n  -webkit-filter: contrast(125%);\n    /* Chrome, Opera */\n    -moz-filter: blur(125%);\n    -ms-filter: blur(125%);\n    filter: blur(125%);\n}\n\ndiv.editor-container div.editor-container-title div.editor-container-icon svg.context-menu-icon.fill>path {\n  fill: #BBB;\n  stroke-width: 0px;\n}\ndiv.editor-container div.editor-container-title div.editor-container-icon:hover svg.context-menu-icon.fill>path {\n  fill: white;\n}\ndiv.editor-container-title {\n  border-radius: 0.2rem;\n  height: 30px;\n  background-color: var(--context-editor-container-title);\n  cursor: pointer;\n  font-family: Tahoma, sans-serif;\n  font-weight: bold;\n}\n\ndiv.editor-container-content {\n  padding: 6px;\n  padding: 6px;\n  max-height: 80%;\n  overflow-y: auto;\n}\n\ndiv.editor-container-content button {\n    outline: none;\n}\ndiv.editor-container div.editor-container-title div.editor-container-icon {\n  opacity: 0;\n  transition: opacity .25s ease-in-out;\n}\ndiv.editor-container div.editor-container-title:hover div.editor-container-icon {\n  opacity: 1;\n}\ndiv.editor-container div.editor-container-title div.editor-container-icon {\n  float: right;\n  margin-top: 5px;\n}\ndiv.editor-container.minimized div.editor-container-title div.editor-container-icon#displayArrow {\n  transform: rotate(180deg);\n  transform-origin: 50% 50%;\n}\n\ndiv.editor-container-content > div.draftList > div.draft-row {\n    display: flex;\n}\n\ndiv.editor-container-content > div.draftList > div.draft-row:not(#draft-title) > * {\n    flex-grow: 1;\n    flex-shrink: 1;\n}\n\n\ndiv.editor-container-content > div.draftList > div.draft-row > button {\n    margin: 4px;\n    border-radius: 0.2em;\n    color: var(--context-dom-children-selector-color);\n    background-color: rgba(255, 255, 255, 0.9);\n    font-size: 0.88em;\n    border: none;\n    height: 1.6em;\n    cursor: pointer;\n}\n\ndiv.editor-container-content > div.draftList > div.draft-row > button:hover {\n    -webkit-filter: contrast(125%);\n    /* Chrome, Opera */\n    -moz-filter: blur(125%);\n    -ms-filter: blur(125%);\n    filter: blur(125%);\n    background-color: var(--context-dom-children-selector-color);\n    border: none;\n    color: white;\n}\n\ndiv.editor-container-content > div.draftList > div.draft-row > button.draft-switch {\n    color: white;\n    background: linear-gradient(left, var(--context-dom-selector-color) , var(--context-dom-children-selector-color));\n    background: -webkit-linear-gradient(left, var(--context-dom-selector-color) , var(--context-dom-children-selector-color));\n    flex-basis: 10px;\n}\n\ndiv.draftList > div.draft-row > button.draft-publish,\ndiv.draftList > div.draft-row > button.draft-clone,\ndiv.draftList > div.draft-row > button.draft-delete {\n    flex-basis: 20px;\n}\n\ndiv.draftList > div.draft-row > button.draft-delete:hover {\n    color: rgb(204, 204, 0) !important;\n    font-weight: bold;\n}\n\ndiv.editor-container-content > div.draftList > div#draft-title {\n    padding-left: 4px;\n    padding-right: 4px;\n}\n\ndiv.editor-container-content > div.draftList > div#draft-title > label {\n    margin-top: 6px;\n}\n\ndiv.editor-container-content > div.draftList > div#draft-title > label:first-child {\n    font-weight: bold;\n    font-size: 1.2em;\n    margin-top: 2px;\n    padding-right: 10px;\n}\n\nlabel.switch {\n  position: relative;\n}\n\ndiv#modify-menu div.translation-title {\n  font-weight: bold;\n  margin-top: 5px;\n}\ndiv#modify-menu textarea.translation-content {\n  color: black;\n  width: 100%;\n  height: 120px;\n  max-height: 50%;\n}\n\n.translate-select {\n  color: black;\n}\n\n@@media screen and (max-width: 800px) {\n    div#modify-menu {\n        -webkit-box-shadow: none;\n        -moz-box-shadow: none;\n        box-shadow: none;\n        /* font-size: 48px; */\n        bottom: 0px;\n        left: 0px;\n        top: initial;\n        right: initial;\n        height: 40%;\n        width: 100%;\n        min-height: 350px;\n        transform: translate(0px, 100%);\n        padding: 0;\n        padding-bottom: 8px;\n    }\n    div#modify-menu>div.modify-menu-icons.pinned {\n        width: auto;\n        height: var(--context-menu-height);\n        position: absolute;\n        top: calc(0px - var(--context-menu-height));\n        left: 0px;\n    }\n    div#modify-menu>div.modify-menu-icons.pinned span.modify-menu-icon-label {\n        display: none;\n    }\n    div#modify-menu>div.modify-menu-icons.pinned >div.modify-menu-button {\n        height: 50px;\n    }\n    div#modify-menu>div.modify-menu-icons.pinned svg {\n        height: 50px;\n    }\n    div.bottom-placeholder {\n        width: 100%;\n        height: 30%;\n    }\n    :root {\n        --context-menu-height: 48px;\n        --context-menu-button-width: 48px;\n        --context-menu-padding-top: 9px;\n        --context-menu-padding-left: 4px;\n    }\n    /* mobile dom selector */\n    div.dom-selector-style {\n        height: 30%;\n        margin: 0.15em;\n        border-radius: 0.4em;\n        margin: 2%;\n    }\n    div.elementAttr {\n        display: none;\n    }\n    div.mainElem {\n        margin-bottom: 0;\n        height: 56%;\n    }\n    div.childrenSelector {\n        font-size: 1.2em;\n    }\n    div.no-sibling {\n        font-size: 1em;\n    }\n    /* mobile modify menu */\n    div.tagname-summary {\n        padding-left: 10px;\n    }\n    div.information {\n        margin: 2%;\n        margin-top: 0;\n        height: 215px;\n        overflow-y: auto;\n    }\n    div.information>textarea {\n        font-size: 1.2em;\n        border-radius: 0.3em;\n        border: none;\n        padding: 1.5%;\n    }\n    textarea.templateengine {\n        width: 100%;\n        height: 100%;\n        color: black;\n        font-size: 1.4rem;\n        border-radius: 0.4rem;\n        border: 0;\n        padding: 0.4rem;\n    }\n    div.insert-information-style {\n        max-height: 400px;\n        height: 400px;\n    }\n    div.insert-information-style>h1 {\n        margin: 0;\n    }\n}\n\ndiv.editor-modal {\n  display: none; /* Hidden by default */\n  position: fixed; /* Stay in place */\n  z-index: 100002; /* Sit on top */\n  left: 0;\n  top: 0;\n  width: 100%; /* Full width */\n  height: 100%; /* Full height */\n  overflow: auto; /* Enable scroll if needed */\n  background-color: rgb(0,0,0); /* Fallback color */\n  background-color: rgba(0,0,0,0.4); /* Black w/ opacity */\n}\n\n/* Modal Content/Box */\ndiv.editor-modal-content {\n  background-color: #fefefe;\n  margin-left: auto;\n  margin-right: auto;\n  margin-top: 50px;\n  margin-bottom: 50px;\n  padding: 20px;\n  border: 1px solid #888;\n  width: 80%; /* Could be more or less, depending on screen size */\n}\n\n/* The Close Button */\n.editor-close {\n  color: #aaa;\n  float: right;\n  font-size: 28px;\n  font-weight: bold;\n}\n\n.editor-close:hover,\n.editor-close:focus {\n  color: black;\n  text-decoration: none;\n  cursor: pointer;\n}\n</style>\n]\n\ndefaultMarkdowncss = \"\"\"img {\n  max-width: 100%;\n}\npre {\n  padding: 10px 0 10px 30px;\n  color: cornflowerblue;\n}\na {\n  text-decoration: none;\n  font-weight: bold;\n  color: #0268cd;\n}\np {\n  margin: 1.0em 0 1.0em 0;\n}\nbody {\n  text-align: justify;\n  font-family: Geneva, Verdana, sans-serif;\n  line-height: 1.75em;\n  background-color: #C9CFCD;\n}\nh1, h2, h3, h4 {\n  letter-spacing: -1px;\n  font-weight: normal;\n  color: #171717;\n}\nh2 {\n\tfont-size: 2.25em;\n}\nh3 {\n  padding: 25px 0 0 0;\n\tfont-size: 1.75em;\n}\nh4 {\n\tfont-size: 1.25em;\n  margin-top: 1.25em;\n}\n.wrapper {\n  margin-left: auto;\n  margin-right: auto;\n  margin-top: 10px;\n  max-width: 900px;\n  padding-left: 20px;\n  padding-right: 20px;\n  padding-top: 20px;\n  background-color: white;\n}\"\"\"\n\n[\"#document\", [], main]";
const useDefaultServerContent = true;

const defaultHtAccessFileContent = `if Regex.matchIn """\\.\\.(?:/|\\\\)|(?:/|\\\\)\\.\\.|^\\.\\.$""" path then False else
    not (Regex.matchIn """.*\\.pem""" path)`

function readServerFile() {
  if(fs.existsSync(serverFile) && !useDefaultServerContent) {
    return fs.readFileSync(serverFile, "utf8");
  } else
    return defaultServerContent;
}

function readHtAccessFile() {
  if(fs.existsSync(htaccessFile)) {
    return fs.readFileSync(htaccessFile, "utf8");
  } else
    return defaultHtAccessFileContent;
}

const sns = require("sketch-n-sketch");

function evaluateToHtml(path, env, serverFileContent) {
  var result = sns.objEnv.string.evaluateWithoutCache(env)(serverFileContent);
  if(result.ctor == "Ok") {
    var out = sns.valToHTMLSource(result._0);
    if(out.ctor == "Ok") {
      return {ctor: "Ok", out._0.replace(/^<#document>|<\/#document>$/g, "")};
    } else {
      return { ctor: "Err", _0: "Error while converting the result to HTML source file: " + out._0}
    }
  } else {
    return { ctor: "Err", _0: `Error while interpreting ${path}: ` + result._0}
  }
}

function lazyListToList(ll) {
  var x = [];
  while(sns.lazyList.nonEmpty(ll)) {
    x.push(sns.lazyList.head(ll));
    ll = sns.lazyList.tail(ll);
  }
  return x;
}

cachedSolutions = {
  key: {
     timestamp: 0,
     computed: [["html page", "environment vars", "fileOperations"],
                ["html page 2", "environment vars 2", "fileOperations 2..."]],
     remaining: "false, or a LazyList whose head element is last computed solution. Call getOneSolution(this.path, this.serverFileContent, sns.lazyList.tail(remaining)) on it to get one more solution if it exists",
     path: "The path that is being computed",
     serverFileContent: "The original source file of the server. Maybe be overwritten in fileOperations"
  }
}

// Retrieves the given solution by 1-based index from the set of solutions
// If the solution is the last computed, computes remaining solutions
function getSolutionByNum(solutionSet, num) {
  if(solutionSet.computed.length >= num && num >= 1) {
    if(solutionSet.computed.length == num) { // If we select the last computed solution, we checked if we can compute more solutions.
      if(solutionSet.remaining !== false) {
        console.log("Checking for ambiguity #" + (num + 1));
        var lt = sns.lazyList.tail(solutionSet.remaining);
        var newSolution = getOneSolution(solutionSet.path, solutionSet.serverFileContent, lt);
        if(newSolution === false) {
          console.log("No more ambiguity");
          solutionSet.remaining = false;
        } else {
          console.log("Ambiguity #" + (num + 1) + " found");
          solutionSet.remaining = lt;
          solutionSet.computed.push(newSolution);
        }
      }
    }
    return solutionSet.computed[num - 1];
  } else {
    console.log(`Requested invalid solution number ${num}. Returning the first`)
    return solutionSet.computed[0];
  }
}

function uniqueKey() {
  var potentialkey = +(new Date());
  while(typeof cachedSolutions["" + potentialkey] != "undefined") {
    potentialkey++;
  }
  return "" + potentialkey;
}

function envToVars(env) { return env.vars; }

function getOneSolution(path, serverFileContent, allSolutions) {
  if(sns.lazyList.isEmpty(allSolutions)) return false;
  var {_0: newEnv, _1: newServerFileContent} = sns.lazyList.head(allSolutions);
  if(newServerFileContent != serverFileContent) { // server file itself modified from the update method
    var d =
      sns.process(sns.objEnv.string.evaluateWithoutCache({x: serverFileContent, y: newServerFileContent})(`__diff__ x y`))(sns.valToNative)
    var diffsServerFileContent = 
      d.ctor == "Ok" ? d._0 ? d._0.args ? d._0.args._1 ? d._0.args._1.args ? d._0.args._1.args._1 ? d._0.args._1.args._1 :
        false : false : false : false : false : false;

    newEnv.fileOperations.unshift(
      leo.Tuple2(
       serverFile,
       leo.data("Write")(serverFileContent, newServerFileContent,diffsServerFileContent)
       ));
  }
  var fo = newEnv.fileOperations;
  var evaluated = evaluateToHtml(path, newEnv, newServerFileContent);
  return [evaluated, envToVars(newEnv), fo]; 
  // Evaluates everything given the temporary context of writing the files.
}

// Apply the given operations to the file system. TODO: Merge different writes to a single file.
function applyOperations(operations) {
  for(var i = 0; i < operations.length; i++) {
    var {_1: path, _2: action} = operations[i];
    if(action["$d_ctor"] == "Write") {
      fs.writeFileSync(path, action.args._2, "utf8");
    } else if(action["$d_ctor"] == "Create") {
      // TODO: Create the path if necessary
      fs.writeFileSync(path, action.args._1, "utf8");
    } else if(action["$d_ctor"] == "Rename") {
      if(path.startsWith("/")) path = path.substring(1);
      var newName = action.args._1;
      if(newName.startsWith("/")) newName = newName.substring(1);
      fs.renameSync(path, newName);
    } else if(action["$d_ctor"] == "Delete") {
      fs.unlinkSync(path);
    } else {
      console.log("unrecognized action:", action);
    }
  }
}

function stringDiffSummary(oldString, newString, stringDiffs) {
  if(stringDiffs["$d_ctor"] == "Nothing") return "[No change observed]";
  if(stringDiffs["$d_ctor"] == "Just") stringDiffs = stringDiffs.args._1;
  var listStringDiffs = stringDiffs.args._1; // It's a VStringDiffs
  var offset = 0;
  var summary = "";
  var lastLineNumber = -1;
  var lastEnd = -1;
  var lastLine = "";
  var lastLineAfterRemoved = "";
  for(var i = 0; i < listStringDiffs.length; i++) {
    var {args: {_1: start, _2: end, _3: replaced}} = listStringDiffs[i];
    var removed = oldString.substring(start, end);
    var inserted = newString.substring(start + offset, start + offset + replaced);
    var beforeRemoved = oldString.substring(0, start);
    var afterRemoved = oldString.substring(end);
    var linesBeforeRemoved = beforeRemoved.split(/\r?\n/);
    var lineNumber = linesBeforeRemoved.length;
    var charNumber = linesBeforeRemoved[linesBeforeRemoved.length - 1].length + 1;
    var lineBeforeRemoved = linesBeforeRemoved[linesBeforeRemoved.length - 1];
    var lineAfterRemoved = afterRemoved.split(/\r?\n/)[0];
    if(lineNumber === lastLineNumber) {
      summary += oldString.substring(lastEnd, start);
    } else {
      summary += lastLineAfterRemoved + "\nL" + lineNumber + "C" + charNumber + ":" +
        lineBeforeRemoved;
    }
    summary +=
          (removed === "" ? "" : "(---" + removed + "---)") +
          (inserted === "" ? "" : "(+++" + inserted + "+++)");
    lastEnd = end;
    lastLineAfterRemoved = lineAfterRemoved;
    offset += replaced - (end - start);
    lastLineNumber = lineNumber;
  }
  summary += lastLineAfterRemoved;
  return summary;
}

function relativePath(filepath) {
  return filepath.substring(path.length);
}

function fileOperationSummary(operations) {
  if(operations == null) return "";
  var summary = "";
  for(var i = 0; i < operations.length; i++) {
    var {_1: filepath, _2: action} = operations[i];
    if(summary != "") summary += "\n";
    if(action["$d_ctor"] == "Write") {
      summary += relativePath(filepath) + ": " + stringDiffSummary(action.args._1, action.args._2, action.args._3);
    } else if(action["$d_ctor"] == "Create") {
      summary += "Created " + relativePath(filepath);
    } else if(action["$d_ctor"] == "Rename") {
      summary += "Renamed " + relativePath(filepath) + " to " + action.args._1;
    } else if(action["$d_ctor"] == "Delete") {
      summary += "Deleted " + relativePath(filepath);
    } else {
      console.log("unrecognized action:", action);
    }
  }
  return summary;
}

function detectHydefile($name) {
  if($name.length > 0 && $name.substring($name.length - 1,  $name.length) === "/") {
    $name = $name.substring(0, $name.length - 1);
  }
  let $hydefile = null, $result;
  while($name.length > 0) {
    $namex = $name == "" ? "" : `${$name}/`;
    if(fs.existsSync($namex+"hydefile.leo")) {
      $hydefile = $namex+"hydefile.leo"; break;
    }
    if(fs.existsSync($namex+"hydefile.elm")) {
      $hydefile = $namex+"hydefile.elm"; break;
    }
    if(fs.existsSync($namex+"hydefile")) {
      $hydefile = $namex+"hydefile"; break;
    }
    $newname = $name.replace(/\/[^\/]*$/,"");
    if($newname === $name) { // No more slashes
      $name = "";
    } else {
      $name = $newname;
    }
  }
  if($hydefile != null) {
    $result = {file : $hydefile};
    if(fs.existsSync($namex+".hydecache")) {
      $result["cache"] = fs.readFileSync($namex+".hydecache", "utf8");
      $result["cachefile"] = $namex+".hydecache";
    }
  } else {
    $result = {};
  }
  return $result;
}

function pushResultOn(array) {
  return name => { array.push(name); return 0 }
}

// Returns a [Result of string containing the requested page, new overrides]
// If newvalue is defined, performs an update before returning the page.
function loadpage(path, vars, user, newvalue) {
  // __dirname = path.resolve(); // If in the REPL
  if(typeof vars != "object") vars = {};
  var serverFileContent = readServerFile();
  var hydefilecache = defaultOptions.hyde ? detectHydefile(path) : undefined;
  console.log("hydefilecache", hydefilecache)
  var filesToWatch = [];
  var foldersToWatch = [];
  var generatedFiles = [];
  var writtenFiles = [];
  var env = {
      googleClientId: googleClientId,
      vars: vars,
      user: toLeoQuery(user || {}),
      defaultOptions: toLeoQuery(defaultOptions).concat(
          hydefilecache ? [leo.Tuple2("hydefilecache", hydefilecache)] : []),
      path: path,
      fileOperations: [] };
  if(hydefilecache) {
    env["recordFileRead"] = pushResultOn(filesToWatch);
    env["recordFolderList"] = pushResultOn(foldersToWatch);
    env["recordOutputFiles"] = tuplesToWrite => {
      writtenFiles = tuplesToWrite.map(({_1}) => _1);
      alwaysWriteAll(tuplesToWrite);
      return 0;
    }
  }
  if(typeof newvalue == "undefined") {
    let result = [evaluateToHtml(path, env, serverFileContent), vars];
    if(hydefilecache.cache) {
      console.log("overriding cache", [filesToWatch, foldersToWatch, writtenFiles, hydefilecache.cachefile]);
      let newCacheContent =
            sns.valToNative(sns.objEnv.string.evaluateWithoutCache(
              {a: {inputFiles: filesToWatch,
                   inputFolders: foldersToWatch,
                   outputFiles: writtenFiles
               }})("toString a")._0)._0;
      console.log("set cache to write");
      alwaysWrite(hydefilecache.cachefile, newCacheContent);
    }
    return result;
  } else { // We update the page and re-render it.
    var newVal = sns.nativeToVal(newvalue);
    console.log("Started to update...");
    var result = sns.objEnv.string.updateWithoutCache(env)(serverFileContent)(newVal);
    console.log("Update finished (first solution)");
    if(result.ctor == "Ok") {
      var allSolutions = result._0;
      // Instead of iterating through all the solutions, just detect if there is an ambiguity.
      var solution = getOneSolution(path, serverFileContent, allSolutions);
      if(solution === false) {
        return [{ctor: "Err", _0: "Empty list of solutions"}];
      } else {
        console.log("Checking for ambiguities");
        var allSolutionsTail = sns.lazyList.tail(allSolutions);
        var solution2 = getOneSolution(path, serverFileContent, allSolutionsTail);
        if(solution2 === false) { // No ambiguity, we can immediately process the change.
          console.log("No ambiguity");
          return solution;
        } else {
          console.log("Ambiguity found");
          var solutionKey = uniqueKey();
          var cachedSolution = {
              timestamp: (+ new Date()),
              computed: [solution, solution2],
              remaining: allSolutionsTail,
              path: path,
              serverFileContent: serverFileContent
          }
          cachedSolutions[solutionKey] = cachedSolution;
          return solution.concat(solutionKey);
        }
      }
    } else return [result];
  }
}

function toLeoQuery(query) {
  var result = [];
  for(key in query) {
    result.push(leo.Tuple2(key, query[key]));
  }
  return result;
}

var willkill = undefined;

var key = fs.existsSync(defaultOptions.key) ? fs.readFileSync(defaultOptions.key) : null;
var cert = fs.existsSync(defaultOptions.cert) ? fs.readFileSync(defaultOptions.cert) : null;
var httpsOptions = { key: key, cert: cert };
var protocol = key && cert ? "https" : "http";
var httpOrHttps = require(protocol);
if(protocol == "http") {
  console.log(`${defaultOptions.key} (--key) and/or ${defaultOptions.cert} (--cert) files missing. Starting http server instead of https.`);
}

function combinePath(prefix, path) {
  return (prefix == "" ? "." : prefix) + "/" + (path && path.length && path[0] === "/" ? path.substring(1) : path);
}

function alwaysWrite($name, $content) {
  if (!fs.lstatSync($name).isDirectory(fspath.dirname($name))) {
    fs.mkdirSync(fspath.dirname($name), { recursive: true });
  }
  fs.writeFileSync($name, $content, "utf8");
}

function alwaysWriteAll($toWrite, callback) {
  for(let $nameContent of $toWrite) {
      alwaysWrite($nameContent._1, $nameContent._2);
      if(callback) callback($nameContent);
  }
}

const server = httpOrHttps.createServer(httpsOptions, (request, response) => {
  var requestURL = request.headers["url"] ? request.headers["url"] : request.url; // Possibility to override the URL.
  var urlParts = url.parse(requestURL, parseQueryString=true);
  var query = toLeoQuery(urlParts.query);
  var pn = urlParts.pathname;
  var path = decodeURIComponent(pn.length && pn[0] == "/" ? pn.substring(1) : pn); // Without the slash.
  var accessResult = sns.objEnv.string.evaluateWithoutCache({path:path,method:request.method})(readHtAccessFile());
  var access = sns.process(accessResult)(sns.valToNative);
  var header = 'text/html; charset=utf-8';
  if(access.ctor == "Err") {
    console.log("Error in htaccess", access._0);
    response.setHeader('Content-Type', header);
    response.statusCode = 500;
    response.end(`<html><body style="color:#cc0000" class="editor-error"><div   style="max-width:600px;margin-left:auto;margin-right:auto"><h1>htaccess.elm internal Error report</h1><pre style="white-space:pre-wrap">${access._0}</pre></div></body></html>`);
  } else if(access._0) {
    if(typeof willkill != "undefined") {
      clearTimeout(willkill);
      willkill = undefined;
    }
    if(request.method == "GET") {
      let $action = request.headers["action"];
      let $name = request.headers["name"];
      if(typeof $action != "undefined" && typeof $name != "undefined") { // AJAX requests to read info from the file system
        if($name.substring(0, 1) === "/") {
          $name = $name.substring(1);
        }
        if($action == "isdir") {
          response.statusCode = 200;
          if($name == "") $name = ".";
          response.end(fs.existsSync($name) && fs.lstatSync($name).isDirectory() || $name == "." || $name == ""  ? "true" : "false");
          return;
        } else if($action == "isfile") {
          response.statusCode = 200;
          response.end(fs.existsSync($name) && fs.lstatSync($name).isFile() ? "true" : "false");
          return;
        } else if($action == "listdir") {
          response.statusCode = 200;
          if($name == "") $name = ".";
          response.end(JSON.stringify((fs.readdirSync($name) || []).filter(i => i != "." && i != "..")));
          return;
        } else if($action == "read") {
          response.statusCode = 200;
          if(fs.existsSync($name)) {
            response.end(fs.readFileSync($name));
          } else {
            response.statusCode = 404;
            response.end("");
          }
          return;
        } else if ($action=="fullListDir") {
          if($name == "") $name = ".";
          let $result =
            (fs.readdirSync($name, {withFileTypes: true}) || [])
            .filter(f => f.name != "." && f.name != "..")
            .map(f => [f.name, f.isDirectory()]);
          response.statusCode = 200
          response.end(JSON.stringify($result));
          return;
        } else {
          response.statusCode = 500;
          response.end("Unsupported read action for this user: $action, $userId"); 
          return;
        }
      }
      var header = path.endsWith(".ico") ? "image/ico" : header;
      var header = path.endsWith(".jpg") ? "image/jpg" : header;
      var header = path.endsWith(".gif") ? "image/gif" : header;
      var header = path.endsWith(".png") ? "image/png" : header;
      var header = path.endsWith(".svg") ? "image/svg+xml" : header;
      var header = path.endsWith(".css") ? "text/css; charset=utf-8" : header;
      if(!header.startsWith("image/") && !header.startsWith("text/css")) {
        var [htmlContent] = loadpage(path, query, undefined);
        response.setHeader('Content-Type', header);
        response.statusCode = 200;
        if(htmlContent.ctor == "Err") {
          response.end(`<html><body style="color:#cc0000" class="editor-error"><div   style="max-width:600px;margin-left:auto;margin-right:auto"><h1>Internal Error report</h1><pre style="white-space:pre-wrap">${htmlContent._0}</pre></div></body></html>`);
        } else {
          response.end(htmlContent._0);
        }
      } else {
        response.setHeader('Content-Type', header);
        let expectedFilePath = combinePath(defaultOptions.path, path);
        if(fs.existsSync(expectedFilePath)) {
          var content = fs.readFileSync(expectedFilePath);
          response.statusCode = 200;
          response.end(content);
        } else {
          response.statusCode = 404;
          response.end(`<html>body>${path} not found</body></html>`);
        }
      }
    } else if(request.method == "POST") {
      const chunks = [];
      request.on('data', chunk => chunks.push(chunk));
      request.on('end', function () {
        var allChunks = Buffer.concat(chunks);
        // Start ajax requests to modify the file system.
        let $action = request.headers["action"];
        let $name = request.headers["name"];
        if(typeof $action != "undefined" && typeof $name != "undefined") {
          $content = allChunks.toString();
          if($action == "write" || $action == "create") {
            if (!fs.lstatSync($name).isDirectory(fspath.dirname($name))) {
              fs.mkdirSync(fspath.dirname($name), { recursive: true });
            }
            fs.writeFileSync($name, $content, "utf8");
            response.statusCode = 200;
            if($action == "create") {
              response.end(`Written ${$name}`);
            } else {
              response.end(`Created ${$name}`);
            }
            return;
          } else if($action == "writeall") {
            let $toWrite = JSON.parse($content);
            let $i = 0;
            let msg = "";
            alwaysWriteAll($toWrite, $nameContent => {
              msg += "Written " + $nameContent._1 + "\n";
             $i = $i + 1;
            });
            response.end(msg + `\n$i files written`);
          } else if($action == "rename") {
            fs.renameSync($name, $content);
            response.statusCode = 200;
            response.end(`Renamed ${$name} to ${$content}`);
            return;
          } else if($action == "delete") {
            fs.unlinkSync($name);
            response.statusCode = 200;
            response.end(`Deleted ${$name}`);
            return;
          } else {
            response.statusCode = 500;
            response.end(`Unsupported write action for this user: ${$action}, ${userId}`)
            return;
          }
        } else if(request.headers["location"]) { // File overwriting
          $location = request.headers["location"];
          $location = $location.length && $location[0] == "/" ? $location.substring(1) : $location;
          $content = allChunks.toString();
          responde.send(`Writing ${location} whatever received on POST data`);
          fs.writeFileSync($location, $content, "utf8");
          responde.end(`Finished to write to $location`);
          return;
        }
        // End ajax requests

        if(defaultOptions.closeable && request.headers["close"]) {
          willkill = setTimeout(() => process.exit(), timeBeforeExit); // Kills the server after 2 seconds if the webpage is not requested.
          response.statusCode = 200;
          response.end('');
          return;
        } else if(request.headers["write-file"]) { // With this and with the correct permissions, we can overwrite any file.
          console.log("going to write file");
          // Just a file that we write on disk.
          var imageType = request.headers["write-file"];
          var imageLocation = combinePath(defaultOptions.path, path);
          console.log("going to write image file to ", imageLocation);
          fs.writeFileSync(imageLocation, allChunks);
          response.statusCode = 201;
          response.end('');
          return;
        }
        
        var continueWithLoading = (userdata) => {
          var canAskQuestion = (request.headers["question"] || urlParts.query["question"] || (defaultOptions.questions ? "true" : "false")) == "true";
          var body =  allChunks.toString();
          var ambiguityKey = request.headers["ambiguity-key"];
          var numberOfSolutionsSoFar = 2; // Only if Ambiguity-Key is set.
          var numSolutionSelected = 1;
          var htmlContent = {ctor:"Err", _0: "Not yet defined"};
          var newQuery = [];
          var fileOperations = [];
          var ambiguitiesSummary = [];
          if(ambiguityKey !== null && typeof ambiguityKey !== "undefined") {
            var selectAmbiguityStr = request.headers["select-ambiguity"];
            if(selectAmbiguityStr != null) {
              numSolutionSelected = JSON.parse(selectAmbiguityStr);
              var solutionSet = cachedSolutions[ambiguityKey];
              if(typeof solutionSet != "undefined") {
                [htmlContent, newQuery, fileOperations] = getSolutionByNum(solutionSet, numSolutionSelected);
                numberOfSolutionsSoFar = solutionSet.computed.length;
                ambiguitiesSummary = solutionSet.computed.map(a => fileOperationSummary(a[2]));
              } else {
                htmlContent = {ctor:"Err", _0: "Solution set not found"};
              }
            } else {
              var acceptAmbiguityStr = request.headers["accept-ambiguity"];
              if(acceptAmbiguityStr != null) {
                var acceptAmbiguity = JSON.parse(acceptAmbiguityStr);
                var solutionSet = cachedSolutions[ambiguityKey];
                [htmlContent, newQuery, fileOperations] = getSolutionByNum(solutionSet, acceptAmbiguity);
                ambiguityKey = undefined;
              } else {
                var cancelAmbiguityStr = request.headers["cancel-ambiguity"];
                if(cancelAmbiguityStr != null) {
                  ambiguityKey = undefined;
                  [htmlContent, newQuery, fileOperations] = loadpage(path, query, userdata);
                  fileOperations = [];
                } else {
                  htmlContent = {ctor:"Err", _0: "Solution set not found."};
                }
              }
            }
          } else if(request.headers["reload"]) {
            [htmlContent, newQuery, fileOperations] = loadpage(path, query, userdata);
          } else {
            var pushedValue = JSON.parse(body);
            [htmlContent, newQuery, fileOperations, ambiguityKey] = loadpage(path, query, userdata, pushedValue);
          }
          response.statusCode = 201;
          response.setHeader('Content-Type', 'text/html; charset=utf-8');
          if(htmlContent.ctor == "Err") {
            response.end(`<html><body style="color:#cc0000" class="editor-error"><div   style="max-width:600px;margin-left:auto;margin-right:auto"><h1>Internal Error report</h1><pre style="white-space:pre-wrap">${htmlContent._0}</pre></div></body></html>`)
          } else {
            if(typeof request.headers["url"] === "string") {
              response.setHeader("New-Local-URL", request.headers["url"]);
            }
            response.setHeader('New-Query', JSON.stringify(newQuery));
            if(ambiguityKey != null && typeof ambiguityKey != "undefined" &&
               !path.endsWith(".html") && canAskQuestion &&
               (urlParts.query["edit"] == "true" || (urlParts.query["edit"] == null && defaultOptions.edit))) {
              var solutionSet = cachedSolutions[ambiguityKey];
              var ambiguityEnd = solutionSet.remaining === false;
              ambiguitiesSummary = solutionSet.computed.map(a => fileOperationSummary(a[2]));
              response.setHeader('Ambiguity-Key', ambiguityKey);
              response.setHeader('Ambiguity-Number', JSON.stringify(numberOfSolutionsSoFar));
              response.setHeader('Ambiguity-Selected', JSON.stringify(numSolutionSelected));
              response.setHeader('Ambiguity-Summaries', JSON.stringify(ambiguitiesSummary));
              response.setHeader('Ambiguity-End', ambiguityEnd ? "true" : "false");
            } else {
              if(fileOperations) {
                applyOperations(fileOperations);
                response.setHeader('Operations-Summary', encodeURI(fileOperationSummary(fileOperations)));
              }
            }
            response.end(htmlContent._0);
          }
        }
        
        var token = request.headers["id-token"];
        if(token) {
          const {OAuth2Client} = require('google-auth-library');
          const client = new OAuth2Client(googleClientId);
 
          async function verify() {
            const ticket = await client.verifyIdToken({
                idToken: token,
                audience: googleClientId // Array of client ids if multiple clients access the backend.
            });
            const userdata = ticket.getPayload();
            continueWithLoading(userdata); // Only authenticated users can access their information. Great!
          }
          verify().catch(err => {
            console.log(err);
            continueWithLoading(undefined);            
          });
          return;
        } else {
          continueWithLoading(undefined);
        }
      });
    } else {
      response.statusCode = 400;
      response.end("Unknown method");
    }
  } else {
    response.statusCode = 401;
    response.end(`<html><body style="color:#cc0000" class="editor-error"><div   style="max-width:600px;margin-left:auto;margin-right:auto"><h1>Unauthorized access to ${path}</h1></div></body></html>`);
  }
});

port = await getPort({host: hostname, port: [port, 3000, 3001, 3002, 3003, 3004]})

// Load the Elm program into our namespace.
server.listen(port, hostname, () => {
  console.log("Editor Server serving path " + defaultOptions.path);
  if(defaultOptions.edit) {
    console.log("Edit mode:     activated.    (toggle option: 'edit=false')");
  } else {
    console.log("Edit mode:     deactivated.  (toggle option: 'edit=true')");
  }
  if(defaultOptions.autosave) {
    console.log("Autosave mode: activated.    (toggle option: 'autosave=false')");
  } else {
    console.log("Autosave mode: deactivated.  (toggle option: 'autosave=true')");
  }
  if(defaultOptions.question) {
    console.log("Questions:     activated.    (toggle option: 'question=false')");
  } else {
    console.log("Questions:     deactivated.  (toggle option: 'question=true')");
  }
  console.log("To toggle any of these options in the browser, join these toggle options using '&', prefix this with '?', and append the result to any URL, ");
  console.log(`Point your browser at ${protocol}://${hostname}:${port}`);
});

if(fileToOpen) {
  var opn = require('opn');

  // opens the url in the default browser 
  opn(protocol + "://" + hostname + ":" + port + "/" + fileToOpen);
} else if(defaultOptions.openbrowser) {
  var opn = require('opn');

  // opens the url in the default browser 
  opn(protocol + "://" + hostname + ":" + port);
}
} // async declaration of start()

// Never called when starting the server from command-line.
module.exports = function(requireOptions) {
  if(!requireOptions) {
    start();
    return;
  } else {
    for(var k in requireOptions) {
      defaultOptions[k] = requireOptions[k];
    }
    start();
    return;
  }
}


