
var params = process.argv.slice(2);

function getParam(x, defaultValue) {
  var param = params.find(elem => elem.startsWith(x));
  if(typeof param !== "undefined") {
    var returnValue = param.substring(x.length + 1);
    if(returnValue == "") return defaultValue;
    return returnValue;
  } else {
    return defaultValue;
  }
}

function existsParam(x) {
  var param = params.find(elem => elem == x);
  return typeof param !== "undefined";
}

function isBoolParamTrue(x) {
  return existsParam(x) || getParam(x, "false") == true;
}

function getNonParam() {
  return params.find(elem => !elem.startsWith("-"))
}

const fs = require("fs");
const fspath = require('path');
const https = require('https');
//const http = require('http');
const url = require('url');
const hostname = getParam("hostname", 'localhost');
var port = parseInt(getParam("port", "3000"));

// The default client id is suitable only for localhost:3000
var googleClientId = getParam("google-client-id", "844835838734-2iphm3ff20ephn906md1ru8vbkpu4mg8.apps.googleusercontent.com");

const getPort = require('get-port');

const serverFile = "./server.elm";
const htaccessFile = "./htaccess.elm";
var path =  getParam("--path",    "");
var question = getParam("--question", "true") == "true";
var autosave = getParam("--autosave", "false") == "true";

var fileToOpen = getNonParam();
if(fileToOpen) {
  if(fileToOpen.indexOf("/") == -1 && fileToOpen.indexOf("\\") == -1) {
    path = "";
  } else {
    path = fileToOpen.replace(/[\/\\][^\/\\]*$/g, "");
  }
  fileToOpen = fileToOpen.replace(/.*[\/\\](?=[^\/\\]*$)/g, "");
  question = false; // When opening a file, by default we should not ask questions.
  autosave = false; // When opening a file, by default we want to let the user save it.
}
var timeBeforeExit = 2000; // Number of ms after receiving the closing signal (if file open) to kill the server.


leo = {};
leo.data = function(name) {
  return function() {
    let args = {};
    for(let i = 1; i <= arguments.length; i++) {
      args["_" + i] = arguments[i - 1];
    }
    return {"$d_ctor": name, args: args};
  }
}
leo.Just = leo.data("Just")
leo.Nothing = leo.data("Nothing")()
leo.Tuple2 = function(a, b) {
  return {"$t_ctor": "Tuple2", _1: a, _2: b}
}

var defaultOptions = {
  edit:     getParam("--edit",     "true") == "true",
  autosave: autosave,
  question: question,
  admin:    isBoolParamTrue("--admin"),
  production:    isBoolParamTrue("--production"),
  path:     path,
  closeable: !(!(fileToOpen)),
  openbrowser: isBoolParamTrue("--openbrowser"),
  key: "localhost-key.pem",
  cert: "localhost.pem",
  hyde: getParam("--hyde", "true") == "true"
};

async function start() {

// Don't modify, this will be replaced by the content of 'server.elm'
const defaultServerContent = "-- input: path            The file to serve.\n-- input: vars:           URL query vars.\n-- input: urlParams:      The URL params plainly\n-- input: defaultOptions  default options (options that vars can override for certain parts).\n--                        If nodefs is set, will use it instead of nodejs.nodeFS\n--                        If browserSide is set, will use a different kind of request. \n-- input: fileOperations  The current set of delayed file disk operations.\n--    Note that Elm pages are given in context the path, the vars, and the file system (fs) to read other files\n-- output: The page, either (almost) uninstrumented or augmented with the toolbar and edit scripts.\n\n{--------------------------------------------------------\n    Permission handling, file system, options processing\n---------------------------------------------------------}\nlistGetOrElse key listDict default = listDict.get key listDict |> Maybe.withDefault default\n\n{--}\nupdatecheckpoint name x = {\n  apply x = x\n  update {input, outputNew, diffs} =\n    let _ = Debug.log \"\"\"Checkpoint @name\"\"\" () in  \n    Ok (InputsWithDiffs [(outputNew, Just diffs)])\n}.apply x\n\ndebugcheckpoint name x = let _ = Debug.log name () in x\n--}\n\npreludeEnv = let _ = googlesigninbutton in -- Forces googlesigninbutton to be evaluated before preludeEnv\n  __CurrentEnv__\n\nmbApplyPrefix = case listDict.get \"path\" defaultOptions of\n  Just \"\" -> Nothing\n  Nothing -> Nothing\n  Just prefix -> Just (\\name -> if name == \"\" then prefix\n      else if Regex.matchIn \"/$\" prefix then prefix + name\n      else prefix + \"/\" + name)\n\ndirectReadFileSystem =\n  listDict.get \"nodefs\" defaultOptions |> Maybe.withDefault nodejs.nodeFS\n\nfs = nodejs.delayedFS directReadFileSystem fileOperations\n\nhydefilecache = listDict.get \"hydefilecache\" defaultOptions\n\nfs = case mbApplyPrefix of\n  Nothing -> fs\n  Just applyPrefix -> { fs |\n    read name = fs.read (applyPrefix name)\n    listdir name = fs.listdir (applyPrefix name)\n    listdircontent name = fs.listdircontent (applyPrefix name)\n    isdir name = fs.isdir (applyPrefix name)\n    isfile name = fs.isfile (applyPrefix name)\n  }\n\neditdelay = 1000\n\nboolVar name resDefault =\n  listDict.get name vars |>\n  Maybe.map (\\original ->\n    Update.bijection\n      (case of \"true\" -> True; \"\" -> True; _ -> False)\n      (case of True -> if original == \"true\" || original == \"\" then original else \"true\"; _ -> \"false\") original) |>\n  Maybe.withDefaultReplace (\n    listDict.get name defaultOptions |> Maybe.withDefault resDefault |> freeze)\n\nbrowserSide = listDict.get \"browserSide\" defaultOptions == Just True\n\nvaradmin = boolVar \"admin\" False\nvarraw = boolVar \"raw\" False\nvaredit = boolVar \"edit\" False || varraw\nvarls = boolVar \"ls\" False\ndefaultVarEdit = listDict.get \"edit\" defaultOptions |> Maybe.withDefault False\nvarproduction = listDict.get \"production\" defaultOptions |> Maybe.withDefault (freeze False)\niscloseable = listDict.get \"closeable\" defaultOptions |> Maybe.withDefault (freeze False)\n\nuserpermissions = {pageowner= True, admin= varadmin}\npermissionToCreate = userpermissions.admin\npermissionToEditServer = boolVar \"superadmin\" False -- should be possibly get from user authentication\n-- List.contains (\"sub\", \"102014571179481340426\") user -- That's my Google user ID.\n\ncanEditPage = userpermissions.pageowner && varedit && not varls\n\nfreezeWhen = Update.freezeWhen\n\nserverOwned what obj = freezeWhen (not permissionToEditServer) (\\od -> \"\"\"You tried to modify @what, which is part of the server. We prevented you from doing so.<br><br>\n\nIf you really intended to modify this, add ?superadmin=true to the URL and redo this operation. This is likely going to create or modify the existing <code>server.elm</code> at the location where you launched Editor.<br><br>\n\nFor debugging purposes, below is the new value that was pushed:\n<pre>@(Regex.replace \"<\" (always \"&lt;\") \"\"\"@od\"\"\")</pre>\nHere is the old value that was computed\n<pre>@(Regex.replace \"<\" (always \"&lt;\") \"\"\"@obj\"\"\")</pre>\n\"\"\") obj\n\ncanEvaluate = listDict.get \"evaluate\" vars |> Maybe.withDefaultReplace (serverOwned \"default value of evaluate\" \"true\")\n\n{--------------------------------------------------------\n Rewrite path to either a folder or a default file under\n---------------------------------------------------------}\n\npath: String\npath =\n  if fs.isdir path then\n   if not varls then\n     List.mapFirstSuccess (\\test ->\n       if fs.isfile <| path + test then Just (path + test) else Nothing)\n       [\"index.elm\" , \"/index.elm\", \"index.html\", \"/index.html\", \"README.md\" , \"/README.md\" ]\n     |> Maybe.withDefault path\n   else path\n  else path\n\n{---------------------------------------------------------------------------\n Retrieves the string content of the path. For folders, creates a custom page\n----------------------------------------------------------------------------}\n\nmbDotEditorFile = \n  let prefix = Regex.extract \"^(.*/)[^/]*$\" path |> Maybe.map (\\[prefix] -> prefix) |> Maybe.withDefault \"\" in\n  let dotEditor = prefix +  \".editor\" in\n  fs.read dotEditor\n\napplyDotEditor source = \n  let prefix = Regex.extract \"^(.*/)[^/]*$\" path |> Maybe.map (\\[prefix] -> prefix) |> Maybe.withDefault \"\" in\n  let dotEditor = prefix +  \".editor\" in\n  case mbDotEditorFile of\n    Nothing -> source\n    Just modifier ->\n      case __evaluate__ ((\"vars\", vars)::(\"path\", path)::(\"fs\", fs)::(\"content\", source)::preludeEnv) modifier of\n        Err msg -> let _ = Debug.log (\"Error while executing \" + dotEditor + \" : \" + msg) () in\n          source\n        Ok newSource -> newSource\n\nisTextFile path =\n  Regex.matchIn \"\"\"\\.(?:txt|css|js|sass|scss)$\"\"\" path\n\n---------------------\n-- Hyde file support.\n-- Everything unrolled on the main let definitions to benefit from caching\n---------------------\n\n(withoutPipeline, hydefilepath, hydefileSource) = case hydefilecache of\n  Just {file=hydefile} ->\n    case hydefilecache of\n      Just {cacheContent} ->\n        case evaluate cacheContent of\n          {inputFiles, outputFiles} ->\n            (List.find (\\e -> e == path || e == \"/\" + path) inputFiles == Nothing &&\n             List.find (\\e -> e == path || e == \"/\" + path) outputFiles == Nothing,\n               hydefile, fs.read hydefile)\n          _ -> (False, hydefile, fs.read hydefile)\n      _ -> (False, hydefile, fs.read hydefile) -- Need to recompute the cache anyway\n  _ -> (True, \"\", Nothing)\n\n(folderView, mbSourcecontentAny1, hydeNotNeeded): (Boolean, Maybe String, Boolean)\n(folderView, mbSourcecontentAny1, hydeNotNeeded) =\n  if path == \"server.elm\" then\n    (False, Just \"\"\"<html><head></head><body>The Elm server cannot display itself. This is a placeholder</body></html>\"\"\", True)\n  else if fs.isdir path then\n    (True, Just \"\", True)\n  else if fs.isfile path && Regex.matchIn \"\"\"\\.(png|jpg|ico|gif|jpeg)$\"\"\" path then -- Normally not called because server.js takes care of these cases.\n    (False, Just \"\"\"<html><head><title>@path</title></head><body><img src=\"@path\"></body></html>\"\"\", True)\n  else if hydefilecache == Nothing || withoutPipeline || varraw then\n    (False, fs.read path, True)\n  else\n    (False, Nothing, False)\n\nhyde_sourceRaw = if hydeNotNeeded then \"\" else\n  hydefileSource |> Maybe.withDefaultLazy (\\_ -> \"\"\"all = [Error \"hyde file '@hydefilepath' not found?!\"]\"\"\")\n\nhyde_source = if hydeNotNeeded then \"\" else\n  hyde_sourceRaw + Update.freeze \"\\n\\nlet t = \" + (listDict.get \"task\" vars |> Maybe.withDefault \"all\") + \"\\n    t = if typeof t == 'function' then t () else t\\n    t = if typeof t == 'list' then t else [t]\\nin t\"\n\nhyde_fileDirectory = if hydeNotNeeded then \"\" else\n  Regex.replace \"/[^/]*$\" \"\" hydefilepath\n\nhyde_inDirectory name =\n  if hyde_fileDirectory == \"\" then name else\n    hyde_fileDirectory  + \"/\" + name\n\nhyde_fs = \n  if hydeNotNeeded then {} else\n  let hyde_fsReadRecord = \n        { directReadFileSystem |\n          read name =\n            let name = hyde_inDirectory name in\n            let _ = recordFileRead name in\n            fs.read name,\n          listdir name =\n            let name = hyde_inDirectory name in\n            let _ = recordFolderList name in\n            fs.listdir name\n        } in\n  nodejs.delayedFS hyde_fsReadRecord <|\n  Update.lens {\n    apply = identity\n    update {outputNew, diffs} = -- input and outputOld were empty, diffs is valid\n    -- We just need to change the paths\n      outputNew |>\n      List.map (case of\n        (name, Rename newName) -> (hyde_inDirectory name, Rename (hyde_inDirectory newName))\n        (name, x) -> (hyde_inDirectory name, x))|>\n      flip (,) (Just diffs) |>\n      List.singleton |> InputsWithDiffs |> Ok\n  } fileOperations\n\n-- A Hyde plug-is a function that transforms a list of Write into another list of Write\nplugin name =\n  fs.read (hyde_inDirectory (\"hydefile-plugin-\" + name + \".leo\")) |>\n  Maybe.andThen (\\plugin_content ->\n    case __evaluate__ ((\"fs\", hyde_fs)::(\"plugin\", plugin)::preludeEnv) plugin_content of\n      Ok x -> Just x\n      Err msg -> \n        let _ = Debug.log (\"loading of plugin \" + name + \" failed:\" + msg) () in\n        Nothing\n  ) |> Maybe.withDefaultLazy (\\_ ->\n   let _ = Debug.log (\"plugin \" + name + \" not found\") () in\n   \\options -> identity)\n\nhyde_resEvaluatedHydeFile =\n  if hydeNotNeeded then {} else\n  __evaluateWithCache__ ((\"fs\", hyde_fs)::(\"plugin\", plugin)::preludeEnv) hyde_source\n\n(hyde_generatedFilesDict, hyde_errors) =\n  if hydeNotNeeded then (False, False) else\n  case hyde_resEvaluatedHydeFile of\n    Err msg -> ([], msg)\n    Ok (writtenContent, _) ->\n      let (written, errors) = List.partition (case of Write -> True; _ -> False) writtenContent in\n      let tuplesToWrite =\n            List.map (case of Write name content -> (hyde_inDirectory name, content)) written\n          joinedErrors = \n            List.map (case of Error msg -> msg) errors |> String.join \"\\n\"\n      in\n      (tuplesToWrite, joinedErrors)\n\nhyde_record_output_files =\n  if hydeNotNeeded then False else\n  let hyde_dummy = recordOutputFiles hyde_generatedFilesDict in  -- Writes on disk \n  False\n\nhyde_dummy = if hydeNotNeeded then (False, False) else\n  let x = hyde_generatedFilesDict in -- to make sure dependency is executed\n  if hyde_errors == \"\" then\n    cacheResult () -- Caches the names of written files\n  else \n    ()\n\nmbSourcecontentAny =\n  if hydeNotNeeded then mbSourcecontentAny1 else\n  case listDict.get (\"/\" + path) hyde_generatedFilesDict of\n    Nothing ->\n      case listDict.get path hyde_generatedFilesDict of\n        Nothing ->\n          if hyde_errors == \"\" then\n            let _ = Debug.log \"\"\"Unable to read (/)@path from output of hydefile\"\"\" () in\n            fs.read path\n          else\n            Just <|\n            serverOwned \"error recovery of hyde build tool\" <|\n            \"\"\"<html><head></head><body><h1>Error while resolving the generated version of @path</h1><pre>@hyde_errors</pre></body></html>\"\"\"\n        x -> x\n    x -> x\n\n---------------------------------\n-- Hyde file support ends here --\n---------------------------------\n\nsourcecontentAny = Maybe.withDefaultReplace (\n    serverOwned \"404 page\" (if isTextFile path then\n           if permissionToCreate then freeze \"\"\"@path does not exist yet. Modify this page to create it!\"\"\" else \"\"\"Error 404, @path does not exist or you don't have admin rights to modify it (?admin=true)\"\"\"\n        else \"\"\"<html><head></head><body>@(\n          if permissionToCreate then freeze \"\"\"<span>@path does not exist yet. Modify this page to create it!</span>\"\"\" else \"\"\"<span>Error 404, @path does not exist or you don't have admin rights to modify it (?admin=true)</span>\"\"\"\n            )</body></html>\"\"\")\n  ) mbSourcecontentAny\n\nsourcecontent = String.newlines.toUnix sourcecontentAny\n\n{---------------------------------------------------------------------------\nUtility functions to be inherited by the main body of any\nview of editor (edit / file listing / word processor / etc)\nLUCA stands for \"Last Universal Common Ancestor\"\n----------------------------------------------------------------------------}\n\nluca = \n  [<script id=\"thaditor-vars\" class=\"editor-interface\">\n     var EDITOR_VERSION = typeof EDITOR_VERSION === \"number\" ? EDITOR_VERSION : 0;\n     var path = @(jsCode.stringOf path);\n     var varedit = @(if varedit then \"true\" else \"false\");\n     var askQuestions = @(case listDict.get \"question\" vars of\n                       Just questionattr -> \"true\"\n                       _ -> if boolVar \"question\" True then \"true\" else 'false');\n     var autosave = @(case listDict.get \"autosave\" vars of\n                      Just autosaveattr -> \"true\"\n                      _ -> if boolVar \"autosave\" True then \"true\" else \"false\");\n     var editIsFalseButDefaultIsTrue = @(if varedit == False && (listDict.get \"edit\" defaultOptions |> Maybe.withDefault False) == True then \"true\" else \"false\");\n   </script>,\n   <script id=\"thaditor-luca\" class=\"editor-interface\">\n    function writeDocument(NC) {\n      document.open();\n      document.write(NC);\n      document.close();\n    }\n    var XHRequest = typeof ProxiedServerRequest != \"undefined\" ? ProxiedServerRequest : XMLHttpRequest;\n    var apache_server = typeof thaditor_worker !== \"undefined\";\n    userName = typeof userName === \"string\" ? userName : \"anonymous\";\n    function doReadServer(action, name, onOk, onErr) {\n      if (typeof readServer != \"undefined\") {\n        return readServer(action, name, onOk, onErr);\n      } else {\n        var request = new XMLHttpRequest();\n        var url = \"/\";\n        request.open('GET', url, false);  // `false` makes the request synchronous\n        request.setRequestHeader(\"action\", action);\n        request.setRequestHeader(\"name\", name);\n        request.send(null);\n        if(request.status == 200) {\n          return request.responseText || \"\";\n        } else {\n          console.log(\"error while reading \" + url, request);\n          return \"\";\n        }\n      }\n    }\n    // Use in async setting\n    function getServer(action, name) {\n      return new Promise(function(resolve, reject) {\n        doReadServer(action, name, resolve, reject);\n      });\n    }\n    function doWriteServer(action, name, content, onOk, onErr) {\n      if (typeof writeServer != \"undefined\") {\n        return writeServer(action, name, content, onOk, onErr);\n      } else {\n        var request = new XMLHttpRequest();\n        request.open('POST', url, false);  // `false` makes the request synchronous\n        request.setRequestHeader(\"action\", action);\n        request.setRequestHeader(\"name\", name);\n        request.send(content);\n        if(request.status == 200) {\n          return request.responseText;\n        } else if(request.status == 500) {\n          return request.responseText;\n        } else {\n          console.log(\"error while writing \" + url, request);\n          return \"\";\n        }\n      }\n    }\n    function postServer(action, name, content) {\n      return new Promise(function(resolve, reject) {\n        doWriteServer(action, name, content, resolve, reject);\n      });\n    }\n    // Page reloading without trying to recover the editor's state.\n    function doReloadPage(url, replaceState) {\n      var xmlhttp = new XHRequest();\n      xmlhttp.onreadystatechange = ((xmlhttp, replaceState) => () => {\n        if (xmlhttp.readyState == XMLHttpRequest.DONE) {\n          //source of the editing menu disappearing after reloading\n          writeDocument(xmlhttp.responseText);\n          var newLocalURL = xmlhttp.getResponseHeader(\"New-Local-URL\");\n          if(newLocalURL) {\n            window.history[xmlhttp.replaceState ? \"replaceState\" : \"pushState\"]({localURL: newLocalURL}, \"Nav. to \" + newLocalURL, newLocalURL);\n          }\n        }\n      })(xmlhttp, replaceState);\n      xmlhttp.open(\"POST\", location.pathname + location.search);\n      xmlhttp.setRequestHeader(\"reload\", \"true\");\n      xmlhttp.setRequestHeader(\"url\", url);\n      if(googleAuthIdToken) {\n        xmlhttp.setRequestHeader(\"id-token\", googleAuthIdToken)\n      }\n      console.log(\"setting url to \", url);\n      xmlhttp.send(\"{\\\"a\\\":1}\");\n    }\n    window.onpopstate = function(e){\n        console.log(\"onpopstate\", e);\n        if(e.state && e.state.localURL) {\n          doReloadPage(location, true);\n        } else {\n          doReloadPage(location.pathname + location.search, true);\n        }\n    };\n    //document.body.appendChild(el(\"progress\", {id:\"progress-bar\", max:100, value:0, visible:false}, [], {}));\n\n    function sendNotification(msg, timeout) {\n      /*\n        Pushes the notification msg to the log & displays it for 3 seconds directly left of the moidfymenu.\n        css for notification box is textarea .notif\n      */\n\n      let modifyMenuDiv = document.querySelector(\"#modify-menu\");\n      if (!modifyMenuDiv) {\n        console.log(\"Notifications havent been set up for use outside of editor, like in the filesystem\");\n        console.log (msg);\n        return;\n      }\n      let notifBox = document.getElementById(\"notif-box\");\n      if (!notifBox) { //function el(tag, attributes, children, properties) \n        notifBox = el(\"textarea\", {id:\"notif-box\", class:\"textarea notifs\", visibility:true, readonly:true, isghost:true}, [], {value:msg});\n        modifyMenuDiv.append(notifBox);\n      }\n      notifBox.value = msg;\n      notifBox.style.display = \"block\";\n      notifBox.classList.toggle(\"visible\", true);\n      notifBox.style.zIndex = 100;\n      notifBox.style.visibility = true;\n      editor_model.editor_log.push(msg);\n      var logWindow = getEditorInterfaceByTitle(\"Log\");\n      if(logWindow) logWindow.refresh();\n      setTimeout(hideNotification, timeout ? timeout : 3000);\n    }\n\n    function hideNotification() {\n      let notifBox = document.getElementById(\"notif-box\");\n      if (notifBox) {\n        notifBox.classList.toggle(\"visible\", false);\n      }\n    }\n\n    var uploadProgress = [];\n\n    function initializeProgress(numFiles) {\n      var progressBar = document.getElementById(\"progress-bar\");\n      if (!progressBar) {\n        console.err (\"Warning! Add the progress bar yourself before calling this. We'll add it for you this time.\");\n        document.body.appendChild(el(\"progress\", {id:\"progress-bar\", max:100, value:0, visible:false}, [], {}));\n      }\n      progressBar.value = 0;\n      progressBar.visible = true;\n      uploadProgress = [];\n\n      for(let i = numFiles; i > 0; i--) {\n        uploadProgress.push(0);\n      }\n    }\n\n    function updateProgress(fileNumber, percent) {\n      uploadProgress[fileNumber] = percent;\n      let total = uploadProgress.reduce((tot, curr) => tot + curr, 0) / uploadProgress.length;\n      console.log (\"prog updated\");\n      documentgetElementById(\"progress-bar\").value = total;\n    }\n\n    // Editor's API should be stored in the variable editor.\n\n    editor = typeof editor === \"object\" ? editor : {};\n    editor.uploadFile = function(targetPathName, file, onOk, onError, updateProgFunction) {\n      var xhr = new XMLHttpRequest();\n      xhr.onprogress = (e) => {\n        updateProgFunction(i, (e.loaded * 100.0 / e.total) || 100)\n      }\n      xhr.onreadystatechange = ((xhr, file) => () => {\n        if (xhr.readyState == XMLHttpRequest.DONE) {\n          if (xhr.status == 200 || xhr.status == 201) {\n            onOk ? onOk(targetPathName, file) : 0;\n          } else {\n            console.log(\"Error while uploading picture or file\", xhr);\n            onError ? onError(targetPathName, file) : 0;\n          }\n        }\n        var progbar = document.getElementById(\"progress-bar\");\n      })(xhr, file);\n      if(apache_server) {\n        xhr.open(\"POST\", \"/Thaditor/editor.php?action=write&\" + \"name=\" + encodeURIComponent(targetPathName), false);\n      } else {\n        xhr.open(\"POST\", targetPathName, false);\n        xhr.setRequestHeader(\"write-file\", file.type);\n      }\n      xhr.send(file);\n    }\n    // Returns the storage folder that will prefix a file name on upload (final and initial slash excluded)\n    editor.getStorageFolder = function(file) {\n      var storageOptions = document.querySelectorAll(\"meta[editor-storagefolder]\");\n      for(let s of storageOptions) {\n        if(file.type.startsWith(s.getAttribute(\"file-type\") || \"\")) {\n          let sf = storageOptions.getAttribute(\"editor-storagefolder\") || \"\";\n          if(!sf.endsWith(\"/\")) sf = sf + \"/\";\n          return sf;\n        }\n      }\n      let extension = \"\";\n      if(file && file.type.startsWith(\"image\")) {\n        var otherImages = document.querySelectorAll(\"img[src]\");\n        for(let i of otherImages) {\n           extension = (i.getAttribute(\"src\") || \"\").replace(/[^\\/]*$/, \"\");\n           break;\n        }\n        if(extension[0] == \"/\") { // Absolute URL\n          return extension;\n        }\n      }\n      if(extension != \"\" && extension[extension.length-1] != \"/\") {\n        extension = extension + \"/\";\n      }\n      // extension ends with a / or is empty\n      var tmp = location.pathname.split(\"/\");\n      tmp = tmp.slice(0, tmp.length - 1);\n      storageFolder = tmp.join(\"/\") + (extension != \"\" ?  \"/\" + extension : \"/\");\n      return storageFolder;\n    }\n\t  editor.fs = { \n      listdir: \n\t\t    async function(dirname) {\n          return JSON.parse(await getServer(\"listdir\", dirname) || \"[]\");\n\t\t    }\n\t  };\n    editor.toTreasureMap = function(oldNode) {\n      if(!oldNode) return undefined;\n      if(oldNode.nodeType == 1 && oldNode.getAttribute(\"id\") && document.getElementById(oldNode.getAttribute(\"id\"))) {\n        return {id: oldNode.getAttribute(\"id\")};\n      }\n      let tentativeSelector = [];\n      let t = oldNode;\n      let isText = false, textIndex = 0;\n      while(t && t.parentNode) {\n        let index = Array.prototype.slice.call( t.parentNode.children ).indexOf(t);\n        if(t.nodeType === 1) {\n          tentativeSelector.unshift(t.tagName + \":nth-child(\" + (index + 1) + \")\" );\n        } else {\n          isText = true;\n          textIndex = Array.prototype.slice.call( t.parentNode.childNodes ).indexOf(t);\n        }\n        t = t.parentNode;\n      }\n      return {tentativeSelector: tentativeSelector, isText: isText, textIndex: textIndex};\n    }\n    // Returns the new node that matches the old node the closest.\n    // For text nodes, try to recover the text node, if not, returns the parent node;\n    editor.fromTreasureMap = function(data) {\n      if(!data) return undefined;\n      if(typeof data === \"object\" && data.id) {\n        return document.getElementById(data.id);\n      }\n      if(typeof data == \"object\" && Array.isArray(data.tentativeSelector)) {\n        let tentativeSelector = data.tentativeSelector;\n        while(tentativeSelector.length >= 1) {\n          let newNode = document.querySelector(tentativeSelector.join(\" \"));\n          if(newNode) {\n            return data.isText && newNode.childNodes && newNode.childNodes[data.textIndex] || newNode;\n          }\n          tentativeSelector.shift();\n        }\n        return undefined;\n      }\n    }\n        \n    // Helper to create an element with attributes, children and properties\n    function el(tag, attributes, children, properties) {\n      let tagClassIds = tag.split(/(?=#|\\.)/g);\n      let x;\n      for(let attr of tagClassIds) {\n        if(x && attr.startsWith(\".\")) {\n          x.classList.toggle(attr.substring(1), true);\n        } else if(x && attr.startsWith(\"#\")) {\n          x.setAttribute(\"id\", attr.substring(1));\n        } else if(!x) {\n          x = document.createElement(attr);\n        }\n      }\n      if(typeof attributes == \"object\") {\n        for(let k in attributes) {\n          let v = attributes[k];\n          if(typeof v != \"undefined\") {\n            x.setAttribute(k, v);\n          }\n        }\n      }\n      if(Array.isArray(children)) {\n        for(let child of children) {\n          if(typeof child === \"string\") {\n            x.append(child)\n          } else if(typeof child !== \"undefined\")\n            x.appendChild(child);\n        }\n      } else if(typeof children !== \"undefined\") {\n        x.append(children);\n      }\n      if(typeof properties == \"object\") {\n        for(let k in properties) {\n          x[k] = properties[k];\n        }\n      }\n      return x;\n    }    \n   </script>]\n\n\n-- Conversion of php script to elm script\nphpToElmFinal path string =\n  let includingFolder = Regex.replace \"\"\"(/)[^/]*$\"\"\" (\\{submatches=[slash]} -> slash) path in\n  let phpToElm string =\n        let echoRaw content = \"\\nob = ob + \" + content in\n        let wrapStr content = freeze String.q3 + Regex.replace \"@\" (\\{match=m} -> m + m) content + freeze String.q3 in\n        let echo content = echoRaw (wrapStr content) in\n        let phpStringToElmString =\n                (Regex.replace \"\"\"(\\\")([^\\\"]*)(\\\")\"\"\" <| \\m ->\n                  nth m.group 1 +\n                  (nth m.group 2\n                  |> Regex.replace \"\"\"\\$[0-9a-zA-Z_]*\"\"\" (\\n ->\n                     freeze \"\\\" + \" + nth n.group 0 + freeze \" + \\\"\")) +\n                  nth m.group 3) >>\n                (Regex.replace \"\"\"\\$_GET\\[([^\\]]*)\\]\"\"\" <| \\m ->\n                  freeze \"listDict.get \"+ nth m.group 1 + freeze \" $_GET |> Maybe.withDefaultReplace ''\"\n                ) >>\n                (Regex.replace \"\"\"\\$_SERVER\\[([^\\]]*)\\]\"\"\" <| \\m ->\n                  freeze \"listDict.get \"+ nth m.group 1 + freeze \" $_SERVER |> Maybe.withDefaultReplace ''\"\n                )\n        in\n        if not (Regex.matchIn \"<?php\" string) then\n          echo string\n        else\n        Regex.replace \"\"\"^((?:(?!<\\?php)[\\s\\S])+?)(?=(<\\?php))|(\\?>)([\\s\\S]*?)(?=<\\?php)|(\\?>)([\\s\\S]*?)$|(^)(<\\?php)([\\s\\S]*?)(?=\\?>)|(<\\?php)\\s*if\\s*\\(([\\s\\S]*?)\\s*\\)\\s*\\{\\s*\\?>((?:(?!<\\?php)[\\s\\S])+?)<\\?php\\s*\\}\\s*(?=\\?>)|(<\\?php)([\\s\\S]*?)(?=\\?>)\"\"\" (\n             \\{submatches=[content1, isRaw1, isRaw2, content2, isRaw3, content3, beginning1, isPhp1, code1, isPhpIf, condIf, codeIf, isPhp2, code2]} ->\n          if isPhp1 /= \"\" || isPhp2 /= \"\" || isPhpIf /= \"\" then\n            let prefix = if isPhp1 /= \"\" then echo beginning1 else freeze \"\" in\n            prefix +\n            if isPhpIf /= \"\" then\n              echoRaw <| \"(if \"+condIf+\" then \" + wrapStr codeIf + \" else \\\"\\\")\"\n            else\n            let code = if isPhp1 /= \"\" then code1 else code2 in\n            case Regex.extract \"\"\"^\\s*include\\(\"([^\"]*)\"\\)\"\"\" code of\n              Just [included] ->\n                phpToElm (fs.read (includingFolder + included) |> Maybe.withDefaultReplace (\"\\n[code to read \" + included + \" in \" + includingFolder +\"]\"))\n              _ ->\n            case Regex.extract \"\"\"^\\s*switch\\s*\\(([^\\)]*)\\)\\s*\\{((?:\\s*(?:case\\s*[^:]*?\\s*|default):((?:\\s*\\$[\\w_]+\\s*=\\s*(?:(?!;\\r?\\n)[\\s\\S])*;)*)(?:\\s*break\\s*;)?)*)\\s*\\}\\s*\"\"\" code of\n              Just [input, assignments, lastAssignment] ->\n                let vars = \"(\" + (Regex.find \"\"\"(\\$[\\w_]+)\\s*=\"\"\" lastAssignment |> List.map (\\[_, name] -> name) |> String.join \", \") + \")\" in\n                let results = assignments |> Regex.find \"\"\"\\s*(case\\s*([^:]*?)\\s*|default):((?:\\s*\\$[\\w_]+\\s*=\\s*(?:(?!;\\r?\\n)[\\s\\S])*;)*)(?:\\s*break\\s*;)?\"\"\" |>\n                      List.map (\\[whole, caseOrDefault, pattern, values] ->\n                        let tuple =\n                              Regex.find \"\"\"\\s*\\$[\\w_]+\\s*=\\s*((?:(?!;\\r?\\n)[\\s\\S])*?)\\s*;\"\"\" values |>\n                              List.map (\\[whole2, value2] -> phpStringToElmString value2) |> String.join \", \"\n                        in\n                        let finalPattern = if caseOrDefault == \"default\" then \"_\" else pattern in\n                        \"\\n  \" + finalPattern + \" -> (\" + tuple + \")\"\n                      ) |> String.join \"\"\n                in\n                \"\\n\" + vars + \" = case \" + phpStringToElmString input + \" of\"  + results\n              _ ->\n            case Regex.extract \"\"\"\\s*(?:echo|print)\\s+([^;]+?);\\s*\"\"\" code of\n              Just [content] -> echoRaw content\n              res ->\n                \"\\n[convert\" + code + \"]\\n\" + toString res\n          else\n          let content = if isRaw1 /= \"\" then\n                content1\n              else if isRaw2 /= \"\" then\n                content2\n              else -- if isRaw3 /= \"\" then\n                content3\n          in\n          echo content\n        ) string\n  in\n  flip (+) \"\\nob\" <|\n  (+) \"date _ = '2019'\\nob = freeze ''\" <| phpToElm string\n\n{---------------------------------------------------------------------------\n Evaluates the page according to the path extension.\n - Wraps html pages to parse them as raw html\n - Interprets markdown pages and evaluate them as raw html with CSS\n - Directly evaluate sources from elm/leo pages or folders\n----------------------------------------------------------------------------}\nevaluatedPage: Result String Html\nevaluatedPage = \n  if canEvaluate /= \"true\" then\n    Ok <html><head></head><body>URL parameter evaluate=@(canEvaluate) requested the page not to be evaluated</body></html>\n  else if isTextFile path || varraw then\n    Ok <html>\n        <head>\n        <title>@path</title>\n        <style type=\"text/css\" media=\"screen\">\n            #aceeditor { \n                  height: 100%;\n                  width: 100%;\n                  border: 1px solid #DDD;\n                  border-radius: 4px;\n                  border-bottom-right-radius: 0px;\n                  margin-top: 5px;\n            }\n        </style>\n        <script>\n          function loadAceEditor() {\n            console.log(\"executing script\");\n            var aceeditor = ace.edit(\"aceeditor\");\n            var mode = path.match(/\\.js$/) ? \"ace/mode/javascript\" :\n                       path.match(/\\.html?$/) ? \"ace/mode/html\" :\n                       path.match(/\\.css$/) ? \"ace/mode/css\" :\n                       path.match(/\\.json$/) ? \"ace/mode/json\" :\n                       path.match(/\\.leo$/) ? \"ace/mode/elm\" :\n                       path.match(/\\.elm$/) ? \"ace/mode/elm\" :\n                       path.match(/\\.php$/) ? \"ace/mode/php\" :\n                       \"ace/mode/plain_text\";\n            aceeditor.session.setMode({path: mode, v: Date.now()});\n            aceeditor.setOptions({\n              fontSize: \"20pt\"\n            });\n            aceeditor.setValue(document.getElementById(\"aceeditor\").getAttribute(\"initdata\"));\n            aceeditor.session.on('change', function(e) {\n              document.getElementById(\"aceeditor\").setAttribute(\"initdata\", aceeditor.getValue());\n            });\n            var callbackSelection = function() {\n              var anchor = aceeditor.selection.getSelectionAnchor();\n              var lead = aceeditor.selection.getSelectionLead();\n              var div = document.querySelector(\"#aceeditor\");\n              div.setAttribute(\"ghost-anchor-row\", anchor.row)\n              div.setAttribute(\"ghost-anchor-column\", anchor.column)\n              div.setAttribute(\"ghost-lead-row\", lead.row)\n              div.setAttribute(\"ghost-lead-column\", lead.column)\n            }\n            aceeditor.selection.on(\"changeSelection\", callbackSelection);\n            aceeditor.selection.on(\"changeCursor\", callbackSelection);\n            var div = document.querySelector(\"#aceeditor\");\n            aceeditor.selection.moveTo(div.getAttribute(\"ghost-anchor-row\") || 0, div.getAttribute(\"ghost-anchor-column\") || 0)\n            aceeditor.focus();\n          }\n        </script>\n        </head>\n        <body>\n        <div id=\"aceeditor\" list-ghost-attributes=\"class draggable style\" children-are-ghosts=\"true\"\n          save-ghost-attributes=\"style ghost-anchor-column ghost-anchor-row ghost-lead-column ghost-lead-row\" initdata=@sourcecontent></div>\n        <script>\n        editor.ghostNodes.push(node =>\n          node.tagName === \"SCRIPT\" && node.getAttribute(\"src\") && node.getAttribute(\"src\").match(/mode-(.*)\\.js|libs\\/ace\\/.*\\/ext-searchbox.js/)\n        );\n        \n        var script = document.createElement('script');\n        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.2/ace.js';\n        script.async = false;\n        script.setAttribute(\"isghost\", \"true\");\n        ace = undefined;\n        document.head.appendChild(script);\n        onAceLoaded = (delay) => () => {\n          if(typeof ace != \"undefined\") {\n            console.log(\"ace loaded.\")\n            loadAceEditor();\n          } else {\n            console.log(\"ace not loaded. Retrying in \" + (delay * 2) + \"ms\");\n            setTimeout(onAceLoaded(delay * 2), 100);\n          }\n        }\n        onAceLoaded(1)();\n        </script>\n        </body>\n        </html>\n  else \n  let isPhp = Regex.matchIn \"\"\"\\.php$\"\"\" path in\n  let isHtml = Regex.matchIn \"\"\"\\.html?$\"\"\" path in\n  if isHtml || isPhp then\n    let sourcecontent = if isHtml then applyDotEditor sourcecontent else\n      let elmSourceContent = phpToElmFinal path sourcecontent in\n      __evaluate__ ((\"$_GET\", vars)::(\"$_SERVER\", [(\"SCRIPT_NAME\", \"/\" + path)])::(\"path\", path)::(\"fs\", fs)::preludeEnv) elmSourceContent |>\n      case of\n        Err msg -> serverOwned \"error message\" \"<html><head></head><body><pre>Error elm-reinterpreted php: \" + Regex.replace \"<\" \"&lt;\" msg + \"</pre>Original computed source <pre>\" +\n          Regex.replace \"<\" \"&lt;\" elmSourceContent +\n          \"</pre></body></html>\"\n        Ok sourcecontent -> applyDotEditor sourcecontent\n    in\n    let interpretableData =\n          case Regex.extract \"\"\"^\\s*<!DOCTYPE(?:(?!>)[\\s\\S])*>([\\s\\S]*)$\"\"\" sourcecontent of\n            Just [interpretableHtml] -> serverOwned \"begin raw tag\" \"<raw>\" + interpretableHtml + serverOwned \"end raw tag\" \"</raw>\"\n            _ ->\n          case Regex.extract \"\"\"^[\\s\\S]*?(<html\\b[\\s\\S]*)$\"\"\" sourcecontent of\n            Just [interpretableHtml] -> serverOwned \"begin raw tag\" \"<raw>\" + interpretableHtml + serverOwned \"end raw tag\" \"</raw>\"\n            _ -> serverOwned \"raw display of html - beginning\" \"\"\"<raw><html><head></head><body>\"\"\" + sourcecontent + serverOwned \"raw display of html - end\" \"\"\"</body></html></raw>\"\"\"\n    in\n    __evaluate__ preludeEnv interpretableData\n    |> Result.andThen (case of\n      [\"raw\", _, nodes] ->\n        case List.find (case of [\"html\", _, _] as n -> True; _ -> False) nodes of\n          Just n -> Ok n\n          Nothing -> Err \"\"\"No top-level HTML node found\"\"\" \n      result -> Err \"\"\"Html interpretation error: The interpretation of raw html did not work but produced @result\"\"\"\n    )\n  else if Regex.matchIn \"\"\"\\.md$\"\"\" path then\n    let markdownized = String.markdown sourcecontent in\n      case Html.parseViaEval markdownized of\n        x -> \n          let markdownstyle = fs.read \"markdown.css\" |> Maybe.withDefaultReplace defaultMarkdowncss in\n          Ok <html><head></head><body><style title=\"If you modify me, I'll create a custom markdwon.css that will override the default CSS for markdown rendering\">@markdownstyle</style><div class=\"wrapper\">@x</div></body></html>\n  else if Regex.matchIn \"\"\"\\.(elm|leo)$\"\"\" path then\n    __evaluate__ ((\"vars\", vars)::(\"path\", path)::(\"fs\", fs)::preludeEnv) sourcecontent\n  else if fs.isdir path then\n    let\n      pathprefix = if path == \"\" then path else path + \"/\"\n    in\n    Ok <html><head>\n      \n      <script>\n        var ispressed = false;\n        var whichOne = \"\";\n        //declare bool variable to be false\n        document.onkeydown = function(e) {\n          if (e.ctrlKey){\n              ispressed = true;\n          }\n        };\n        document.onkeyup = function(e) {\n          if (e.keyCode == 17){ //releasing ctrl key. doesn't set e.ctrlKey properly or would use that.\n            ispressed = false;\n          }\n        }\n        var handleFileSelect = e => {\n          e.preventDefault();\n        }\n        document.addEventListener('drop', handleFileSelect, false);\n      </script>\n      <style>\n        #menu_bar {\n          overflow: hidden;\n          background-color: #ffffff;\n          opacity:1;\n        }\n\n        #menu_bar a {\n          float: left;\n          display: block;\n          color: #f2f2f2;\n          text-align: center;\n          padding: 14px 16px;\n          text-decoration: none;\n          font-size: 17px;\n        }\n\n        #menu_bar a:hover {\n          background-color: #ddd;\n          color: black;\n        }\n\n        #menu_bar a.active {\n          background-color: #4CAF50;\n          color: white;\n        }\n        .dropdown {\n          float: left;\n          overflow: hidden;\n        }\n\n        .dropdown .dropbtn {\n          font-size: 16px;  \n          border: none;\n          outline: none;\n          color: white;\n          padding: 14px 16px;\n          background-color: inherit;\n          font-family: inherit;\n          margin: 0;\n        }\n        .dropdown .dropbtn {\n          font-size: 16px;  \n          border: none;\n          outline: none;\n          color: white;\n          padding: 14px 16px;\n          background-color: inherit;\n          font-family: inherit;\n          margin: 0;\n        }\n\n        .menu_bar a:hover, .dropdown:hover .dropbtn {\n          background-color: red;\n        }\n\n        .dropdown-content {\n          display: none;\n          position: absolute;\n          background-color: #f9f9f9;\n          min-width: 160px;\n          box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);\n          z-index: 1;\n        }\n\n        .dropdown-content a {\n          float: none;\n          color: black;\n          padding: 12px 16px;\n          text-decoration: none;\n          display: block;\n          text-align: left;\n        }\n\n        .dropdown-content a:hover {\n          background-color: #ddd;\n        }\n\n        .dropdown:hover .dropdown-content {\n          display: block;\n        }\n        .content {\n          padding: 16px;\n        }\n\n        .sticky {\n          position: fixed;\n          top: 0;\n          width: 100%;\n        }\n\n        .sticky + .content {\n          padding-top: 60px;\n        }\n        #fileListing div.file-item {\n          display: block;\n        }\n        #fileListing div.file-item input {\n          display: none;\n        }\n        #fileListing div.file-item {\n          display: table-row;\n        }\n        #fileListing div.file-item label {\n          display: table-cell;\n          vertical-align: middle;\n          padding: 0.3em;\n        }\n        #fileListing div.file-item label:hover {\n          background: rgb(229,243,255);\n        }\n        #fileListing div.file-item input:checked + label {\n          color: white;\n          outline: 1px solid rgb(153,209,255);\n          background: rgb(204,232,255);\n        }\n        #fileListing div.file-item label a {\n          text-decoration: none;\n          color: black;\n          padding: 2px;\n        }\n        #fileListing div.file-item label a:hover {\n          text-decoration: underline;\n          color: blue;\n        }\n        #fileListing div.file-item label svg {\n          vertical-align: middle;\n          transform: scale(0.5);\n        }\n        #fileListing div.file-item label svg.file-extension-icon {\n          opacity: 0.5;\n        }\n        #fileListing div.file-item label svg.file-extension-icon > path {\n          stroke:black;\n          stroke-width:2px;\n          stroke-linecap:butt;\n          fill:none;\n          -linejoin:miter;\n          stroke-opacity:1;\n        }\n        #fileListing div.file-item label svg.file-extension-icon > text {\n          font-size: 2em;\n        }\n\n      </style>\n      <div id=\"menu_bar\">\n        <button id=\"renamefs\" onClick=\"renameFs()\">Rename File(s)</button>\n        <button id=\"duplicatefs\" onClick=\"duplicateFs()\">Make a Copy</button>\n        <button id=\"movefs\" onClick=\"moveFs()\">Move File(s)</button>\n        <button id=\"createFolder\" onClick=\"createFolder()\">Create a Folder</button>\n        <button id=\"deletefs\" onClick=\"deleteFs()\">Delete File(s)</button>\n        <div id=\"forprog\"></div>\n      </div>\n      </head><body><h1><label value=path>@path</label></h1>\n      <form id=\"fileListing\"></form>\n      <script>\n      var fullListDir = (path) => JSON.parse(doReadServer(\"fullListDir\", path));\n      var thisListDir = fullListDir(path);\n      var folders = thisListDir.filter((i) => i[1] == true);\n      var getSelectedFiles = () => Array.from(document.querySelectorAll(\"input.filesBtn\")).filter((btn) => btn.checked);\n      var warnSelectFile = reason => window.alert (reason + \", please select some and click this button again\");\n      var warnDeselectFiles = reason => window.alert (reason + \", please deselect all files and folders and click this button again\");\n      var isDupInFolder = (folder, name) => folder.filter((i) => i[0] == name).length != 0;\n      var isDuplicateHere = (name) => isDupInFolder(thisListDir, name);\n      var isFolder = (name) => folders.filter((i) => i[0] == name).length != 0;\n\n      window.onscroll = function() {stickyFun()};\n      var menu_bar = document.getElementById(\"menu_bar\");\n      var sticky = menu_bar.offsetTop;\n\n      function stickyFun() {\n        if (window.pageYOffset >= sticky) {\n          menu_bar.classList.add(\"sticky\")\n        } else {\n          menu_bar.classList.remove(\"sticky\");\n        }\n      }\n      function getOneFile(reason) {\n        var selected = getSelectedFiles();\n        if (selected.length == 0) {\n          warnSelectFile(reason);\n          return 0;\n        } else if (selected.length != 1) {\n          window.alert (\"Please select only one file to rename\");\n          return 0;\n        }\n        return selected[0];\n      }\n      function renameFs() {\n        console.log (\"in rename fs\");\n        var sel = getOneFile(\"To rename files or folders\");\n        if (! sel) return;\n        if (sel.id == \"..\") {\n          window.alert(\"Can't change the up dir\");\n          return;\n        }\n        var newname = window.prompt(\"Set new name for file: \", sel.id);\n        if (newname == null) return;\n        if (newname == \"\") {\n          window.alert(\"Please specify a new name for the file.\");\n          return;\n        }\n        if (isDuplicateHere(newname)) {\n          const doit = window.confirm(\"Are you sure you want to overwrite an existing file with the name \" + newname + \"?\");\n          if (!doit) return;\n        }\n        var x = doWriteServer(\"rename\", path + sel.id, path + newname);\n        console.log (\"renamed\", sel.id, newname);\n        goodReload();\n      }\n      function deleteFs() {\n        var selected = getSelectedFiles();\n        if (selected.length == 0) {\n          warnSelectFile(\"To delete a file or a folder\"); \n          return;\n        }\n        if (selected.filter((i) => i.id == \"..\").length != 0) {\n          window.alert(\"Can't delete the parent dir\");\n          return;\n        }\n        var warningMsg = \"Are you sure you want to delete the following file(s)?\"\n        for (i = 0; i < selected.length; i++) {\n          warningMsg = warningMsg + \"\\n\" + selected[i].id;\n        }\n        var conf = window.confirm(warningMsg);\n        if (conf) {\n          for (i = 0; i < selected.length; i++) {\n            var isfolder = folders.filter((j) => j[0] == selected[i].id); //optomizable\n            console.log (isfolder);\n            if (isfolder.length != 0) {\n              doWriteServer(\"rmdir\", path + selected[i].id); //does this work on non-empty stuff? idts....\n              continue;\n            }\n            doWriteServer(\"unlink\", path + selected[i].id);\n          }\n          goodReload();\n          return;\n        }\n      }\n      function duplicateFs() {\n        var sel = getOneFile(\"To duplicate files or folders\");\n        if (! sel) return;\n        if (sel.id == \"..\") {\n          window.alert(\"Can't change the up dir\");\n          return;\n        }\n        var lastdot = sel.id.lastIndexOf(\".\");\n        var nn;\n        if (isFolder(sel.id)) {\n          nn = sel.id + \"_(Copy)\";\n        } else {\n          nn = sel.id.substring(0, lastdot) + \"_(Copy)\" + sel.id.substring(lastdot);\n        }\n        var newname = window.prompt(\"Name for duplicate: \", nn);\n        var contents = doReadServer(\"read\", path + sel.id);\n        if (contents[0] != \"1\") {\n          window.alert (\"Couldn't read the file for some reason. aborting.\");\n          console.error (\"couldn't read the file for some reason. aborting.\");\n          return;\n        }\n        contents = contents.substring(1, contents.length);\n        var resp = doWriteServer(\"create\", path + newname, contents);\n        goodReload();\n      }\n      function createFolder() {\n        var btns = getSelectedFiles();\n        if (btns.length != 0) {\n          warnDeselectFiles(\"To create a folder\");\n          return;\n        }\n        var newname = window.prompt(\"Name for new folder: \", \"\");\n        console.log (newname);\n        if (newname == null) return;\n        if (newname == \"\") {\n          window.alert(\"Please set a name for the new folder!\");\n          return;\n        }\n        var dups = isDuplicateHere(newname);\n        if (dups) {\n          const conf = window.confirm (\"Are you sure you want to overwrite a folder with the name \" + newname + \" with an empty file? This would delete the folder.\");\n          if (!conf) return;\n        }\n        doWriteServer(\"mkdir\", newname, \"\");\n        goodReload();\n      }\n      function moveFs() {\n        var btn = getOneFile(\"To move files or folders\");\n        if (!btn) return;\n        if (btn.id == \"..\") {\n          window.alert(\"Can't change the up dir\");\n          return;\n        }\n        var newpath = window.prompt(\"New path to file (relative to root of server):\", \"\");\n        if (newpath == null) return;\n        if (newpath[newpath.length -1] != \"/\") {\n          newpath = newpath + \"/\";\n        }\n        try {\n          var nldir = fullListDir(newpath);\n          if (isDupInFolder(nldir, btn.id)) {\n            const conf = window.confirm(\"Are you sure you want to overwrite an existing file?\");\n            if (!conf) return;\n          }\n        } catch (e) {\n          window.alert (\"The path specified does not exist. Move cancelled.\");\n          return;\n        }\n        console.log (\"move approved\");\n        var oldloc = (path + btn.id);\n        var newloc = newpath == \"/\" ? btn.id : (newpath + btn.id);\n        console.log (\"renamimg\\n%s\\n%s\", (path + btn.id), (newpath + btn.id));\n        doWriteServer(\"rename\", oldloc, newloc); \n        console.log (\"rename successful\");\n        goodReload();\n      }\n\n      function radPressed(){\n        var btns = document.querySelectorAll(\"input.filesBtn\");\n        if (!ispressed){\n          for(var i = 0; i < btns.length; i++){\n            if (btns[i].value == whichOne) continue;\n            btns[i].checked = false;\n          }\n        }\n      }\n      var handleFiles = (files) => {\n        var pgbr = document.getElementById(\"forprog\");\n        var progbar = document.getElementById(\"progress-bar\");\n        if (!progbar) {\n          pgbr.append(el(\"progress\", {id:\"progress-bar\", max:100, value:0, visible:true}, [], {}));\n          progbar = document.getElementById(\"progress-bar\");\n        } else {\n          progbar.visible = true;\n        }\n        initializeProgress(files.length);\n        var didUp = false;\n        ([...files]).forEach((fl) => {\n          editor.uploadFile(path + fl.name, fl, (ok) => console.log (\"was ok\\n\" + ok), (err) => console.err (err), updateProgress);\n          didUp = true;\n          \n        });\n        progbar.value = 100;\n        progbar.visible = false;\n        if (didUp) {\n          goodReload();\n          pgbr.innerHTML = \"\";\n        }\n      }\n      function preventDefaults (e) {\n        e.preventDefault()\n        e.stopPropagation()\n      }\n      function handleDrop(e) {\n        preventDefaults(e);\n        let dt = e.dataTransfer;\n        let files = dt.files;\n        handleFiles(files);\n      }\n      function loadFileList() {\n        let form = document.getElementById(\"fileListing\");\n        let files = thisListDir;\n        function getRecordForCheckbox(file) {\n          var rec = {type:\"checkbox\",\n                      id:file,\n                      class:\"filesBtn\",\n                      name:\"filesBtn\",\n                      value:file,\n                      onClick:\"whichOne=value\",\n                      onChange:\"radPressed()\"};\n          return rec;\n        }\n        var dirIcon = () => {\n          var d = el(\"div\", {}, [], {innerHTML: \n          `<svg class=\"file-extension-icon\" width=\"60\" height=\"30\">\n            <path d=\"M 8,3 5,6 5,26 10,10 32,10 32,6 18,6 15,3 8,3 Z M 5,26 10,10 37,10 32,26 Z\" />`});\n          return d.childNodes[0];\n        }\n        var extensionIcon = name => {\n          let extension = name.replace(/^(?:(?!\\.(?=[^\\.]*$)).)*\\.?/, \"\");\n          if(\".\" + extension == name || extension === \"\") extension = \"-\";\n          console.log ({extension});\n          var d = el(\"div\", {}, [], {innerHTML: \n          `<svg class=\"file-extension-icon\" width=\"60\" height=\"30\">\n            <text x=\"0\" y=\"25\">${extension}\n           `});\n          return d.childNodes[0];\n        }\n\n        var fileItemDisplay = function(link, name, isDir) {\n           return el(\"div\", {class:\"file-item\"}, [\n              el(\"input\", getRecordForCheckbox(name), \"\"),\n              el(\"label\", {for:name, value:name}, [ \n                isDir ? dirIcon() : extensionIcon(name),\n                el(\"a\", {href:link}, name, {onclick: function(event) {\n                  event.preventDefault();\n                  let link = this.getAttribute(\"href\");\n                  doReloadPage(link);\n                }})])]);\n        }\n        var otherItemDisplay = function(link, name) {\n           return el(\"div\", {class:\"file-item\"}, [\n              el(\"input\", getRecordForCheckbox(name), \"\"),\n              el(\"label\", {for:name, value:name}, [ \n                extensionIcon(name),\n                el(\"a\", {href:link}, name)\n                ])\n              ]);\n        }\n        //el(tag, attributes, children, properties)\n        if (path != \"\") {\n          var link = \"../\" + \"?ls\";\n          form.append(otherItemDisplay(link, \"..\"));\n        }\n        // directories before files, sorted case-insensitive\n        files.sort(([name1, isDir1], [name2, isDir2]) =>\n          isDir1 && !isDir2 ? -1 : isDir2 && !isDir1 ? 1 :\n          name1.toLowerCase() < name2.toLowerCase() ? -1 : 0);\n        for (i = 0; i < files.length; i++) {\n          var [name, isDir] = files[i];\n          let extension = name.replace(/^(?:(?!\\.(?=[^\\.]*$)).)*\\.?/, \"\");\n          if(\".\" + extension == name || extension === \"\") extension = \"-\";\n          const img_exts = [\"jpeg\", \"jpg\", \"png\", \"svg\", \"tiff\", \"tif\", \"gif\", \"pdf\"]\n          const is_img = img_exts.includes(extension.toLowerCase());\n          if (!is_img) {\n            if (isDir) {\n              form.append(otherItemDisplay((name + \"/?ls\"), name))\n            } else {\n              form.append(fileItemDisplay((name + \"/?edit\"), name, isDir));\n            }\n          } else {\n            form.append(otherItemDisplay(name, name));\n          }\n        }\n\n        form.append(el(\"input\", {type:\"file\", id:\"fileElem\", onchange:\"handleFiles(this.files)\"}, [], {}));\n      }\n      loadFileList();\n      var goodReload = () => {\n        document.getElementById(\"fileListing\").innerHTML = \"\";\n        thisListDir = fullListDir (path);\n        loadFileList();\n      }\n    window.addEventListener('drop', handleDrop, false);\n    window.addEventListener('dragover', (e) => e.preventDefault(), false);\n    </script></body></html>\n  else \n    Ok <html><head></head><body>\n      <p>Editor cannot open file because it does not recognize the extension.</p>\n      <p>As an alternative, you can open the file in raw mode by appending <code>?raw</code> to it.</p>\n      <button onclick=\"\"\"\n        location.search = location.search + (location.search == \"\" ? \"?raw\" : \"&raw\");\n      \"\"\">Open @path in raw mode</button>\n    </body></html>  \n\n{---------------------------------------------------------------------------\n Recovers from evaluation errors\n----------------------------------------------------------------------------}\nrecoveredEvaluatedPage: Html\nrecoveredEvaluatedPage = --updatecheckpoint \"recoveredEvaluatedPage\" <|\n  case evaluatedPage of\n  Err msg -> serverOwned \"Error Report\" <|\n    <html><head></head><body style=\"color:#cc0000\"><div style=\"max-width:600px;margin-left:auto;margin-right:auto\"><h1>Error report</h1><button onclick=\"reloadPage();\" title=\"Reload the current page\">Reload</button><pre style=\"white-space:pre-wrap\">@msg</pre></div></body></html>\n  Ok page -> page\n\njsEnabled = boolVar \"js\" True\n\nremoveJS node = case node of\n  [text, content] -> node\n  [tag, attrs, children] ->\n    if tag == \"script\" then [tag, [], [[\"TEXT\", \"/*Script disabled by Thaditor*/\"]]] else\n    [tag, attrs, List.map removeJS children]\n  _ -> []\n\n{---------------------------------------------------------------------------\n Instruments the resulting HTML page\n - Removes whitespace that are siblings of <head> and <body>\n - !f the page is editable:\n   * Adds the contenteditable attribute to body\n   * Adds the edition menu and the source preview area\n - Else: Adds the \"edit\" box to switch to edit mode\n - Adds the initial scripts\n - Append the edition scripts so that we can modify the page even without edit mode (that's dangerous, should we avoid this?)\n----------------------------------------------------------------------------}\nmain: Html\nmain = \n  --updatecheckpoint \"main\" <|\n  case recoveredEvaluatedPage of\n  [\"html\", htmlattrs, htmlchildren] -> [\"html\", htmlattrs, htmlchildren |>\n    List.filter (case of [_, _] -> False; _ -> True) |>\n    List.mapWithReverse identity (case of\n      [\"head\", headattrs, headChildren] ->\n        let headChildren = if jsEnabled then headChildren else List.map removeJS headChildren in\n        [\"head\", headattrs,\n           insertThereInstead identity True headChildren ++  -- All new nodes added to the beginning of the head are added back to headChildren.\n           serverOwned \"initial script\" initialScript ++\n           (serverOwned \"stylesheet-of-server\" <style>/* The switch - the box around the slider */\n\n.switch {\n    position: relative;\n    display: inline-block;\n    width: 30px;\n    height: 17px;\n    vertical-align: middle;\n    margin-left: 0.6rem;\n}\n\n/* Hide default HTML checkbox */\n\n.switch input {\n    display: none;\n}\n\n/* The slider */\n\n.slider {\n    position: absolute;\n    cursor: pointer;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background-color: #ccc;\n    -webkit-transition: .4s;\n    transition: .4s;\n}\n\n.slider:before {\n    position: absolute;\n    content: \"\";\n    height: 13px;\n    width: 13px;\n    left: 2px;\n    bottom: 2px;\n    background-color: white;\n    -webkit-transition: .4s;\n    transition: .4s;\n}\n\n/* Remove all input default border and shadow in modify-menu*/\n\n#modify-menu input[type=text] {\n    outline-color: invert;\n    outline-style: none;\n    outline-width: 0px;\n    border: none;\n    border-style: none;\n    text-shadow: none;\n    -webkit-appearance: none;\n    -webkit-user-select: text;\n    outline-color: transparent;\n    box-shadow: none;\n    color: var(--context-button-color-inert);\n}\n\ninput:checked+.slider {\n    background-color: #2196F3;\n}\n\ninput:focus+.slider {\n    box-shadow: 0 0 1px #2196F3;\n}\n\ninput:checked+.slider:before {\n    -webkit-transform: translateX(13px);\n    -ms-transform: translateX(13px);\n    transform: translateX(13px);\n}\n\n.textarea {\n    color: white;\n    font-family: Arial;\n}\n.notifs {\n    background-color: var(--context-color);\n    /* transform: translateX(44px); */\n    position: absolute;\n    top: 0px;\n    width:256px;\n    height:128px;\n    font-size: 1.4rem;\n    resize: none;\n    text-align: center;\n    border: none;\n    border-radius: 0.4rem;\n    font-weight: bold;\n    padding-top: 1em;\n    animation: notifs-invisible 0.5s forwards, fadeOut 0.5s forwards;\n}\n.notifs.visible {\n  animation: notifs-visible 0.5s forwards, fadeIn 0.5s forwards;\n}\n@keyframes notifs-visible {\n  0% {transform:translateX(-128px);}\n  100% {transform: translateX(calc(-256px - 48px));}\n}\n@keyframes notifs-invisible {\n  0% {transform:translateX(calc(-256px - 48px));}\n  100% {transform: translateX(-128px);}\n}\n@keyframes fadeIn {\n  0% {opacity:0;}\n  100% {opacity: 1;}\n}\n@keyframes fadeOut {\n  0% {opacity:1;}\n  100% {opacity: 0;}\n}\n\n.logger {\n    background-color: transparent;\n    width: 100%;\n    height: 50px;\n    border: none;\n}\n\n/* Rounded sliders */\n\n.slider.round {\n    border-radius: 17px;\n}\n\n.slider.round:before {\n    border-radius: 50%;\n}\n\n.switch+label {\n    cursor: pointer;\n    padding-top: 5px;\n    padding-bottom: 5px;\n}\n\n.filename {\n    color: #FFF;\n    padding-left: 3px;\n    vertical-align: top;\n    display: block;\n    font-weight: bold;\n    font-size: 1.2rem;\n}\n\ndiv.imgFolder {\n    text-align: center;\n    padding: 0.6em;\n}\n\ndiv.imgFolder > img {\n    max-width: 100%;\n    min-width: 2em;\n}\n\na.troubleshooter {\n    position: absolute;\n    top: 1rem;\n    /* top: calc(100% - 3em); */\n    display: inline-block;\n    right: 2em;\n    text-decoration: none;\n    color: white;\n    font-weight: bold;\n}\n\n.editor-menu {\n    display: initial !important;\n}\n\n.disabled {\n    color: #BBB;\n}\n\ninput.global-setting[type=checkbox] {\n    display: none;\n}\n\ninput.global-setting[type=checkbox]:checked+span.label-checkbox {\n    background: #bcbbff;\n}\n\nspan.label-checkbox {\n    padding: 2px;\n    border-radius: 10px;\n}\n\nspan.label-checkbox:hover {\n    background-color: rgba(0, 0, 0, 0.06);\n    cursor: pointer;\n}\n\nspan#ambiguity-id {\n    color: #9dff00;\n    display: block;\n}\n\n.solution {\n    display: block;\n    padding: 3px;\n}\n\n.solution.selected {\n    background: rgba(255, 255, 255, 0.2);\n}\n\n.solution:not(.selected):hover {\n    background: rgba(255, 255, 255, 0.1);\n    cursor: pointer;\n}\n\n.solution.notfinal {\n    color: #f6f6aa;\n}\n\n.add {\n    background: lightgreen\n}\n\n.remove {\n    background: #f8a7a7;\n    text-decoration: line-through\n}\n\ndiv.disambiguationMenu {\n    height: 40%;\n    overflow-y: auto;\n    padding-left: 0.3em;\n    padding-top: 0.3em;\n    padding-bottom: 0.3em;\n    border: 2px solid #f6f6aa;\n}\n\n.codepreview {\n    font-family: monospace;\n    padding: 3px;\n    background: white;\n    color: black;\n    margin-left: 0.1em;\n}\n\n.solution:not(.selected) .codepreview {\n    background: rgba(255, 255, 255, 0.8);\n}\n\n#modify-menu button.modifyMenuButton {\n    background-color: var(--context-button-color);\n    min-height: var(--context-button-width);\n    color: var(--context-dom-text-color);\n    border-style: none;\n    margin-top: 5px;\n    padding: 0.4em;\n    font-weight: bold;\n    cursor: pointer;\n}\n\n#modify-menu button.modifyMenuButton:hover {\n    background-color: var(--context-button-color-hover);\n}\n\n#editor_codepreview, #manualsync-menuitem {\n    display: none;\n    z-index: 999;\n}\n\n[ghost-visible=true] {\n    display: initial !important;\n}\n\n[ghost-disabled=true] {\n    opacity: 0.5 !important;\n    cursor: initial;\n    pointer-events: none !important;\n}\n\n[ghost-disabled=false] {\n    opacity: 1 !important;\n    pointer-events: auto !important;\n}\n\n#manualsync-menuitem[ghost-disabled=false]>button {\n    cursor: pointer !important;\n    opacity: 1 !important;\n    pointer-events: auto !important;\n}\n\n#manualsync-menuitem[force-visible=true] {\n    display: initial;\n}\n\n[ghost-visible=false] {\n    display: none !important;\n}\n\n#manualsync-menuitem>button {\n    vertical-align: top;\n    opacity: 0.5;\n    cursor: initial;\n    pointer-events: none;\n}\n\n#editor_codepreview {\n    width: 100%;\n    height: 600px;\n}\n\n@media screen and (max-width: 800px) {\n    body {\n        font-size: 48px;\n    }\n    menu.edittoolbar {\n        right: 10px;\n    }\n    menuitem.filename {\n        display: none;\n    }\n    /*menuitem {\n      font-size: 2.5em;\n    }*/\n    button {\n        font-size: 1em;\n    }\n    menuitem#question-menuitem {\n        display: none;\n    }\n    menuitem#autosave-menuitem {\n        display: none;\n    }\n    #editor_codepreview {\n        width: 100%;\n        height: 600px;\n    }\n    @keyframes notifs-visible {\n      0% {transform:translateY(-64px);}\n      100% {transform: translateY(calc(-128px - 48px));}\n    }\n    @keyframes notifs-invisible {\n      0% {transform:translateY(calc(-128px - 48px));}\n      100% {transform: translateY(-64px);}\n    }\n\n}\n\ndiv#modify-menu textarea.inline-CSS {\n    width: 100%;\n    height: 100px;\n    margin-bottom: 6px;\n    overflow-y: auto;\n    color: black;\n}\n\ndiv#modify-menu #CSS-modification {\n    width: 100%;\n    overflow-y: auto;\n    display: flex;\n    flex-direction: column;\n    flex: 1;\n}\n\ndiv#modify-menu button.action-button {\n    color: white;\n    background: var(--context-dom-children-selector-color);\n    font-size: 1em;\n    margin-top: 6px;\n    margin-bottom: 6px;\n    display: block;\n    border-radius: 0.4em;\n    height: 2em;\n    font-weight: normal;\n    padding: 6px;\n    border: none;\n}\n\n\ndiv#modify-menu button.action-button:hover {\n    -webkit-filter: contrast(125%);\n    /* Chrome, Opera */\n    -moz-filter: blur(125%);\n    -ms-filter: blur(125%);\n    filter: blur(125%);\n    border: none;\n}\n\n\ndiv#modify-menu #CSS-modification > button#add-inline-style:hover {\n    -webkit-filter: contrast(125%);\n    /* Chrome, Opera */\n    -moz-filter: blur(125%);\n    -ms-filter: blur(125%);\n    filter: blur(125%);\n}\n\ndiv#modify-menu #CSS-modification .linked-CSS {\n    width: 100%;\n    height: 250px;\n}\n\ndiv#modify-menu #CSS-modification>.CSS-modify-unit {\n    display: flex;\n    align-items: center;\n    margin-bottom: 5px;\n}\n\ndiv#modify-menu #CSS-modification>.CSS-modify-unit>.CSS-buttons{\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n}\n\ndiv#modify-menu #CSS-modification>.CSS-modify-unit > textarea {\n    width: 100%;\n    height: 100px;\n    overflow-y: auto;\n    font-family: monospace;\n    color: black;\n    border-radius: 0.2em;\n    border: none;\n    font-size: 16px;\n    padding: 6px;\n}\n\ndiv#modify-menu #CSS-modification>div.CSS-chain {\n    margin-bottom: 6px;\n}\n\ndiv#modify-menu #CSS-modification>.CSS-modify-unit .CSS-action-button:hover {\n    background-color: var(--context-button-color-hover);\n}\n\ndiv#modify-menu #CSS-modification>.CSS-modify-unit .CSS-selectors {\n    width: 100%;\n    height: 100px;\n    overflow-y: auto;\n    font-family: monospace;\n    color: black;\n    border-radius: 0.2em;\n    border: none;\n    font-size: 0.8em;\n    padding: 6px;\n}\n\ndiv#modify-menu div#fullLog {\n  max-height: 50%;\n}\n\n.summary {\n    color: green;\n}\n\ndiv#modify-menu {\n    -webkit-box-shadow: 0px 0px 34px 0px rgba(0, 0, 0, 0.75);\n    -moz-box-shadow: 0px 0px 34px 0px rgba(0, 0, 0, 0.75);\n    box-shadow: 0px 0px 34px 0px rgba(0, 0, 0, 0.75);\n    position: fixed;\n    top: 0px;\n    right: 0px;\n    width: 400px;\n    height: 100%;\n    background-color: var(--context-color);\n    color: var(--context-dom-text-color);\n    padding: 5px;\n    font-size: 16px;\n    transform: translate(100%, 0px);\n    transition-property: transform;\n    transition-duration: 0.5s;\n    z-index: 100001;\n}\n\n.modify-menu-holder {\n    width: 100%;\n    height: calc(100% - 10px);\n    overflow-y: auto;\n    font-family: Arial, Helvetica, sans-serif;\n}\ndiv.modify-menu-icons:not(.pinned) ~ div.modify-menu-holder {\n  height: calc(100% - 50px);\n}\n\n.modify-menu-icon {\n    vertical-align: middle;\n    cursor: pointer;\n    width: var(--context-menu-button-width);\n}\n\n.modify-menu-icon:hover {\n    background-color: var(--context-button-color-hover);\n}\n\ndiv#modify-menu>div.modify-menu-icons:not(.pinned) {\n    width: 100%;\n    height: 30px;\n    overflow-x: auto;\n    margin: 5px;\n}\n\ndiv#modify-menu>div.modify-menu-icons.pinned {\n    width: var(--context-menu-button-width);\n    position: absolute;\n    left: calc(0px - var(--context-menu-button-width));\n}\n\ndiv#modify-menu>div.information {\n    overflow-y: auto;\n    max-height: calc(100% - var(--context-menu-height) - 15%);\n    margin: 2%;\n    margin-top: 0;\n    border-radius: 0.3em;\n}\n\ndiv#modify-menu>div.information-style {\n    padding: 0.4rem;\n}\n\n/* information part scroll bar */\n.information.information-style::-webkit-scrollbar {\n    background: transparent;\n    width: 8px;\n}\n\n.information.information-style::-webkit-scrollbar-thumb {\n    background: rgba(255, 255, 255, 0.5);\n    border-radius: 10px;\n}\n\ndiv.information>textarea {\n    font-size: 1em;\n}\n\ndiv#modify-menu.visible {\n    transform: translate(0%, 0%);\n}\n\ndiv#modify-menu h3 {\n    margin-top: 2px;\n    margin-bottom: 2px;\n}\n\ndiv#modify-menu button.CSSbutton {\n    width: 98%; \n    height: 7%;\n    padding: 4px;\n    margin-left: 4px;\n}\n\ndiv#modify-menu div.keyvalues {\n    margin-top: 6px;\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue {\n    font-size: 16px;\n    padding: 2px;\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-items: center;\n    padding-left: 8px;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue .attribute-key-value {\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    width: 60%;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue .attribute-key {\n    width: 39%;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalueadder {\n    opacity: 0.5;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalueadder:hover {\n    opacity: 1;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalueadder .attribute-key-value{\n    display: flex;\n    flex-direction: row;\n}\n\ndiv#modify-menu div.keyvalue input {\n    padding: 4px;\n    width: 98%;\n    color: black;\n    font-size: 16px;\n}\n\ndiv#modify-menu .codefont {\n    font-size: 1.4em;\n    font-family: monospace;\n}\n\ndiv#modify-menu .tagname-input {\n    padding: 4px;\n    flex: 1;\n}\n\ndiv#modify-menu .tagname-input input {\n    display: inline-block;\n}\n\ndiv#modify-menu .tagname-info {\n    display: inline-block;\n    border-radius: 4px;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    background: transparent;\n    color: var(--context-dom-text-color);\n    flex: 2;\n    line-height: 3.5em;\n}\n\ndiv#modify-menu input[type=radio] {\n    width: initial;\n    font-size: 1em;\n}\n\ndiv#modify-menu span.insertOption {\n    display: block;\n}\n\ndiv.keyvalue span>input {\n    border-radius: 4px;\n    margin: 2px;\n}\n\ndiv.tagname-summary {\n    display: flex;\n    background-color: var(--context-dom-selector-color);\n    border-radius: 0.4em;\n    padding: 4px;\n    margin: 2%;\n}\n\n.inline-input {\n    background: transparent;\n    color: var(--context-dom-text-color);\n    border: none;\n}\n\n/* dom selector css */\n\ndiv.dom-selector-style {\n    margin: 2%;\n    margin-top: 0;\n    margin-bottom: 0;\n    border-radius: 0.4em;\n    padding: 0.4rem;\n}\n\ndiv.childrenElem {\n    display: flex;\n    height: 30px;\n    margin-top: 4px;\n}\n\ndiv.mainElemName {\n    color: var(--context-dom-text-color);\n    font-family: monospace;\n}\n\ndiv.childrenSelectorName {\n    font-family: monospace;\n}\n\ndiv.childrenSelector {\n    min-width: 50px;\n    position: relative;\n    flex: 1;\n    text-align: center;\n    overflow: hidden;\n    padding: 2px;\n    margin: 2px;\n    border-radius: 0.3rem;\n    background-color: var(--context-dom-children-selector-color);\n    transition: all 0.5s;\n    text-decoration: none;\n    cursor: pointer;\n}\n\ndiv.childrenSelector:hover {\n    -webkit-filter: contrast(125%);\n    /* Chrome, Opera */\n    -moz-filter: blur(125%);\n    -ms-filter: blur(125%);\n    filter: blur(125%);\n}\n\ndiv.editor-interface-dom-selector {\n  opacity: 0.5;\n  color: #ffe5b5;\n}\ndiv.editor-recorded-ghost-node {\n  opacity: 0.5;\n}\ndiv.editor-recorded-ghost-attribute {\n  opacity: 0.5;\n}\ndiv.editor-ignored-attribute {\n  background: #a2a2a2;\n}\n\n\ndiv.mainElem {\n    height: 62px;\n    position: relative;\n    text-align: center;\n    overflow: hidden;\n    font-size: 1.3em;\n    text-overflow: ellipsis;\n}\n\ndiv.mainElemInfo {\n    font-size: 0.6em;\n    color: var(--context-dom-text-color);\n    height: 20px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\ndiv.childrenSelectorInfo {\n    text-overflow: ellipsis;\n    overflow: hidden;\n    color: var(--context-dom-text-color);\n    height: 38px;\n    font-size: 0.8em;\n}\n\ndiv.elementAttr {\n    margin-left: 6px;\n    display: inline-block;\n    font-size: 0.6em;\n    line-height: 1.02em;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    color: var(--context-dom-text-color);\n}\n\ndiv.no-children, div.no-parent {\n    background-color: transparent;\n    text-align: center;\n    text-transform: uppercase;\n    color: black;\n    border-radius: 0.3rem;\n    font-weight: bold;\n    line-height: 36px;\n    font-size: 0.8rem;\n    pointer-events: none;\n}\n\ndiv.no-children {\n    width: 100%;\n}\n\ndiv.no-sibling {\n    background-color: transparent;\n    color: black;\n    width: 20%;\n    text-transform: uppercase;\n    font-size: 0.8em;\n    line-height: 20px;\n    font-weight: bold;\n    min-width: 50px;\n    pointer-events: none;\n}\n\n/* make button's text unselectable for better user experience */\n\n.noselect {\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -khtml-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n\n.selectedDom {\n    background-color: var(--context-dom-selector-color) !important;\n    border: none;\n}\n\n#upload-image-btn-a {\n    margin-left: 0;\n    margin-top: 10px;\n    margin-bottom: 10px;\n    height: 20px;\n    position: relative;\n    color: black;\n    background: transparent;\n    border-radius: 4px;\n    display: inline-block;\n    height: 20px;\n    width: 280px;\n}\n\n#upload-image-btn-input {\n    position: absolute;\n    top: -7px; /* alignment */\n    left: 0;\n    width: 100%;\n}\n\n/* highlight selected image */\n\ndiv.highlight-select-image {\n    border: 1px solid white;\n    border-radius: 0.76em;\n}\n\n:root {\n    --context-color: rgba(0, 128, 128, 0.8);\n    --context-color-next: rgba(0, 158, 158, 0.8);\n    --context-button-color: rgba(0, 192, 192, 0.8);\n    --context-button-color-hover: rgba(0, 232, 232, 0.8);\n    --context-button-color-inert: rgba(128, 128, 128, 0.8);\n    --context-button-color-inert-hover: rgba(150, 150, 150, 0.8);\n    --context-button-color-inert-active: rgba(182, 182, 182, 0.8);\n    --context-dom-selector-color: rgba(0, 212, 159, 0.8);\n    --context-dom-children-selector-color: rgba(0, 178, 179, 0.8);\n    --context-dom-text-color: whitesmoke;\n    --context-menu-height: 30px;\n    --context-menu-button-width: 40px;\n    --context-menu-padding-top: 0px;\n    --context-menu-padding-left: 0px;\n    --context-button-selected: rgba(0, 212, 212, 0.8);\n    --context-editor-container-title: rgba(0, 178, 179, 0.6);\n}\n\ndiv.tagName {\n    margin-top: 0.24rem;\n    /* padding: 4px; */\n    cursor: pointer;\n    /* background: var(--context-button-color); */\n    vertical-align: text-bottom;\n}\n\ndiv.tagName:not(.nohover):hover {\n    background: var(--context-button-color-hover);\n}\n\n\n#customHTML {\n    height: 6%;\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n}\n\n[ghost-hovered=true] {\n    outline: 2px dashed var(--context-color-next);\n}\n\n[ghost-clicked=true] {\n    outline: 2px solid var(--context-color);\n}\n\n[wrong-selector=true]{\n    background-color: #fbcaca;\n}\n\ndiv#context-menu {\n    position: absolute;\n    display: none;\n    background-color: var(--context-color);\n    color: white;\n    font-weight: bold;\n    z-index: 1000000;\n}\n\ndiv#context-menu.visible {\n    display: block;\n    height: var(--context-menu-height);\n    width: 200px;\n}\n\ndiv#context-menu .context-menu-button, div#modify-menu .modify-menu-button, div#modify-menu .modify-menu-icons .context-menu-button {\n    background: var(--context-button-color);\n    display: inline-block;\n    width: var(--context-menu-button-width);\n    cursor: pointer;\n}\n\ndiv.modify-menu-icons:not(.pinned) > div.modify-menu-button {\n    background-color: transparent !important;\n    border-radius: 0.4rem;\n    margin-right: 0.2rem;\n}\n\ndiv.modify-menu-icons:not(.pinned) > div.modify-menu-button:hover {\n    background-color: var(--context-button-color) !important;\n}\n\ndiv#context-menu .context-menu-button, div#modify-menu .modify-menu-icons:not(.pinned) .modify-menu-button {\n    height: var(--context-menu-height);\n}\n\ndiv#modify-menu .modify-menu-icons.pinned .modify-menu-button {\n    border-bottom: 1px solid black;\n}\n\ndiv#modify-menu .modify-menu-icons.pinned .modify-menu-button:last-child {\n    border-bottom: none;\n}\n\ndiv#context-menu .context-menu-button.selected, div#modify-menu .modify-menu-button.selected {\n    background: var(--context-button-selected);\n}\n\ndiv#modify-menu .modify-menu-button.inert.active {\n    background: var(--context-button-color-inert-active)\n}\n\ndiv#modify-menu .modify-menu-button.disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\ndiv#modify-menu .modify-menu-icon-label {\n    display: block;\n    color: white;\n    font-size: calc(var(--context-menu-button-width) / 3);\n    text-align: center;\n}\n\ndiv#modify-menu .modify-menu-icon-label-link {\n    display: block;\n    color: white;\n    font-size: calc(var(--context-menu-button-width) / 4);\n    text-align: center;\n}\n\n/* div#context-menu .context-menu-button>svg, div#modify-menu .modify-menu-button>svg {\n    padding: 5px;\n    padding-bottom: 2px;\n    padding-top: 2px;\n} */\n\ndiv#context-menu .context-menu-button.inert, div#modify-menu .modify-menu-icons.modify-menu-icons .modify-menu-button.inert {\n    background: var(--context-button-color-inert)\n}\n\nsvg.context-menu-icon>path {\n    fill: none;\n    stroke: #FFFFFF;\n    stroke-width: 2px;\n    stroke-linecap: butt;\n    -linejoin: miter;\n    stroke-opacity: 1;\n}\n\nsvg.context-menu-icon.fill>path {\n    fill: #FFFFFF;\n    fill-rule: evenodd;\n}\n\ndiv#context-menu .context-menu-button:hover, div#modify-menu .modify-menu-button:hover:not(.disabled) {\n    background: var(--context-button-color-hover);\n}\n\ndiv#context-menu .context-menu-button.inert:hover, div#modify-menu .modify-menu-button.inert:hover:not(.disabled) {\n    background: var(--context-button-color-inert-hover)\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue #applyNewTagName {\n    display: none;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue #applyNewTagName.visible {\n    display: flex;\n    width: var(--context-menu-button-width);\n    padding: 4px;\n}\ndiv#modify-menu div.keyvalues>div.keyvalue #newTagName {\n    background: none;\n    color: white;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue #newTagName:focus {\n    background: white;\n    color: initial;\n}\n\n\ndiv#modify-menu div.keyvalues>div.keyvalue #applyNewTagName + div#newtagname-align-placeholder {\n  display: flex;\n  width: calc(var(--context-menu-button-width) - 8px);\n  padding: 4px;\n  margin: 2px;\n  border-radius: 4px;\n  border-width: 2px;\n}\n\ndiv#modify-menu div.keyvalues>div.keyvalue #applyNewTagName.visible + div#newtagname-align-placeholder {\n  display: none;\n}\n\ntextarea.textChildNodeContent {\n  width: 100%;\n  height: 100px;\n  border-radius: 0.4em;\n  border: 0;\n  margin-top: 6px;\n  padding: 10px;\n  color: black;\n  resize: vertical;\n  min-height: 50px;\n  font-size: 0.8em;\n}\n\ntextarea.templateengine {\n    width: 100%;\n    height: 100%;\n    max-height: 50%;\n    color: black;\n    border-radius: 0.4rem;\n    border: 0;\n    padding: 0.4em;\n    font: normal 0.8em Consolas, Monaco, monospace;\n    resize: none;\n    opacity: 0.8;\n}\n\ntextarea.templateengine:focus {\n    outline: none;\n    opacity: 1;\n}\n\n#modify-menu span.insertOption label {\n  display: inline-block;\n}\n\n\n.to-be-selected {\n    animation: OrangeWait 3s linear infinite;\n    background: linear-gradient(90deg, orange 0%, gold 5%, gold 10%, orange 15%) !important;\n    background-size: 200% 100% !important;\n}\n\n@keyframes OrangeWait { \n    0% { \n      background-position: 30% 0%;\n    }\n    30%, 100% {\n      background-position: -100% 0%;\n    }\n}\n\ndiv.editor-container {\n  margin-top: 3px;\n}\n\ndiv.editor-container-title > div.expand-menu {\n  float: left;\n  line-height: 30px;\n  padding-left: 6px;\n}\ndiv.editor-container:first-of-type div.arrowup, div.editor-container:last-of-type div.arrowdown {\n  visibility: hidden;\n}\ndiv.editor-container.minimized div.editor-container-content {\n  display: none;\n}\ndiv.editor-container.disabled div.editor-container-title {\n  color: #BBB;\n}\ndiv.editor-container:not(.disabled) > div.editor-container-title:hover {\n  -webkit-filter: contrast(125%);\n    /* Chrome, Opera */\n    -moz-filter: blur(125%);\n    -ms-filter: blur(125%);\n    filter: blur(125%);\n}\n\ndiv.editor-container div.editor-container-title div.editor-container-icon svg.context-menu-icon.fill>path {\n  fill: #BBB;\n  stroke-width: 0px;\n}\ndiv.editor-container div.editor-container-title div.editor-container-icon:hover svg.context-menu-icon.fill>path {\n  fill: white;\n}\ndiv.editor-container-title {\n  border-radius: 0.2rem;\n  height: 30px;\n  background-color: var(--context-editor-container-title);\n  cursor: pointer;\n  font-family: Tahoma, sans-serif;\n  font-weight: bold;\n}\n\ndiv.editor-container-content {\n  padding: 6px;\n  padding: 6px;\n  max-height: 80%;\n  overflow-y: auto;\n}\n\ndiv.editor-container-content button {\n    outline: none;\n}\n\ndiv.editor-container div.editor-container-title div.editor-container-icon {\n  float: right;\n  margin-top: 5px;\n}\ndiv.editor-container.minimized div.editor-container-title div.editor-container-icon#displayArrow {\n  transform: rotate(180deg);\n  transform-origin: 50% 50%;\n}\n\ndiv.editor-container-content > div.draftList > div.draft-row {\n    display: flex;\n}\n\ndiv.editor-container-content > div.draftList > div.draft-row:not(#draft-title) > * {\n    flex-grow: 1;\n    flex-shrink: 1;\n}\n\n\ndiv.editor-container-content > div.draftList > div.draft-row > button {\n    margin: 4px;\n    border-radius: 0.2em;\n    color: var(--context-dom-children-selector-color);\n    background-color: rgba(255, 255, 255, 0.9);\n    font-size: 0.88em;\n    border: none;\n    height: 1.6em;\n    cursor: pointer;\n}\n\ndiv.editor-container-content > div.draftList > div.draft-row > button:hover {\n    -webkit-filter: contrast(125%);\n    /* Chrome, Opera */\n    -moz-filter: blur(125%);\n    -ms-filter: blur(125%);\n    filter: blur(125%);\n    background-color: var(--context-dom-children-selector-color);\n    border: none;\n    color: white;\n}\n\ndiv.editor-container-content > div.draftList > div.draft-row > button.draft-switch {\n    color: white;\n    background: linear-gradient(left, var(--context-dom-selector-color) , var(--context-dom-children-selector-color));\n    background: -webkit-linear-gradient(left, var(--context-dom-selector-color) , var(--context-dom-children-selector-color));\n    flex-basis: 10px;\n}\n\ndiv.draftList > div.draft-row > button.draft-publish,\ndiv.draftList > div.draft-row > button.draft-clone,\ndiv.draftList > div.draft-row > button.draft-delete {\n    flex-basis: 20px;\n}\n\ndiv.draftList > div.draft-row > button.draft-delete:hover {\n    color: rgb(204, 204, 0) !important;\n    font-weight: bold;\n}\n\ndiv.editor-container-content > div.draftList > div#draft-title {\n    padding-left: 4px;\n    padding-right: 4px;\n}\n\ndiv.editor-container-content > div.draftList > div#draft-title > label {\n    margin-top: 6px;\n}\n\ndiv.editor-container-content > div.draftList > div#draft-title > label:first-child {\n    font-weight: bold;\n    font-size: 1.2em;\n    margin-top: 2px;\n    padding-right: 10px;\n}\n\nlabel.switch {\n  position: relative;\n}\n\ndiv#modify-menu div.translation-title {\n  font-weight: bold;\n  margin-top: 5px;\n}\ndiv#modify-menu textarea.translation-content {\n  color: black;\n  width: 100%;\n  height: 120px;\n  max-height: 50%;\n}\n\n.translate-select {\n  color: black;\n}\n\n@media screen and (max-width: 800px) {\n    div#modify-menu {\n        -webkit-box-shadow: none;\n        -moz-box-shadow: none;\n        box-shadow: none;\n        /* font-size: 48px; */\n        bottom: 0px;\n        left: 0px;\n        top: initial;\n        right: initial;\n        height: 40%;\n        width: 100%;\n        min-height: 350px;\n        transform: translate(0px, 100%);\n        padding: 0;\n        padding-bottom: 8px;\n    }\n    div#modify-menu>div.modify-menu-icons.pinned {\n        width: auto;\n        height: var(--context-menu-height);\n        position: absolute;\n        top: calc(0px - var(--context-menu-height));\n        left: 0px;\n    }\n    div#modify-menu>div.modify-menu-icons.pinned span.modify-menu-icon-label {\n        display: none;\n    }\n    div#modify-menu>div.modify-menu-icons.pinned >div.modify-menu-button {\n        height: 50px;\n    }\n    div#modify-menu>div.modify-menu-icons.pinned svg {\n        height: 50px;\n    }\n    div.bottom-placeholder {\n        width: 100%;\n        height: 30%;\n    }\n    :root {\n        --context-menu-height: 48px;\n        --context-menu-button-width: 48px;\n        --context-menu-padding-top: 9px;\n        --context-menu-padding-left: 4px;\n    }\n    /* mobile dom selector */\n    div.dom-selector-style {\n        height: 30%;\n        margin: 0.15em;\n        border-radius: 0.4em;\n        margin: 2%;\n    }\n    div.elementAttr {\n        display: none;\n    }\n    div.mainElem {\n        margin-bottom: 0;\n        height: 56%;\n    }\n    div.childrenSelector {\n        font-size: 1.2em;\n    }\n    div.no-sibling {\n        font-size: 1em;\n    }\n    /* mobile modify menu */\n    div.tagname-summary {\n        padding-left: 10px;\n    }\n    div.information {\n        margin: 2%;\n        margin-top: 0;\n        height: 215px;\n        overflow-y: auto;\n    }\n    div.information>textarea {\n        font-size: 1.2em;\n        border-radius: 0.3em;\n        border: none;\n        padding: 1.5%;\n    }\n    textarea.templateengine {\n        width: 100%;\n        height: 100%;\n        color: black;\n        font-size: 1.4rem;\n        border-radius: 0.4rem;\n        border: 0;\n        padding: 0.4rem;\n    }\n    div.insert-information-style {\n        max-height: 400px;\n        height: 400px;\n    }\n    div.insert-information-style>h1 {\n        margin: 0;\n    }\n}</style> :: headChildren)]\n      [\"body\", bodyattrs, bodyChildren] ->\n        let bodyChildren = if jsEnabled then bodyChildren else List.map removeJS bodyChildren in\n        [\"body\",\n           (if canEditPage then\n             [[\"contenteditable\", \"true\"]] |> serverOwned \"contenteditable attribute of the body due to edit=true\" \n            else freeze []) ++\n           bodyattrs, insertThereInstead identity True bodyChildren ++ luca ++\n          if not varedit || varls then\n            bodyChildren\n          else \n             (if canEditPage then ((serverOwned \"edition menu\" editionmenu) sourcecontent) else\n              if not varedit && not iscloseable && not varproduction then serverOwned \"open edit box\" [openEditBox] else\n              serverOwned \"edit prelude when not in edit mode\" []) ++\n             bodyChildren ++\n             Update.sizeFreeze [[\"div\", [[\"id\", \"editor-files-to-overwrite\"], [\"class\", \"editor-interface\"]], insertThereInstead insertedElementsToWriteFile True fileOperations]] ++\n             (serverOwned \"synchronization script and placeholder\" [<div class=\"bottom-placeholder editor-interface\"> </div>, <script  id=\"thaditor-lastscript\" class=\"editor-interface\">@lastEditScript</script>] ++ insertThereInstead identity False bodyChildren -- All new nodes there are added back to bodyChildren.\n             )]\n      x -> x -- anything else?\n    )]\n  x-> <html><head></head><body>Not a valid html page: @(\"\"\"@x\"\"\")</body></html>\n  --|> Update.debug \"main\"\n\ninsertedElementsToWriteFile = List.map <| case of\n   [_, [[\"class\", \"file-overwrite\"], [\"name\", name], [\"oldcontent\", oldcontent], [\"newcontent\", newcontent]], _] ->\n     (name, Write oldcontent newcontent (Update.diffs oldcontent newcontent |> Maybe.withDefault (VStringDiffs [])))\n   thisInstead ->\n     error \"\"\"In #editor-files-to-overwrite, you should put attributes class=\"file-overwrite\" name=\"[full path name]\" oldcontent=\"[old file content]\" newcontent=\"[new file content]\"> in this order (even call the funciton addFileToSave(name, oldContent, newContent) fo simplicity. Got @thisInstead\"\"\"\n\n-- Returns an empty list. If elements are inserted, inserts them in the given list instead.\ninsertThereInstead onInsert atBeginning list =\n  Update.lens {apply _ = [],\n    update {outputNew, input=list} =\n      Ok (InputsWithDiffs [(if atBeginning then onInsert outputNew ++ list else list ++ onInsert outputNew, Just <|\n        VListDiffs [(if atBeginning then 0 else List.length list, ListElemInsert (List.length outputNew))]\n      )])\n  } list\n\n{---------------------------------------------------------------------------\n Definitions for the pipeline above\n----------------------------------------------------------------------------}\n  \n-- Box to switch to edit mode.\nswitchEditBox toEdit = \n  let prev = if toEdit then \"false\" else \"true\"\n      next = if toEdit then \"true\" else \"false\"\n      msg = if toEdit then \"edit\" else \"x\"\n      title = if toEdit then \"Reload the page in edit mode\" else \"Reload the page without edit mode\" in\n<div id=\"editbox\" title=@title onclick=\"\"\"\n if(location.search.indexOf(\"edit=@prev\") == -1) {\n   location.search = location.search.startsWith(\"?\") ? location.search + \"&edit=@next\" : \"?edit=@next\"\n } else {\n   location.search = location.search.replace(/edit=@prev/, \"edit=@next\");\n }\n\"\"\" class=\"editor-interface\">\n<style>#editbox {\n  @(if toEdit then \"\"\"position: fixed;\n  margin-top: 2px;\n  margin-left: 2px;\n  background: white;\n  padding: 2px;\n  border-radius: 10px;\n  transform: scale(0.6);\n  \"\"\" else \"\"\"position: absolute;\n  color: white;\n  background: black;\n  font-family: 'Helvetica', 'Arial', sans-serif;\n  font-size: 2em;\n  font-weight: bold;\n  text-align: center;\n  width: 40px;\n  height: 40px;\n  border-radius: 5px;\n  transform: translate(-0.7em, -0.7em) scale(0.3);\n  \"\"\"\n )z-index: 20000;\n  opacity: 0.5;\n  cursor: pointer;\n}\n#editbox:hover {\n  opacity: 1;\n}\n</style>@msg\n</div>\n\nopenEditBox = switchEditBox True\ncloseEditBox = switchEditBox False\n\nboolToCheck = Update.bijection (case of \"true\" -> [[\"checked\", \"\"]]; _ -> []) (case of [[\"checked\", \"\"]] -> \"true\"; _ -> \"false\")\n\n-- Everything inside the modify menu is generated and is not visible to Editor\neditionmenu thesource = [\n<div id=\"modify-menu\" list-ghost-attributes=\"style class\" sourcecontent=@thesource contenteditable=\"false\" children-are-ghosts=\"true\"></div>,\n<div id=\"context-menu\" children-are-ghosts=\"true\" list-ghost-attributes=\"style class\" contenteditable=\"false\"></div>,\nif iscloseable then <span class=\"editor-interface\" dummy=\"\"></span> else closeEditBox]\n\ninitialScript = serverOwned \"initial script\" [\n<script class=\"editor-interface\" type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/gh/MikaelMayer/lossless-css-parser@d4d64a4a87f64606794a47ab58428900556c56dc/losslesscss.js\" list-ghost-attributes=\"gapi_processed\"></script>,\n<script class=\"editor-interface\">\n\n// TODO: Find a way to store a cookie containing credentials, and have this server refresh tokens.\n// https://developers.google.com/identity/sign-in/web/server-side-flow\n// https://stackoverflow.com/questions/32902734/how-to-make-google-sign-in-token-valid-for-longer-than-1-hour\n// https://www.w3schools.com/js/js_cookies.asp\nif(typeof googleAuthIdToken == \"undefined\") {\n  var googleAuthIdToken = undefined;\n}\n\nfunction isGhostNode(elem) {\n  return elem && elem.isghost || (elem.nodeType == 1 &&\n    (elem.tagName == \"GHOST\" || elem.getAttribute(\"isghost\") == \"true\"));\n}\n\nfunction areChildrenGhosts(n) {\n  return n && n.getAttribute && (\n    n.getAttribute(\"children-are-ghosts\") == \"true\" ||\n    n.getAttribute(\"children-are-ghost\") == \"true\"\n  ) ||\n  editor.ghostChildNodes.find(f => f(n));\n}\nfunction hasGhostAncestor(htmlElem) {\n  if(htmlElem == null) return false;\n  if(isGhostNode(htmlElem)) return true;\n  return areChildrenGhosts(htmlElem.parentNode) || (htmlElem.parentNode == null && htmlElem.nodeType !== 9 /*document*/) || hasGhostAncestor(htmlElem.parentNode);\n}\n// Return true if this htmlElem is inside an element that ignores its children.\nfunction hasIgnoringAncestor(htmlElem) {\n  if(htmlElem == null) return false;\n  return isIgnoringChildNodes(htmlElem.parentNode) || hasIgnoringAncestor(htmlElem.parentNode);\n}\nfunction isGhostAttributeKey(name) {\n  return name.startsWith(\"ghost-\");\n}\n\n// Editor's API is stored in the variable editor.\n\neditor = typeof editor === \"object\" ? editor : {};\n\neditor.matches = function(elem, selector) {\n  if(typeof selector == \"undefined\") { // Then selector is in the elem variable\n    return (selector => function(elem) {\n      return editor.matches(elem, selector);\n    })(elem);\n  }\n  if(elem && elem.matches) {\n    try {\n      return elem.matches(selector);\n    } catch(e) {\n      console.log(\"error while matching selector \" + selector, e);\n      return false;\n    }\n  }\n  return false;\n}\n    \n// An array of (node => {innerHTML, attributes, properties}) that can be defined by plug-ins.\neditor.customContextMenuButtons = [];\n\n// Creates an SVG icon from the given path. If fill is true, will have the path filled.\nfunction svgFromPath(path, fill, width, height, viewBox) {\n  return `<svg class=\"context-menu-icon${fill ? \" fill\": \"\"}\" \n        width=\"${width ? width : 40}\" height=\"${height ? height : 30}\" \n        ${viewBox ? \"viewBox=\\\"\" + viewBox[0] + \" \"+ viewBox[1] + \" \"+ viewBox[2] + \" \"+ viewBox[3] +\"\\\"\" : \"viewBox=\\\"0 0 40 30\\\"\"}>\n        <path d=\"${path}\"></path></svg>`\n}\neditor.svgFromPath = svgFromPath;\n\n// Array of functions on nodes returning an array of attributes that should be ghosts (i.e. removed on back-propagation)\neditor.ghostAttrs = [];\neditor.ghostAttrs.push(n =>\n  ((n && n.getAttribute && n.getAttribute(\"list-ghost-attributes\")) || \"\").split(\" \").concat(\n    ((n && n.getAttribute && n.getAttribute(\"save-ghost-attributes\")) || \"\").split(\" \")).filter(a => a != \"\")\n);\neditor.ghostAttrs.push(n =>\n  n && n.tagName == \"HTML\" ? [\"class\"] : []\n);\neditor.ghostAttrs.push(n =>\n  n && n.tagName == \"BODY\" ? [\"data-gr-c-s-loaded\"] : []\n);\n// attribute of some chrome extensions\neditor.ghostAttrs.push(n => [\"bis_skin_checked\"]);\n\n// Array of functions on nodes returning an array of predicates such that if one is true, the children of this element will be ignored (i.e. their old value is always returned on back-propagation)\neditor.ignoredChildNodes = [];\n\nfunction isIgnoringChildNodes(n) {\n  return editor.ignoredChildNodes.find(f => f(n));\n}\nfunction cacheChildNodes(n) {\n  let res = [];\n  for(let k = 0; k < n.childNodes.length; k++) {\n    res.push(domNodeToNativeValue(n.childNodes[k]));\n  }\n  // Let's store the tree of this element.\n  n.__editor__ = n.__editor__ || {};\n  n.__editor__.ignoredChildNodes = res;\n}\n\n// Array of functions on nodes returning an array of attributes that should be ignored (i.e. old value returned on back-propagation)\neditor.ignoredAttrs = [];\neditor.ignoredAttrs.push(n =>\n  ((n && n.getAttribute && n.getAttribute(\"list-ignored-attributes\")) || \"\").split(\" \").concat(\n    ((n && n.getAttribute && n.getAttribute(\"save-ignored-attributes\")) || \"\").split(\" \")).filter(a => a != \"\")\n)\n\n// Returns a method that, for each key name, return true if it is a ghost attribute for the node\nfunction isSpecificGhostAttributeKeyFromNode(n) {\n  var additionalGhostAttributes = [];\n  for(var k in editor.ghostAttrs) {\n    additionalGhostAttributes = additionalGhostAttributes.concat(editor.ghostAttrs[k](n))\n  }\n  return (a => name => a.indexOf(name) != -1)(additionalGhostAttributes);\n}\n\n// Returns a method that, for each key name, return true if it is an ignored attribute for the node\nfunction isIgnoredAttributeKeyFromNode(n) {\n  var additionalIgnoredAttributes = [];\n  for(var k in editor.ignoredAttrs) {\n    additionalIgnoredAttributes = additionalIgnoredAttributes.concat(editor.ignoredAttrs[k](n))\n  }\n  return ((a, n) => (name, oldValue) => {\n    let result = a.indexOf(name) != -1;\n    if(result) { // let's store the previous attribute's value\n      n.__editor__ = n.__editor__ || {};\n      n.__editor__.ignoredAttrMap = n.__editor__.ignoredAttrMap || {};\n      if(!(name in n.__editor__.ignoredAttrMap) && typeof oldValue !== \"undefined\") {\n        n.__editor__.ignoredAttrMap[name] = oldValue;\n      }\n    }\n    return result;\n  })(additionalIgnoredAttributes, n);\n}\nfunction ignoredAttributeValue(n, name) {\n  let result = n.__editor__.ignoredAttrMap[name];\n  if(typeof result === \"undefined\") {\n    return n.getAttribute(name);\n  }\n  return result;\n}\n\n// Array of predicates that, if they return true on a node, Editor will mark this node as ghost.\neditor.ghostNodes = [];\n// Array of predicates that, if they return true on a node, Editor will mark all the children of this node as ghosts\neditor.ghostChildNodes = [];\n\n// Analytics scripts\neditor.ghostNodes.push(insertedNode =>\n  editor.matches(insertedNode, \"script[src]\") &&\n     (insertedNode.getAttribute(\"src\").indexOf(\"google-analytics.com/analytics.js\") != -1 ||\n      insertedNode.getAttribute(\"src\").indexOf(\"google-analytics.com/gtm/js\") != -1 ||\n      insertedNode.getAttribute(\"src\").indexOf(\"googletagmanager.com/gtm.js\") != -1)\n);\n\n// For for ace styles in header\neditor.ghostNodes.push(insertedNode => {\n    if(insertedNode.tagName == \"STYLE\" && typeof insertedNode.getAttribute(\"id\") == \"string\" &&\n     (insertedNode.getAttribute(\"id\").startsWith(\"ace-\") ||\n      insertedNode.getAttribute(\"id\").startsWith(\"ace_\"))) {\n      insertedNode.setAttribute(\"save-ghost\", \"true\"); \n      return true;\n    } else {\n      return false;\n    }\n  }\n);\n// For Google sign-in buttons and i-frames\neditor.ghostNodes.push(\n  editor.matches(\"div.abcRioButton, iframe#ssIFrame_google\")\n);\n// For anonymous styles inside HEAD (e.g. ace css themes and google sign-in)\n editor.ghostNodes.push(insertedNode => \n   insertedNode.tagName == \"STYLE\" && insertedNode.getAttribute(\"id\") == null && insertedNode.attributes.length == 0 &&\n   insertedNode.parentElement.tagName == \"HEAD\" && typeof insertedNode.isghost === \"undefined\"&& insertedNode.textContent.match(\"error_widget\\\\.ace_warning\")\n   && (insertedNode.setAttribute(\"save-ghost\", \"true\") || true)\n );\n// For ace script for syntax highlight\neditor.ghostNodes.push(insertedNode =>\n  editor.matches(insertedNode, \"script[src]\") &&\n     insertedNode.getAttribute(\"src\").startsWith(\"https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.2/mode-j\")\n);\n// For ace script for syntax highlight\neditor.ghostNodes.push(insertedNode =>\n  insertedNode.tagName == \"ACE_OUTER\"\n);\n// For the grammarly extension\neditor.ghostNodes.push(\n  editor.matches(\".gr-top-z-index, .gr-top-zero\")\n);\n\n// Mark nodes as ghost on insertion, if they are so.\nfunction handleScriptInsertion(mutations) {\n  for(var i = 0; i < mutations.length; i++) {\n    // A mutation is a ghost if either\n    // -- The attribute starts with 'ghost-'\n    // -- It is the insertion of a node whose tag is \"ghost\" or that contains an attribute \"isghost=true\"\n    // -- It is the modification of a node or an attribute inside a ghost node.\n    var mutation = mutations[i];\n    if(hasGhostAncestor(mutation.target) || hasIgnoringAncestor(mutation.target)) continue;\n    if(mutation.type == \"childList\") {\n      for(var j = 0; j < mutation.addedNodes.length; j++) {\n        var insertedNode = mutation.addedNodes[j];\n        if(hasGhostAncestor(insertedNode)) {\n          insertedNode.isghost = true;\n        } else {\n          if(typeof insertedNode.isghost === \"undefined\" && (insertedNode.nodeType == 1 && insertedNode.getAttribute(\"isghost\") != \"true\" || insertedNode.nodeType == 3 && !insertedNode.isghost) && editor.ghostNodes.find(pred => pred(insertedNode, mutation))) {\n           if(insertedNode.nodeType == 1) insertedNode.setAttribute(\"isghost\", \"true\");\n           insertedNode.isghost = true;\n          } else { // Record ignored attributes\n            if(insertedNode.nodeType == 1) {\n              var isIgnoredAttributeKey = isIgnoredAttributeKeyFromNode(insertedNode);\n              for(var k = 0; k < insertedNode.attributes.length; k++) {\n                var attr = insertedNode.attributes[k];\n                isIgnoredAttributeKey(attr.name, attr.value);\n              }\n            }\n          }\n        }\n      }\n    }\n    \n  }\n}\n\nif (typeof automaticGhostMarker !== \"undefined\") {\n  // console.log(\"automaticGhostMarker.disconnect()\");\n  automaticGhostMarker.disconnect();\n}\n\nautomaticGhostMarker = new MutationObserver(handleScriptInsertion);\nautomaticGhostMarker.observe\n ( document.head.parentElement\n , { attributes: false\n   , childList: true\n   , characterData: false\n   , attributeOldValue: false\n   , characterDataOldValue: false\n   , subtree: true\n   }\n )\n\n// Self-editing capabilities\nfunction getSelectionStart() {\n   var node = document.getSelection().anchorNode;\n   return (node != null && node.nodeType == 3 ? node.parentNode : node);\n}\n// Returns the closest ancestor of the selection having the given tagName\nfunction getEnclosingCaret(tagName) {\n  var w = getSelectionStart();\n  while(w != null && w.tagName.toLowerCase() != tagName.toLowerCase()) {\n    w = w.parentNode;\n  }\n  return w;\n}\n\n// Removes all the text from a node (not the text nodes themselves)\nfunction emptyTextContent(node) {\n  if(node != null) {\n    if(node.nodeType == 3) {\n      node.textContent = \"\";\n    } else {\n      for(let i = 0; i < node.childNodes.length; i++) {\n        emptyTextContent(node.childNodes[i]);\n      }\n    }\n  }\n  return node;\n}\neditor.emptyTextContent = emptyTextContent;\n\nfunction insertBefore(parent, node, beforeNode) {\n  if(beforeNode == null) {\n    parent.append(node);\n  } else {\n    parent.insertBefore(node, beforeNode);\n  }\n}\n\nfunction duplicate(node, options) {\n  if(typeof options == \"undefined\") options = {}\n  if(typeof options.onBeforeInsert != \"function\") options.onBeforeInsert = e => e;\n  if(node != null && node.parentNode != null) {\n    var parentInsertion = options.target ? options.target.parentElement : node.parentElement;\n    var insertBeforeNode = options.after ? options.target ? options.target.nextSibling : node.nextSibling :\n                                           options.target ? options.target             : node;\n    if(node.nextSibling != null && !options.target && !options.ignoreText) {\n      var next = node.nextSibling;\n      if(next.nodeType == 3 && next.nextSibling != null &&\n         next.nextSibling.tagName == node.tagName && (node.tagName == \"TR\" || node.tagName == \"TH\" || node.tagName == \"LI\" || node.tagName == \"TD\")) {\n        var textElement = next.cloneNode(true);\n        insertBefore(node.parentNode, textElement, options.after ? node.nextSibling : node);\n        if(options.after) {\n          insertBeforeNode = textElement.nextSibling;\n        } else {\n          insertBeforeNode = textElement\n        }\n      }\n    }\n    var duplicated = node.cloneNode(true);\n    function removeEditorAttributes(node) {\n      if(node.nodeType != 1) return;\n      let attrs = [...node.attributes];\n      for(var i = 0; i < attrs.length; i++) {\n        if(attrs[i].name.match(/^ghost-clicked$|^translate-id.*$/)) {\n          node.removeAttribute(attrs[i].name);\n        }\n      }\n      for(var i = 0; i < node.childNodes; i++) {\n        removeEditorAttributes(node.childNodes[i]);\n      }\n    }\n    removeEditorAttributes(duplicated);\n    \n    var cloned = options.onBeforeInsert(duplicated);\n    insertBefore(parentInsertion, cloned, insertBeforeNode);\n    return cloned;\n  }\n}\neditor.duplicate = duplicate;\n\nfunction remove(node, options) {\n  if(typeof options == \"undefined\") options = {}\n  if(node.previousSibling != null && !options.ignoreText) { // Remove whitespace as well\n    var next = node.nextSibling;\n    if(next.nodeType == 3 && next.nextSibling != null &&\n       next.nextSibling.tagName == node.tagName && (node.tagName == \"TR\" || node.tagName == \"TH\" || node.tagName == \"LI\" || node.tagName == \"TD\")) {\n      next.remove();\n    }\n  }\n  node.remove();\n}\neditor.remove = remove;\n</script>\n]\n\n-- Script added to the end of the page\nlastEditScript = \"\"\" \n    console.log(\"lastEditScript running\");\n    var onMobile = () => window.matchMedia(\"(max-width: 800px)\").matches;\n    var buttonHeight = () => onMobile() ? 48 : 30;\n    var buttonWidth  = () => onMobile() ? 48 : 40;\n\n\n\t  // Before saving, call this function to that it eventually triggers a save action to any file.\n\t  function addFileToSave(path, oldcontent, newcontent) {\n\t    var placement = document.querySelector(\"#editor-files-to-overwrite\");\n\t    if(!placement) {\n\t      console.log(\"could not save file \" + name + \"because #editor-files-to-overwrite not found.\");\n\t      return;\n\t    }\n      let existingDiv = placement.querySelector(\"div[name='\"+path+\"']\");\n      if(existingDiv) {\n        existingDiv.setAttribute(\"newcontent\", newcontent);\n      } else {\n\t      placement.append(el(\"div\", {class: \"file-overwrite\", name:path, oldcontent: oldcontent, newcontent: newcontent}));\n      }\n\t  }\n    \n\n  \n\t  // Save/Load ghost attributes after a page is reloaded, only if elements have an id.\n\t  // Same for some attributes\n\t  function saveGhostAttributes() {\n\t    var ghostModified = document.querySelectorAll(\"[ghost-visible]\");\n\t    var savedGhostAttributes = [];\n\t    for(var i = 0; i < ghostModified.length; i++) {\n\t      var elem = ghostModified[i];\n\t      savedGhostAttributes.push([editor.toTreasureMap(elem),\n\t          \"ghost-visible\", ghostModified[i].getAttribute(\"ghost-visible\")]);\n\t    }\n\n\n\t    function saveAttributes(name) {\n\t       var ghostAttributesModified = document.querySelectorAll(\"[\"+name+\"]\");\n\t      for(var i = 0; i < ghostAttributesModified.length; i++) {\n\t        var elem = ghostAttributesModified[i];\n\t        var toSave = elem.getAttribute(name).split(\" \");\n\t        for(j in toSave) {\n\t          var key = toSave[j];\n\t          savedGhostAttributes.push([editor.toTreasureMap(elem), key, elem.getAttribute(key)]);\n\t        }\n\t      }\n\t    }\n      saveAttributes(\"save-ghost-attributes\");\n      saveAttributes(\"save-ignored-attributes\");  \n    \n      var elemsWithAttributesToSave = document.querySelectorAll(\"[save-properties]\");\n\t    var savedProperties = [];\n\t    for(var i = 0; i < elemsWithAttributesToSave.length; i++) {\n\t      var elem = elemsWithAttributesToSave[i];\n\t      var toSave = elem.getAttribute(\"save-properties\").split(\" \");\n\t      for(j in toSave) {\n\t        var key = toSave[j];\n\t        savedProperties.push([editor.toTreasureMap(elem), key, elem[key]])\n        }\n      }\n      var parentsGhostNodes = [];\n      var ghostElemsToReinsert = document.querySelectorAll(\"[save-ghost]\");\n      for(var i = 0; i < ghostElemsToReinsert.length; i++) {\n        var elem = ghostElemsToReinsert[i];\n        parentsGhostNodes.push({parent: editor.toTreasureMap(elem.parentNode), node: elem});\n      }\n      return [savedGhostAttributes, savedProperties, parentsGhostNodes];\n    }\n    function applyGhostAttributes(attrs) {\n      var [savedGhostAttributes, savedProperties, parentsGhostNodes] = attrs;\n      for(var i in savedGhostAttributes) {\n        var [data, key, attr] = savedGhostAttributes[i];\n        var elem = editor.fromTreasureMap(data);\n        if(elem != null) {\n          elem.setAttribute(key, attr);\n        }\n      }\n      for(var i in savedProperties) {\n        var [data, key, value] = savedProperties[i];\n        var elem = editor.fromTreasureMap(id);\n        if(elem != null) {\n          elem[key] = value;\n        }\n      }\n      for(var i in parentsGhostNodes) {\n        var {parent: data, node: elem} = parentsGhostNodes[i];\n        var parent = editor.fromTreasureMap(data);\n        if(parent != null) {\n          if(!elem.getAttribute(\"id\") || !document.getElementById(elem.getAttribute(\"id\"))) {\n            parent.appendChild(elem);\n          }\n        }\n      }\n    }\n    \n    function domNodeToNativeValue(n) {\n      if(n.nodeType == 3) {\n        return [\"TEXT\", n.textContent];\n      } else if(n.nodeType == 8) {\n        return [\"COMMENT\", n.textContent];\n      } else {\n        var attributes = [];\n        var isSpecificGhostAttributeKey = isSpecificGhostAttributeKeyFromNode(n);\n        var isIgnoredAttributeKey =  isIgnoredAttributeKeyFromNode(n); // TODO recover ignored value\n        for(var i = 0; i < n.attributes.length; i++) {\n          var key = n.attributes[i].name;\n          var ignored = isIgnoredAttributeKey(key);\n          if(!isGhostAttributeKey(key) && !isSpecificGhostAttributeKey(key) || ignored) {\n            var value = ignored ? ignoredAttributeValue(n, key) : n.attributes[i].value;\n            if(key == \"style\") {\n              value = value.split(\";\").map(x => x.split(\":\")).filter(x => x.length == 2)\n            }\n            attributes.push([key, value]);\n          }\n        }\n        var children = [];\n        if(n.__editor__ && n.__editor__.ignoredChildNodes) {\n          children = n.__editor__.ignoredChildNodes;\n        } else {\n          var childNodes = n.childNodes;\n          if(n.tagName.toLowerCase() === \"noscript\" && n.childNodes.length === 1 && n.childNodes[0].nodeType === 3) {\n            // We'll recover the associated HTML node\n            childNodes = el(\"div\", {}, [], {innerHTML: n.childNodes[0].textContent, parentNode: n}).childNodes;\n          }\n          if(!areChildrenGhosts(n)) {\n            for(i = 0; i < childNodes.length; i++) {\n              if(!isGhostNode(childNodes[i])) {\n                children.push(domNodeToNativeValue(childNodes[i]));\n              }\n            }\n          }\n        }\n        return [n.tagName.toLowerCase(), attributes, children];\n      }\n    }\n\n    //(outer lastEditScript)\n    function saveDisplayProperties() {\n      let ret = document.querySelector(\"#textChildNodeContentDiv\");\n      if(ret) {\n        editor_model.textareaPropertiesSaved = [];\n        for(let i = 0; i < ret.childNodes.length; i++) {\n          if(ret.childNodes[i].tagName === \"TEXTAREA\") {\n            editor_model.textareaPropertiesSaved[i] = {\n              scrollTop: ret.childNodes[i].scrollTop,\n              selectionEnd: ret.childNodes[i].selectionStart,\n              selectionStart: ret.childNodes[i].selectionEnd,\n              focus: ret.childNodes[i] === document.activeElement\n            };\n          }\n        }\n      }\n    }\n    \n    function replaceContent(NC) {\n      saveDisplayProperties();\n      if(editor_model.caretPosition) {\n        editor_model.caretPosition = dataToRecoverCaretPosition(editor_model.caretPosition);\n      }\n      if(editor_model.selectionRange) {\n        editor_model.selectionRange = dataToRecoverSelectionRange(editor_model.selectionRange);\n      }\n      if(editor_model.clickedElem) {\n        editor_model.clickedElem = editor.toTreasureMap(editor_model.clickedElem);\n      }\n      writeDocument(NC);\n    }\n    \n    handleServerPOSTResponse = (xmlhttp, onBeforeUpdate) => function () {\n        if (xmlhttp.readyState == XMLHttpRequest.DONE) {\n          editor_model.isSaving = false;\n          if(typeof onBeforeUpdate !== \"undefined\") onBeforeUpdate();\n          var saved = saveGhostAttributes();\n          //return\n          \n          //source of the editing menu disappearing after reloading\n          replaceContent(xmlhttp.responseText);\n          \n          applyGhostAttributes(saved);\n          var newLocalURL = xmlhttp.getResponseHeader(\"New-Local-URL\");\n          var newQueryStr = xmlhttp.getResponseHeader(\"New-Query\");\n          var ambiguityKey = xmlhttp.getResponseHeader(\"Ambiguity-Key\");\n          var ambiguityNumber = xmlhttp.getResponseHeader(\"Ambiguity-Number\");\n          var ambiguitySelected = xmlhttp.getResponseHeader(\"Ambiguity-Selected\");\n          var ambiguityEnd = xmlhttp.getResponseHeader(\"Ambiguity-End\");\n          var ambiguitySummaries = xmlhttp.getResponseHeader(\"Ambiguity-Summaries\");\n          if(ambiguityKey !== null && typeof ambiguityKey != \"undefined\" &&\n             ambiguityNumber !== null && typeof ambiguityNumber != \"undefined\" &&\n             ambiguitySelected !== null && typeof ambiguitySelected != \"undefined\") {\n            var n = JSON.parse(ambiguityNumber);\n            console.log (\"handleServerPOSTResponse ambiguity\");\n            var selected = JSON.parse(ambiguitySelected);\n            var summaries = JSON.parse(ambiguitySummaries);\n            \n            var disambiguationMenuContent = [];\n            disambiguationMenuContent.push(el(\"span#ambiguity-id\", {v: ambiguityKey}, \"Choose the update you prefer, and click the save button:\"));\n            // Find the common path of all files so that we don't need to repeat its name or path.\n            var fileOf = x => x.replace(/^(.*): *\\n[\\s\\S]*$/, \"$1\")\n            var commonPrefix = fileOf(summaries[1]);\n            for(var i = 1; i <= n; i++) {\n              while(!fileOf(summaries[i - 1]).startsWith(commonPrefix)) {\n                let n = commonPrefix.replace(/^(.*)(?:\\/|\\\\).*$/, \"$1\");\n                commonPrefix = n === commonPrefix ? \"\" : n;\n              }\n            }\n            if(commonPrefix) {\n              disambiguationMenuContent.push(el(\"span#ambiguity-prefix\", {}, commonPrefix + \":\"));\n            }\n            for(var i = 1; i <= n; i++) {\n              var summary = summaries[i-1].substring(commonPrefix.length).\n                    replace(/\"/g,'&quot;').\n                    replace(/</g, \"&lt;\").\n                    replace(/---\\)|\\+\\+\\+\\)/g, \"</span>\").\n                    replace(/\\(---/g, \"<span class='remove'>\").\n                    replace(/\\(\\+\\+\\+/g, \"<span class='add'>\").\n                    replace(/(\\nL\\d+C\\d+:)(.*)/, \"$1<span class='codepreview'>$2</span>\");\n              disambiguationMenuContent.push(el(\"span.solution\" + (i == selected ? \".selected\" : \"\") + (i == n && ambiguityEnd != 'true' ? '.notfinal' : ''), {\n              title: i == selected ? \"Currently displaying this solution\" : \"Select this solution\" + (i == n && ambiguityEnd != 'true' ? \" (compute further solutions after if any)\" : \"\"), onclick: i == selected ? `` : `this.classList.add('to-be-selected'); selectAmbiguity('${ambiguityKey}', ${i})`}, \"\", {innerHTML: \"#\" + i + \" \" + summary}));\n            }\n            disambiguationMenuContent.push(el(\"button#cancelAmbiguity.action-button\", {title: \"Revert to the original version\", onclick: `cancelAmbiguity(\"${ambiguityKey}\", ${selected})`}, \"Cancel\"));\n            editor_model.disambiguationMenu = el(\"div.disambiguationMenu\", {}, disambiguationMenuContent);\n            editor_model.disambiguationMenu.ambiguityKey = ambiguityKey;\n            editor_model.disambiguationMenu.selected = selected;\n            editor_model.clickedElem = undefined;\n            editor_model.displayClickedElemAsMainElem = true;\n            editor_model.notextselection = false;\n            editor_model.caretPosition = undefined;\n            editor_model.link = undefined;\n            var advancedBlock = getEditorInterfaceByTitle(\"Advanced\");\n            if(advancedBlock) advancedBlock.minimized = false;\n            editor_model.visible = true;\n            //editor_model.displaySource: false, // Keep source opened or closed\n            // TODO: Disable click or change in DOM until ambiguity is resolved.\n          } else { //no ambiguity\n            if(editor_model.disambiguationMenu && editor_model.disambiguationMenu.replayActionsAfterSave) {\n              console.log(\"disambiguationMenu was there. replaying actions\");\n              editor_model.disambiguationMenu.replayActionsAfterSave(\"Modifications applied\");\n            } else {\n              console.log(\"disambiguationMenu is not there.\");\n            }\n            editor_model.disambiguationMenu = undefined;\n            let opSummaryEncoded = xmlhttp.getResponseHeader(\"Operations-Summary\");\n            if(opSummaryEncoded) {\n              var opSummary = decodeURI(opSummaryEncoded);\n              opSummary =\n                opSummary.\n                replace(/</g, \"&lt;\").\n                replace(/---\\)/g, \"</span>\").\n                replace(/\\(---/g, \"<span class='remove'>\").\n                replace(/\\+\\+\\+\\)/g, \"</span>\").\n                replace(/\\(\\+\\+\\+/g, \"<span class='add'>\");\n              editor_model.editor_log.push(opSummary);\n              // sendNotification(opSummary);\n            }\n          } // /noambiguity\n          var strQuery = \"\";\n          if(newQueryStr != null) { //newQueryStr = undefined ==> (newQueryStr !== null) ==> false;\n            var newQuery = JSON.parse(newQueryStr);\n            for(var i = 0; i < newQuery.length; i++) {\n              var {_1: key, _2: value} = newQuery[i];\n              strQuery = strQuery + (i == 0 ? \"?\" : \"&\") + key + (value === \"\" && key == \"edit\" ? \"\" : \"=\" + value)\n            } \n          }\n          if(newLocalURL) { // Overrides query parameters\n            window.history[xmlhttp.customRequestHeaders && xmlhttp.customRequestHeaders.replaceState == \"true\" ? \"replaceState\" : \"pushState\"]({localURL: newLocalURL}, \"Nav. to \" + newLocalURL, newLocalURL);\n          } else if(strQuery) {\n            window.history.replaceState({}, \"Current page\", strQuery);\n          }\n          updateInteractionDiv(); \n        } //xhr.onreadystatechange == done\n    } //handleServerPOSTResponse\n    \n    window.onpopstate = function(e){\n        console.log(\"onpopstate\", e);\n        if(e.state && e.state.localURL) {\n          navigateLocal(location, true);\n        } else {\n          navigateLocal(location.pathname + location.search, true);\n        }\n    };\n    \n    notifyServer = (requestHeaders, toSend, what) => {\n      if(apache_server) {\n        let data = {action:\"sendRequest\",\n                    toSend: toSend || \"{\\\"a\\\":2}\",\n                    gaidt:googleAuthIdToken,\n                    aq:editor_model.askQuestions,\n                    loc: location.pathname + location.search,\n                    requestHeaders: requestHeaders,\n                    what: what,\n                    server_content: (typeof SERVER_CONTENT == \"undefined\" ? undefined : SERVER_CONTENT)};\n        editor_model.serverWorker.postMessage(data);\n      } else {\n        var xmlhttp = new XHRequest();\n        xmlhttp.onreadystatechange = handleServerPOSTResponse(xmlhttp);\n        xmlhttp.open(\"POST\", location.pathname + location.search);\n        xmlhttp.setRequestHeader(\"Content-Type\", \"application/json\");\n        if(googleAuthIdToken) { // Obsolete\n          xmlhttp.setRequestHeader(\"id-token\", googleAuthIdToken)\n        }\n        if(requestHeaders) {\n          for(let k in requestHeaders) {\n            xmlhttp.setRequestHeader(k, requestHeaders[k]);\n          }\n        }\n        xmlhttp.customRequestHeaders = requestHeaders;\n        xmlhttp.send(toSend || \"{\\\"a\\\":2}\");\n      }\n    }\n    \n    function reloadPage() {\n      sendNotification(\"Reloading...\");\n      notifyServer({reload: \"true\"}, undefined, \"Reload\");\n    }\n    function relativeToAbsolute(url) {\n      if(isAbsolute(url) || url && url.length && url[0] == \"/\") return url;\n      let u =  new URL(location.href);\n      if(url[0] === \"#\") {\n        return u.pathname + url; \n      }\n      else {\n        return u.pathname.replace(/[^\\/]*$/, \"\") + url;\n      }\n    }\n    function navigateLocal(url, replaceState) {\n      sendNotification(\"Loading...\");\n      notifyServer({reload: \"true\", url: url, replaceState: \"\"+replaceState}, undefined, \"Page load\");\n    }\n    \n    function selectAmbiguity(key, num) {\n      notifyServer({\"ambiguity-key\": key, \"select-ambiguity\": JSON.stringify(num), \"question\": \"true\"});\n    }\n    \n    function acceptAmbiguity(key, num) {\n      notifyServer({\"ambiguity-key\": key, \"accept-ambiguity\": JSON.stringify(num)});\n    }\n    \n    function cancelAmbiguity(key, num) {\n      notifyServer({\"ambiguity-key\": key, \"cancel-ambiguity\": JSON.stringify(num)});\n    }\n    function sendModificationsToServerNode() {\n      if(document.getElementById(\"notification-menu\") != null) {\n        //document.getElementById(\"notification-menu\").innerHTML = `cannot send the server more modifications until it resolves these ones. Refresh the page?`\n        // TODO: Listen and gather subsequent modifications when it is loading\n        return;\n      }\n      editor_model.isSaving = true;\n      var newMenu = el(\"menuitem#notification-menu.to-be-selected\", {isghost: true});\n      if(document.getElementById('lastaction')) {\n        document.getElementById('lastaction').remove();\n      }\n      if(document.getElementById(\"modify-menu\")) {\n        document.getElementById(\"modify-menu\").append(newMenu);\n      }\n      saveDisplayProperties();\n      updateInteractionDiv();\n      setTimeout( () => {\n        notifyServer({\"question\": editor_model.askQuestions ? \"true\" : \"false\"},\n          JSON.stringify(domNodeToNativeValue(document.body.parentElement)));\n      }, 0);\n    }\n\n    function sendModificationsToServer() {\n      if(document.getElementById(\"notification-menu\") != null) {\n        //document.getElementById(\"notification-menu\").innerHTML = `Please wait until previous saving completes.`\n        // TODO: Listen and gather subsequent modifications when it is loading\n        return;\n      }\n      editor_model.isSaving = true;\n      var newMenu = el(\"menuitem#notification-menu.to-be-selected\", {isghost: true});\n      if(document.getElementById('lastaction')) {\n        document.getElementById('lastaction').remove();\n      }\n      if(document.getElementById(\"modify-menu\")) {\n        document.getElementById(\"modify-menu\").append(newMenu);\n      }\n      editor_model.actionsDuringSave = [];\n      updateInteractionDiv();\n      sendNotification(\"Saving...\");\n      const tosend = JSON.stringify(domNodeToNativeValue(document.body.parentElement));\n      let data = {action:\"sendRequest\", \n                  toSend:tosend,\n                  gaidt:googleAuthIdToken,\n                  aq:editor_model.askQuestions,\n                  loc:location.pathname + location.search,\n                  what: \"Save\",\n                  server_content:(typeof SERVER_CONTENT == \"undefined\" ? undefined : SERVER_CONTENT)};\n      \n      editor_model.serverWorker.postMessage(data);\n    } //sendModificationsToServer\n\n    function removeTimestamp(path) {\n      var dummyIndex = path.indexOf(\"?\");\n      if(dummyIndex > -1) {\n        path = path.slice(0, dummyIndex);\n      }\n      return path;\n    }\n    function setTimestamp(path) {\n      path = removeTimestamp(path);\n      path += \"?timestamp=\" + (+new Date());\n      return path;\n    }\n\n    function sendToUndo(m) {\n      var time = +new Date();\n      //for childLists, add mutable next/previous sibling properties\n      if(m.type === \"childList\") {\n          /*Object.defineProperty(m, 'rePrevSib', {value: m.previousSibling /*&& !(m.previousSibling.nodeType == 1)) ? \n                                                m.previousSibling.previousElementSibling : m.previousSibling, \n                                                writable: true});\n          Object.defineProperty(m, 'reNextSib', {value: m.nextSibling /*&& !(m.nextSibling.nodeType == 1)) ? \n                                                m.nextSibling.nextElementSibling : m.nextSibling,\n                                                writable: true});*/\n      }\n        //for attributes/characterData, add alternative mutable oldValue\n      else {\n        Object.defineProperty(m, 'URValue', {value: m.oldValue, writable: true});\n      }\n      //Object.defineProperty(m, 'timestamp', {value: time})\n      m.timestamp = time;\n      //check if the last element on currently on the stack is operating on the same \"information\", i.e. oldValue or nodelists\n      //and should be combined together when undoing/redoing\n      \n      let lastUndo = editor_model.undoStack[editor_model.undoStack.length-1];\n      //makes single actions that are recorded as multiple mutations a single action\n      //true here ==> mutation is separate action\n      if(!lastUndo || (lastUndo[0].timestamp < (time - 10))) {  \n        if (editor_model.isSaving) {\n          editor_model.actionsDuringSave.unshift(\"undo\");\n        }\n        editor_model.undoStack.push([m]);\n        editor_model.redoStack = [];\n      }\n      //false here ==> mutation is same action as last mutation\n      //makes no sense for somethign that is first added then removed for those actions to be grouped together \n      //i.e. if i add text then get rid of it, it makes no sense for undo to revert the removal and addition direclty in sequence\n      else {\n        lastUndo = editor_model.undoStack.pop();\n        lastUndo.push(m);\n        editor_model.undoStack.push(lastUndo);\n      }     \n    } //sendToUndo\n\n    // Timeout for autosave\n    var t = undefined;\n    \n    function handleMutations(mutations, observer) {\n      var onlyGhosts = true;\n      for(var i = 0; i < mutations.length; i++) {\n        // A mutation is a ghost if either\n        // -- The attribute starts with 'ghost-'\n        // -- It is the insertion of a node whose tag is \"ghost\" or that contains an attribute \"isghost=true\"\n        // -- It is the modification of a node or an attribute inside a ghost node.\n        /*  \n         * Add mutations to undo list if they are not ghosts and if they are really doing something.\n         */\n        let mutation = mutations[i];\n        if(hasGhostAncestor(mutation.target)) {\n          continue;\n        }\n        if(mutation.type == \"attributes\") {\n          var isSpecificGhostAttributeKey = isSpecificGhostAttributeKeyFromNode(mutation.target);\n          var isIgnoredAttributeKey = isIgnoredAttributeKeyFromNode(mutation.target);\n          if(isGhostAttributeKey(mutation.attributeName) || isSpecificGhostAttributeKey(mutation.attributeName) ||\n             mutation.target.getAttribute(mutation.attributeName) === mutation.oldValue ||\n             isIgnoredAttributeKey(mutation.attributeName)) {\n          } else {\n            onlyGhosts = false;\n            sendToUndo(mutation);\n            // Please do not comment out this line until we get proper clever save.\n            console.log(\"Attribute is not ghost\", mutation);\n            console.log(\"TIP: Use this script if you want to mark it as ghost:\");\n            let sel = getShortestUniqueSelector(mutation.target);\n            if(typeof mutation.oldValue === \"undefined\") {\n              console.log(\"editor.ghostAttrs.push(n => editor.matches(n, '\"+sel+\"') ? ['\"+mutation.attributeName+\"'] : []);\")\n            } else {\n              console.log(\"editor.ignoredAttrs.push(n => editor.matches(n, '\"+sel+\"') ? ['\"+mutation.attributeName+\"'] : []);\")\n            }\n          }\n        } else if(mutation.type == \"childList\") {\n          if(!areChildrenGhosts(mutation.target)) {\n            for(var j = 0; j < mutation.addedNodes.length; j++) {\n              if(!hasGhostAncestor(mutation.addedNodes[j]) && !hasIgnoringAncestor(mutation.addedNodes[j])) {\n                onlyGhosts = false;\n                sendToUndo(mutation);\n                // Please do not comment out this line until we get proper clever save.\n                console.log(`Added node ${j} does not have a ghost ancestor`, mutation);\n                console.log(\"TIP: Ignore node and siblings with this script:\");\n                let sel = getShortestUniqueSelector(mutation.target);\n                console.log(\"editor.ignoredChildNodes.push(editor.matches('\"+sel+\"'));\");\n                if(mutation.addedNodes[j].nodeType === 1) {\n                  console.log(\"TIP: Mark this element as ghost:\");\n                  sel = getShortestUniqueSelector(mutation.addedNodes[j]);\n                  console.log(\"editor.ghostNodes.push(editor.matches('\"+sel+\"'));\");\n                }\n              }\n            }\n            for(var j = 0; j < mutation.removedNodes.length; j++) {\n              if(!isGhostNode(mutation.removedNodes[j]) && !isIgnoringChildNodes(mutation.target) && !hasIgnoringAncestor(mutation.target)) {\n                onlyGhosts = false;\n                sendToUndo(mutation);\n                // Please do not comment out this line until we get proper clever save.\n                console.log(`Removed node ${j} was not a ghost`, mutation);\n                console.log(\"TIP: Mark this element as ghost:\");\n                let sel = getShortestUniqueSelector(mutation.target);\n                console.log(\"editor.ignoredChildNodes.push(editor.matches('\"+sel+\"'));\");\n              }\n            }\n          }\n        } else {\n          onlyGhosts = false;\n          sendToUndo(mutation);\n          // Please do not comment out this line until we get proper clever save.\n          console.log(\"mutations other than attributes, childList and characterData are not ghosts\", mutations);\n        }\n      }\n      if(onlyGhosts) {\n        return;\n      } // Send in post the new HTML along with the URL\n      // Set undo/redo state\n      syncUndoRedoButtons();\n      \n      if(!editor_model.autosave) {\n        var saveButtons = document.querySelectorAll(\".saveButton\");\n        // TODO: Can we regenerate the whole interface for consistency?\n        for(let sb of saveButtons) {\n          sb.classList.toggle(\"disabled\", false);\n        }\n        return;\n      } \n      //autosave is on\n      if(typeof t !== \"undefined\") {\n        clearTimeout(t);\n      }\n      t = setTimeout(function() {\n        t = undefined;\n        if (apache_server) {\n          sendModificationsToServer();\n        } else {\n          sendModificationsToServerNode();\n        }\n      }, typeof editdelay != \"undefined\" ? editodelay : 1000)\n    } //handleMutations\n  \n    //debugging function for printing both teh undo and redo stacks.\n    function printstacks() {\n      console.log(\"-----------------------------\");\n      let i, j;\n      console.log(\"UNDO STACK:\");\n      for(i = 0; i < editor_model.undoStack.length; i++) {\n        console.log(i + \".\");\n        for(j = 0; j < editor_model.undoStack[i].length; j++) {\n          console.log(editor_model.undoStack[i][j]);\n        }\n      }\n      console.log(\"REDO STACK:\");\n      for(i = 0; i < editor_model.redoStack.length; i++) {\n        console.log(i + \".\"); \n        for(j = 0; j < editor_model.redoStack[i].length; j++) {\n          console.log(editor_model.redoStack[i][j]);\n        }\n      }\n      console.log(\"-----------------------------\");\n    }\n    function canUndo() {\n      return editor_model.undoStack.length > 0;\n    }\n\n    //undo function: handles undo feature\n    function undo() {\n      let undoElem = editor_model.undoStack.pop();\n      //need to check if undoStack is empty s.t. we can set the \"savability\" of the document accurately\n      if(undoElem == undefined) {\n        return 0;\n      }\n      (async () => {\n      //TODO prevent pressing the undo button while save underway while letting Editor use the undo function. (just not the user);\n      //need to disconnect the MutationObserver such that our undo does not get recorded as a mutation\n      editor_stopWatching();\n      const quicker = node => recoverElementFromData(dataToRecoverElement(node));\n      let k;\n      for(k = undoElem.length - 1; k >= 0; k--) {\n        let mutType = undoElem[k].type; \n        let qk = quicker(undoElem[k].target);\n        \n        let target = (undoElem[k].target.isConnected ? \n                        undoElem[k].target :\n                        (qk == undefined ? undoElem[k].target : qk));\n        //in each case, we reverse the change, setting the URValue/oldValue as the current value\n        //at the target, and replacing the URValue/oldValue with the current value present in target\n        if(mutType === \"attributes\") {\n          let cur_attr = target.getAttribute(undoElem[k].attributeName);\n          if(undoElem[k].URValue === null) {\n            target.removeAttribute(undoElem[k].attributeName); \n          }       \n          else { \n            target.setAttribute(undoElem[k].attributeName, undoElem[k].URValue);\n          }\n          undoElem[k].URValue = cur_attr; \n        }\n        else if(mutType === \"characterData\") {\n          const cur_data = target.textContent;\n          target.textContent = undoElem[k].URValue;\n          undoElem[k].URValue = cur_data;\n          //undoElem[k].isConnected ? undoElem[k].URValue : quicker(undoElem[k]).URValue = cur_data;\n        }\n        else if(mutType === \"linkHrefCSS\") { // There should be only one such even\n          var keepUndo = undoElem[k];\n          await assignTmpCss(target, keepUndo.oldValue, true);\n        }\n        else {\n          let uRemNodes = undoElem[k].removedNodes;\n          let uAddNodes = undoElem[k].addedNodes;\n          //readding the removed nodes\n          // -in this case, we loop through the childNodes and add them in the appropriate spot \n          // or remove them \n          // NOTE: we only change the nextSib property of the undoElem, and alternate between adding/removing from the \n          //       addedNodes & removedNodes lists depending on whether we are undoing (in which case we will add)\n          // NOTE: Since there is only one nextSibling/prevSibling property, and based off the fact that MutationObserver\n          //       should take into account every mutation, we should only have elements in one of uRemNodes and uAddNodes\n          //       at once.\n          let kidNodes = target.childNodes;\n          let i, j;\n          if(uRemNodes.length) {\n            if(kidNodes.length === 0) {            \n              if(undoElem[k].nextSibling == null && undoElem[k].previousSibling == null) {\n                for(i = 0; i < uRemNodes.length; i++) { \n                  /*if(hasGhostAncestor(uRemNodes.item(i))) {\n                    continue;\n                  }*/\n                  target.appendChild(uRemNodes.item(i)); \n                }\n              }\n            }\n            for(j = 0; j < kidNodes.length; j++) {  \n              let ns = undoElem[k].nextSibling && undoElem[k].nextSibling.isConnected ? undoElem[k].nextSibling : quicker(undoElem[k].nextSibling);\n              let ps = undoElem[k].previousSibling && undoElem[k].previousSibling.isConnected ? undoElem[k].previousSibling : quicker(undoElem[k].previousSibling);\n\n              let knode = kidNodes.item(j);\n              let knode_may = quicker(knode);\n              //if(kidNodes.item(j) === undoElem[k].nextSibling && kidNodes.item(j).previousSibling === undoElem[k].previousSibling) {\n              if ((knode == ns || knode_may == ns || ns == undefined) &&\n                  (knode.previousSibling == ps || knode_may.previousSibling == ps || ps == undefined || ((knode == ps) && !(ns == ps)))){\n                for(i = 0; i < uRemNodes.length; i++) { \n                  /*if(hasGhostAncestor(uRemNodes.item(i))) {\n                    continue;\n                  }*/\n                  let uremnode = uRemNodes.item(i);\n                  let urn = quicker(uremnode);\n                  //debugger;\n                  if (ns) {\n                    target.insertBefore(urn == undefined ? uremnode : urn, knode.isConnected ? knode : knode_may); \n                  }\n                  else {\n                    target.appendChild(urn == undefined ? uremnode : urn, knode.isConnected ? knode : knode_may);\n                  }\n                }\n              }\n            }\n          }\n          for(i = 0; i < uAddNodes.length; i++) {\n            /*if(hasGhostAncestor(uAddNodes.item(i))) {\n              continue;\n            }*/\n            if(!target.contains(uAddNodes.item(i))) {\n              console.log(\"The item you are trying to undo doesn't exist in the parent node.\");\n            }\n            else {\n              target.removeChild(uAddNodes.item(i));\n            }\n          }\n        }\n      } //mutation looper\n      editor_model.redoStack.push(undoElem);\n      if (editor_model.isSaving) {\n        editor_model.actionsDuringSave.unshift(\"redo\");\n      }\n      //TODO make sure save button access is accurate (i.e. we should ony be able to save if there are thigns to undo)\n      //turn MutationObserver back on\n      editor_resumeWatching();\n      updateInteractionDiv();\n      //printstacks();\n      })();\n      return 1;\n    } //undo\n\n    \n    function canRedo() {\n      return editor_model.redoStack.length > 0;\n    }\n    \n    function redo() {\n      let redoElem = editor_model.redoStack.pop();\n      if(redoElem === undefined) {\n        return 0;\n      }\n      (async () => {\n      editor_stopWatching();\n      const quicker = node => recoverElementFromData(dataToRecoverElement(node));\n      let k;\n      for(k = 0; k < redoElem.length; k++) {\n        let mutType = redoElem[k].type;\n        let qk = quicker(redoElem[k].target);\n        let target = (redoElem[k].target.isConnected ? \n                        redoElem[k].target : \n                        (qk == undefined ? redoElem[k].target : qk));\n        if(mutType === \"attributes\") {\n          let cur_attr = target.getAttribute(redoElem[k].attributeName);\n          if (redoElem[k].URValue === null) {\n            target.removeAttribute(redoElem[k].attributeName); \n          } else { \n            target.setAttribute(redoElem[k].attributeName, redoElem[k].URValue);\n          }\n          redoElem[k].URValue = cur_attr;\n        } \n        else if(mutType === \"characterData\") {\n          let cur_data = target.textContent;\n          target.textContent = redoElem[k].URValue;  \n          redoElem[k].URValue = cur_data;\n          //redoElem[k].isConnected ? redoElem[k].URValue : quicker(redoElem[k]).URValue = cur_data;\n        }\n        else if(mutType === \"linkHrefCSS\") {\n          let keepRedo = redoElem[k];\n          await assignTmpCss(target, keepRedo.newValue, true);\n        }\n        else {\n          let rRemNodes = redoElem[k].removedNodes;\n          let rAddNodes = redoElem[k].addedNodes;\n          let i, j;\n          let kidNodes = target.childNodes;\n          if(rAddNodes.length) {\n            for(j = 0; j < kidNodes.length; j++) {\n              let knode = kidNodes.item(j);\n              let raddnode = rAddNodes.item(i);\n              let ran = quicker(raddnode);\n              let knode_may = quicker(knode);\n              //if(kidNodes.item(j) === redoElem[k].nextSibling && kidNodes.item(j).previousSibling === redoElem[k].previousSibling)\n              let ns = redoElem[k].nextSibling && redoElem[k].nextSibling.isConnected ? redoElem[k].nextSibling : quicker(redoElem[k].nextSibling);\n              let ps = redoElem[k].previousSibling && redoElem[k].previousSibling.isConnected ? redoElem[k].previousSibling : quicker(redoElem[k].previousSibling);\n              if ((knode == ns || knode_may == ns || ns == undefined) &&\n                  (knode.previousSibling == ps || knode_may.previousSibling == ps || ps == undefined || ((knode == ps) && !(ns == ps)))) {\n                for(i = 0; i < rAddNodes.length; i++) {\n                  /*console.log(hasGhostAncestor);\n                  if(hasGhostAncestor(rAddNodes.item(i))) {\n                    continue;\n                  }*/\n                  console.log(rAddNodes.item(i));\n\n                  if(ns) {\n                    target.insertBefore(ran == undefined ? rAddNodes.item(i) : ran, knode.isConnected ? knode : knode_may);\n                  }\n                  else {\n                    target.appendChild(ran == undefined ? rAddNodes.item(i) : ran, knode.isConnected ? knode : knode_may);\n\n                  }\n                }\n              }\n            }\n          }\n          for(i = 0; i < rRemNodes.length; i++) {\n            /*if(hasGhostAncestor(rRemNodes.item(i))) {\n              continue;\n            }*/if(!target.parentElement.contains(quicker(rRemNodes.item(i)))) { //bc the node in rRemNodes isn't necessarily connected, we need to rewrite this.\n              console.log(\"The item you are trying to redo doesn't exist in the parent node.\");\n            } else {\n              target.removeChild(quicker(rRemNodes.item(i)));\n            }\n          }\n        }\n      } //mut looper\n      editor_model.undoStack.push(redoElem);\n      if (editor_model.isSaving) {\n        editor_model.actionsDuringSave.unshift(\"undo\");\n      }\n      editor_resumeWatching();\n      updateInteractionDiv();\n      //printstacks();\n      })();\n      return 1;\n    } //end of redo\n\n    function syncUndoRedoButtons() {\n      let undoButton = document.querySelector(\"#undobutton\");\n      let redoButton = document.querySelector(\"#redoButton\");\n      if(undoButton) undoButton.classList.toggle(\"disabled\", !canUndo());\n      if(redoButton) redoButton.classList.toggle(\"disabled\", !canRedo());\n      let saveButton = document.querySelector(\".saveButton\");\n      if(saveButton) saveButton.classList.toggle(\"disabled\", !editor_canSave() && !editor_model.disambiguationMenu);\n    }\n    \n    // When selecting some text, mouse up on document, the focus node is outside of the anchor node. We want to prevent this from happening\n    function fixSelection() {\n      var sel = window.getSelection();\n      if(!sel || !sel.rangeCount) return;\n      sel = sel.getRangeAt(0);\n      if(sel.startContainer.nodeType !== 3) return;\n      if(sel.endContainer.nodeType !== 1) return;\n      // We'll ensure that the end of selection is inside a text node.\n      if(sel.startContainer.parentElement === sel.endContainer.childNodes[sel.endOffset].previousElementSibling ||\n         sel.startContainer.parentElement.nextElementSibling === sel.endContainer && sel.endOffset === 0 ||\n         sel.startContainer.parentElement.nextElementSibling === sel.endContainer.parentElement && sel.endOffset === 0\n      ) {\n        // Triple click chrome bug.\n        var finalTextNode = sel.startContainer.parentElement;\n        while(finalTextNode && finalTextNode.nodeType !== 3) {\n          var candidateChild = finalTextNode.childNodes[finalTextNode.childNodes.length - 1];\n          while(candidateChild && candidateChild.textContent === \"\") {\n            candidateChild = candidateChild.previousSibling;\n          } // We select the last child that contains some text, until we reach the text node.\n          finalTextNode = candidateChild;\n        }\n        if(finalTextNode) { // finalTextNode.nodeType === 3\n          var range = document.createRange();\n          range.setStart(sel.startContainer, sel.startOffset);\n          range.setEnd(finalTextNode, finalTextNode.textContent.length);\n          clearTextSelection();\n          window.getSelection().addRange(range)        \n        }\n      }\n    }\n    \n    document.addEventListener(\"selectionchange\", fixSelection);\n    \n    function clearTextSelection() {\n      var sel = window.getSelection();\n      if(!sel || !sel.rangeCount) return;\n      var selection = sel.getRangeAt(0);\n      if (window.getSelection) {\n        if (window.getSelection().empty) {  // Chrome\n          window.getSelection().empty();\n        } else if (window.getSelection().removeAllRanges) {  // Firefox\n          window.getSelection().removeAllRanges();\n        }\n      } else if (document.selection) {  // IE?\n        document.selection.empty();\n      }\n      return selection;\n    }\n    \n    function pasteHtmlAtCaret(html) {\n      var sel, range;\n      if (window.getSelection) {\n          // IE9 and non-IE\n          sel = window.getSelection();\n          // do not paste html into modify menu\n          if (sel.anchorNode.offsetParent && sel.anchorNode.offsetParent.id === \"modify-menu\") {\n            return;\n          }\n          if (sel.getRangeAt && sel.rangeCount) {\n              range = sel.getRangeAt(0);\n              range.deleteContents();\n              // Range.createContextualFragment() would be useful here but is\n              // only relatively recently standardized and is not supported in\n              // some browsers (IE9, for one)\n              var div = document.createElement(\"div\");\n              div.innerHTML = html;\n              var frag = document.createDocumentFragment(), node, lastNode;\n              while ( (node = div.firstChild) ) {\n                  lastNode = frag.appendChild(node);\n              }\n              range.insertNode(frag);\n              // Preserve the selection\n              if (lastNode) {\n                  range = range.cloneRange();\n                  range.setStartAfter(lastNode);\n                  range.collapse(true);\n                  sel.removeAllRanges();\n                  sel.addRange(range);\n              }\n          }\n      } else if (document.selection && document.selection.type != \"Control\") {\n          // IE < 9\n          document.selection.createRange().pasteHTML(html);\n      }\n    }\n    \n    function handleFileSelect(evt) {\n      evt.stopPropagation();\n      evt.preventDefault();\n      var files = evt.dataTransfer.files; // FileList object\n      uploadFilesAtCursor(files);\n    }\n    \n    function uploadFilesAtCursor(files) { \n      // files is a FileList of File objects. List some properties.\n      for (var i = 0, file; file = files[i]; i++) {\n        var targetPathName =  editor.getStorageFolder(file) + file.name;\n        // if(file.size < 30000000)\n        editor.uploadFile(targetPathName, file, (targetPathName, file) => {\n          if(file.type.indexOf(\"image\") == 0) {\n            pasteHtmlAtCaret(`<img src=\"${targetPathName}\" alt=\"${file.name}\">`);\n          } else {\n            pasteHtmlAtCaret(`<a href=\"${path}\">${path}</a>`); \n          }\n        });\n      }\n    }\n    function handleDragOver(evt) {\n      evt.stopPropagation();\n      evt.preventDefault();\n      evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.\n    }\n    if(typeof varedit == \"boolean\" && varedit || typeof varedit != \"boolean\") {\n      var dropZone = document.body;\n      dropZone.addEventListener('dragover', handleDragOver, false);\n      dropZone.addEventListener('drop', handleFileSelect, false);\n    \n      var lastclick = 0;\n      // Shortcuts\n      document.onkeydown = function(e) {\n        var key = e.which || e.keyCode;\n        if (e.which == 83 && (e.ctrlKey || e.metaKey)) { // CTRL+S or CMD+S: Save\n          if(document.getElementById(\"savebutton\") && document.getElementById(\"savebutton\").onclick) {\n            document.getElementById(\"savebutton\").onclick();\n          }\n          e.preventDefault();\n        }\n        if(e.which == 75 && (e.ctrlKey || e.metaKey)) { // CTRL+K: Insert link\n          if(new Date().valueOf() - lastclick > 100) {\n            document.execCommand('createLink', false, 'http://');\n            e.preventDefault();\n            var s = getSelection();\n            s = s ? s.anchorNode : s;\n            s = s ? s.parentNode : s;\n            lastclick = new Date().valueOf();\n            onClickGlobal({target: s, modify: true});\n          }\n          // Open link.\n        }\n        if(e.which == 90 && (e.ctrlKey || e.metaKey)) {\n          e.preventDefault();\n          if(!undo()) sendNotification(\"Nothing to undo!\");\n        }\n        if(e.which == 89 && (e.ctrlKey || e.metaKey)) {\n          e.preventDefault();\n          if(!redo()) sendNotification(\"Nothing to redo!\");\n        }\n        //in link select mode, escape on the keyboard can be\n        //used to exit the link select mode (same as escape button)\n        if(editor_model.linkSelectMode) {\n          if(e.which == 27) {\n            escapeLinkMode();\n          }\n        }\n      };\n      \n      var bodyeditable = document.querySelector(\"body[contenteditable]\");\n      var onKeypress = e => {\n        if(e.keyCode==13 && !e.shiftKey){ // [Enter] key\n            // If we are inside a paragraph, we split the paragraph.\n            // If we are directly inside a div, we add a paragraph separator.\n            // We delete everything between anchorNode and focusNode\n            // TODO: Handle ul and li\n            var caretSelection = document.getSelection();\n            var x = caretSelection.anchorNode;\n            if(x && x.nodeType == 3 && caretSelection.rangeCount) { // text node\n              if(x.parentNode && getComputedStyle(x.parentNode).display == \"block\") {\n                e.preventDefault(); //Prevent default browser\n                var range = caretSelection.getRangeAt(0);\n                range.deleteContents();\n                caretSelection = document.getSelection();\n                x = caretSelection.anchorNode;\n                if(x.parentNode.tagName == \"p\") { // Split the p\n                  var newPar = document.createElement(\"p\");\n                  \n                  var fo = caretSelection.anchorOffset;\n                  if(fo < x.text.length) {\n                    newPar.append(document.createTextNode(x.text.substring(fo)));\n                    x.deleteData(fo,x.text.length - fo);\n                  }\n                  var y = x.nextSibling;\n                  while(y) {\n                    var yy = y;\n                    y = y.nextSibling;\n                    newPar.append(yy); // Moves yy\n                  }\n                  x.parentNode.insertAdjacentElement(\"afterend\", newPar);\n                } else { // insert br\n                  range.insertNode(document.createElement(\"br\"))\n                }\n              }\n            }\n        }\n      }\n      if(bodyeditable && !bodyeditable.configured) {\n        bodyeditable.configured = true;\n        bodyeditable.addEventListener(\"keypress\", onKeypress, true);\n      }\n    }\n    \n    var observeTargetA = null;\n    \n    var addEditEqualToUrl = function(href, what) {\n      if(href.indexOf(\"://\") == -1) { // Instrument the relative link so that it is edit=true\n        if(href.indexOf(\"?\") >= 0) {\n          if(href.endsWith(\"?\")) {\n            href = href + \"edit=\" + what\n          } else {\n            href = href + \"&edit=\" + what\n          }\n        } else {\n          href = href + \"?edit=\" + what\n        }\n      }\n      return href;\n    }\n    \n    // Prevent mouse down on modify-menu that end outside modify-menu to trigger onclick\n    var onMouseDownGlobal = function(event) {\n      var tmp = event.target;\n      while(tmp) {\n        if(tmp.getAttribute && tmp.getAttribute(\"id\") == \"modify-menu\") {\n          editor_model.dismissNextClick = true;\n          return;\n        }\n        tmp = tmp.parentElement;\n      }\n    }    \n    var onClickGlobal = function (event) {\n      if(editor_model.dismissNextClick) {\n\t      editor_model.dismissNextClick = false;\n\t      return;\n      }\n      \n      var clickedElem = event.target;\n      console.log(typeof event.target);\n      var editorSelectOptions = document.querySelectorAll(\"meta[editor-noselect],meta[editor-doselect]\");\n      var matchOptions = function(clickedElem) {\n        var result = true;\n        for(let i = 0; i < editorSelectOptions.length; i++) {\n          let negativeSelector = editorSelectOptions[i].getAttribute(\"editor-noselect\"),\n              positiveSelector = editorSelectOptions[i].getAttribute(\"editor-doselect\");\n          if(result && negativeSelector) {\n            result = !editor.matches(clickedElem, negativeSelector);\n          }\n          if(!result && positiveSelector) {\n            result = editor.matches(clickedElem, positiveSelector);\n          }\n        }\n        return result;\n      }\n      while(clickedElem && editorSelectOptions && !matchOptions(clickedElem)) {\n        clickedElem = clickedElem.parentElement;\n      }\n      var ancestors = [];\n      var tmp = clickedElem;\n      var aElement;\n      var ancestorIsModifyBox = false;\n      var ancestorIsContextMenu = false;\n      var link = undefined;\n      while(tmp) {\n        ancestors.push(tmp);\n        if(tmp.getAttribute && tmp.getAttribute(\"id\") == \"modify-menu\") {\n          ancestorIsModifyBox = true;\n        }\n        if(tmp.getAttribute && tmp.getAttribute(\"id\") == \"context-menu\") {\n          ancestorIsContextMenu = true;\n        }\n        if(!aElement && tmp.tagName === \"A\") { // First link.\n          aElement = tmp;\n          link = aElement.getAttribute(\"href\");\n        }\n        tmp = tmp.parentElement;\n      }\n      document.querySelectorAll(\"[ghost-hovered=true]\").forEach(e => e.removeAttribute(\"ghost-hovered\"));\n      if(ancestorIsModifyBox || ancestorIsContextMenu || ancestors[ancestors.length - 1].tagName != \"HTML\") return;\n      //console.log(\"not modify box\", ancestors)\n      document.querySelector(\"#context-menu\").classList.remove(\"visible\");\n      \n      editor_model.clickedElem = clickedElem;\n      editor_model.link = link;\n      editor_model.link_href_source = aElement; // So that we can modify it\n      editor_model.insertElement = false;\n      editor_model.notextselection = false;\n      updateInteractionDiv();\n      // Check if the event.target matches some selector, and do things...\n    } //end of onClickGlobal\n\n    var parentUpSVG = svgFromPath(\"M 20,5 20,25 M 15,10 20,5 25,10\");\n    var editorContainerArrowDown = svgFromPath(\"M 10,17 13,14 17,18 17,4 23,4 23,18 27,14 30,17 20,27 Z\", true, 30, 20, [0, 0, 40, 30]);\n    var editorContainerArrowUp = svgFromPath(\"M 10,14 13,17 17,13 17,27 23,27 23,13 27,17 30,14 20,4 Z\", true, 30, 20, [0, 0, 40, 30]);\n    var arrowDown = svgFromPath(\"M 10,17 13,14 17,18 17,4 23,4 23,18 27,14 30,17 20,27 Z\", true);\n    var arrowRight = svgFromPath(\"M 21,25 18,22 22,18 8,18 8,12 22,12 18,8 21,5 31,15 Z\", true);\n    var arrowUp = svgFromPath(\"M 10,14 13,17 17,13 17,27 23,27 23,13 27,17 30,14 20,4 Z\", true);\n    var arrowLeft = svgFromPath(\"M 19,25 22,22 18,18 32,18 32,12 18,12 22,8 19,5 9,15 Z\", true);\n    var cloneSVG = svgFromPath(\"M 19,8 31,8 31,26 19,26 Z M 11,4 23,4 23,8 19,8 19,22 11,22 Z\");\n    var saveSVG = svgFromPath(\"M 10,5 10,25 30,25 30,9 26,5 13,5 Z M 13,6 25,6 25,12 13,12 Z M 22,7 22,11 24,11 24,7 Z M 13,15 27,15 27,24 13,24 Z M 11,23 12,23 12,24 11,24 Z M 28,23 29,23 29,24 28,24 Z\", true);\n    var openLeftSVG = svgFromPath(\"M 27.5,4 22.5,4 12.5,15 22.5,25 27.5,25 17.5,15 Z\", true);\n    var closeRightSVG = svgFromPath(\"M 12.5,4 17.5,4 27.5,15 17.5,25 12.5,25 22.5,15 Z\", true);\n    var openTopSVG = svgFromPath(\"M 9.5,22 9.5,17 20.5,7 30.5,17 30.5,22 20.5,12 Z\", true);\n    var displayArrowSVG = svgFromPath(\"M 9.5,22 9.5,17 20.5,7 30.5,17 30.5,22 20.5,12 Z\", true, 30, 20, [0, 0, 40, 30]);\n    var closeBottomSVG = svgFromPath(\"M 9.5,7 9.5,12 20.5,22 30.5,12 30.5,7 20.5,17 Z\", true);\n    var wasteBasketSVG = svgFromPath(\"m 24,11.5 0,11 m -4,-11 0,11 m -4,-11 0,11 M 17,7 c 0,-4.5 6,-4.5 6,0 m -11,0.5 0,14 c 0,3 1,4 3,4 l 10,0 c 2,0 3,-1 3,-3.5 L 28,8 M 9,7.5 l 22,0\");\n    var plusSVG = svgFromPath(\"M 18,5 22,5 22,13 30,13 30,17 22,17 22,25 18,25 18,17 10,17 10,13 18,13 Z\", true);\n    var liveLinkSVG = link => `<a class=\"livelink\" href=\"javascript:if(nothingToLose()) { navigateLocal(relativeToAbsolute('${link}')) }\">${svgFromPath(\"M 23,10 21,12 10,12 10,23 25,23 25,18 27,16 27,24 26,25 9,25 8,24 8,11 9,10 Z M 21,5 33,5 33,17 31,19 31,9 21,19 19,17 29,7 19,7 Z\", true)}</a>`;\n    var gearSVG = svgFromPath(\"M 17.88,2.979 14.84,3.938 15.28,7.588 13.52,9.063 10,8 8.529,10.83 11.42,13.1 11.22,15.38 7.979,17.12 8.938,20.16 12.59,19.72 14.06,21.48 13,25 15.83,26.47 18.1,23.58 20.38,23.78 22.12,27.02 25.16,26.06 24.72,22.41 26.48,20.94 30,22 31.47,19.17 28.58,16.9 28.78,14.62 32.02,12.88 31.06,9.84 27.41,10.28 25.94,8.52 27,5 24.17,3.529 21.9,6.42 19.62,6.219 17.88,2.979 Z M 20,11 A 4,4 0 0 1 24,15 4,4 0 0 1 20,19 4,4 0 0 1 16,15 4,4 0 0 1 20,11 Z\", true);\n    var folderSVG = svgFromPath(\"M 8,3 5,6 5,26 10,10 32,10 32,6 18,6 15,3 8,3 Z M 5,26 10,10 37,10 32,26 Z\");\n    var reloadSVG = svgFromPath(\"M 32.5,8.625 30.25,15.25 24.75,11.125 M 6.75,20 9.875,14.5 15.125,19 M 29.5,18 C 28.25,22.125 24.375,25 20,25 14.5,25 10,20.5 10,15 M 10.5,12 C 11.75,7.875 15.625,5 20,5 25.5,5 30,9.5 30,15\");\n    var logSVG = svgFromPath(\"M 17.24,16 A 1.24,2 0 0 1 16,18 1.24,2 0 0 1 14.76,16 1.24,2 0 0 1 16,14 1.24,2 0 0 1 17.24,16 Z M 20,16 21.24,16 21.24,16 A 1.24,2 0 0 1 20,18 1.24,2 0 0 1 18.76,16 1.24,2 0 0 1 20,14 1.33,2.16 0 0 1 21,15 M 12,14 12,18 14,18 M 10,12 23,12 23,20 10,20 Z M 23,6 23,11 28,11 M 14,6 14,12 10,12 10,20 14,20 14,25 28,25 28,11 23,6 14,6 Z\");\n    var sourceSVG = svgFromPath(\"M 22.215125,2 25,3 18.01572,27 15,26 Z M 12,19 12,25 2,14 12,4 12,9 7,14 Z M 28,9 28,4 38,15 28,25 28,20 33,15 Z\", true);\n    var isAbsolute = url => url.match(/^https?:\\/\\/|^www\\.|^\\/\\//);\n    var linkToEdit = link => link && !isAbsolute(link) ? link.match(/\\?/) ? link + \"&edit\" : link + \"?edit\" : link;\n    var undoSVG = svgFromPath(\"M 9.5,12.625 11.75,19.25 17.25,15.125 M 31.5,16 C 30.25,11.875 26.375,9 22,9 16.5,9 12,13.5 12,19\");\n    var redoSVG = svgFromPath(\"M 31.5,12.625 29.25,19.25 23.75,15.125 M 9.5,16 C 10.75,11.875 14.625,9 19,9 24.5,9 29,13.5 29,19\");\n\n    var isDraftSVG = svgFromPath(\"M 2,7 2,25 38,25 38,7 M 36,6 C 32,6 29.1,3.9 26.1,3.9 23.1,3.9 22,5 20,6 L 20,23 C 22,22 23.1,20.9 26.1,20.9 29.1,20.9 32,22.9 36,22.9 Z M 4,6 C 8,6 10.9,3.9 13.9,3.9 16.9,3.9 18,5 20,6 L 20,23 C 18,22 16.9,20.9 13.9,20.9 10.9,20.9 8,22.9 4,22.9 Z\");\n    var escapeSVG = svgFromPath(\"M 7.5 4 L 17.5 15 L 7.5 25 L 12.5 25 L 20 17.5 L 27.5 25 L 32.5 25 L 22.5 15 L 32.5 4 L 27.5 4 L 20 12.25 L 12.5 4 L 7.5 4 z\", true);\n    var linkModeSVG = svgFromPath(\"M 14,3 14,23 19,19 22,27 25,26 22,18 28,18 Z\");\n    var checkSVG = svgFromPath(\"M 10,13 13,13 18,21 30,3 33,3 18,26 Z\", true);\n    var ifAlreadyRunning = typeof editor_model === \"object\";\n    if (!ifAlreadyRunning) {\n      var thaditor_files = [\n        \"Thaditor\", \"Makefile\", \"ThaditorPackager.py\", \"ThaditorInstaller.py\", \"ThaditorInstaller.php\",\n        \"ThaditorInstaller.htaccess\", \"composer.json\", \"composer.lock\", \"credentials.json\", \"cacert.pem\", \"versions\",\n        \"vendor\", \"ssg\", \"cache\"\n      ];\n      \n    }\n    if (isLive == undefined) {\n      var isLive = () => !(path.includes(\"Thaditor/versions/\"));\n    }\n\n    var verz = \"Live\";\n    if (!isLive()) {\n      verz = path.slice(path.lastIndexOf(\"versions/\")+9, path.lastIndexOf(\"/\"));\n    }\n    //hover mode functions for linkSelectMode\n    function escapeLinkMode() {\n      document.body.removeEventListener('mouseover', linkModeHover1, false);\n      document.body.removeEventListener('mouseout', linkModeHover2, false);\n      //removing the hovered element (which is retained if the escape key is hit)\n      document.querySelectorAll(\"[ghost-hovered=true]\").forEach(e => e.removeAttribute(\"ghost-hovered\"));\n      //editor_model.clickedElem = editor_model.linkFrom;\n      editor_model.visible = false;\n      editor_model.linkSelectMode = false;\n      editor_model.linkSelectCallback = undefined;\n      editor_model.linkSelectOtherMenus = undefined;\n      updateInteractionDiv();\n    }\n    function noGhostHover (node) {\n      curClass = node.getAttribute(\"class\")\n      if(curClass === \"modify-menu-icon-label-link\" ||\n        curClass === \"context-menu-icon\" ||\n        curClass === \"context-menu-icon fill\") {\n          return false;\n        }\n      else if(node.tagName === \"path\" || node.tagName === \"PATH\") {\n        return false;\n      }\n      return true;\n    }\n    function linkModeHover1(event) {\n      //console.log(event.target);\n      //console.log(event.target.tagName);\n      //console.log(event.target.getAttribute(\"class\"));\n      if(noGhostHover(event.target)) { \n        event.target.setAttribute(\"ghost-hovered\", true);\n        updateInteractionDiv();\n        //console.log(\"hey!\");\n      }\n    }\n    function linkModeHover2(event) {\n      if(noGhostHover(event.target)) {\n        event.target.removeAttribute(\"ghost-hovered\");\n        updateInteractionDiv();\n      }\n    }\n\n    function dataToRecoverElement(oldNode) {\n      if(!oldNode) return undefined;\n      if(oldNode.nodeType == 1 && oldNode.getAttribute(\"id\") && document.getElementById(oldNode.getAttribute(\"id\"))) {\n        return {id: oldNode.getAttribute(\"id\")};\n      }\n      let tentativeSelector = [];\n      let t = oldNode;\n      let isText = false, textIndex = 0;\n      while(t && t.parentNode) {\n        let index = Array.prototype.slice.call( t.parentNode.children ).indexOf(t);\n        if(t.nodeType === 1) {\n          tentativeSelector.unshift(t.tagName + \":nth-child(\" + (index + 1) + \")\" );\n        } else {\n          isText = true;\n          textIndex = Array.prototype.slice.call( t.parentNode.childNodes ).indexOf(t);\n        }\n        t = t.parentNode;\n      }\n      return {tentativeSelector: tentativeSelector, isText: isText, textIndex: textIndex};\n    }\n    \n    // Returns the new node that matches the old node the closest.\n    // For text nodes, try to recover the text node, if not, returns the parent node;\n    function recoverElementFromData(data) {\n      if(!data) return undefined;\n      if(typeof data === \"object\" && data.id) {\n        return document.getElementById(data.id);\n      }\n      if(typeof data == \"object\" && Array.isArray(data.tentativeSelector)) {\n        let tentativeSelector = data.tentativeSelector;\n        while(tentativeSelector.length >= 1) {\n          let newNode = document.querySelector(tentativeSelector.join(\" \"));\n          if(newNode) {\n            return data.isText && newNode.childNodes && newNode.childNodes[data.textIndex] || newNode;\n          }\n          tentativeSelector.shift();\n        }\n        return undefined;\n      }\n    }\n    function setCaretPositionIn(node, position) {\n      position = Math.min(position, node.textContent.length);\n      if (node.nodeType == 3) {\n        let sel  = window.getSelection()\n        setTimeout( () => sel.collapse(node, position), 0);\n      } else {\n        let p = position\n        let n = node.firstChild\n        while(n != null && p > n.textContent.length) {\n          p = p - n.textContent.length\n          n = n.nextSibling\n        }\n        if(n != null) {\n          setCaretPositionIn(n, p)\n        } else {\n          console.log(\"Could not find position. Reached node and position \", [n, p])\n        }\n      }\n    }\n    function dataToRecoverCaretPosition(caretPosition) {\n      if(!caretPosition) return undefined;\n      return {target: editor.toTreasureMap(caretPosition.startContainer), startOffset: caretPosition.startOffset};\n    }\n    function recoverCaretPositionFromData(data) {\n      if(!data) return;\n      let newTextNodeOrParent = editor.fromTreasureMap(data.target);\n      if(newTextNodeOrParent) setCaretPositionIn(newTextNodeOrParent, data.startOffset)\n    }\n    function dataToRecoverSelectionRange(selectionRange) { // TODO\n      if(!selectionRange) return undefined;\n      return undefined;\n    }\n    function recoverSelectionRangeFromData(data) { // TODO\n      if(!data) return;\n      return undefined;\n    }\n    function nothingToLose() {\n      if(editor_canSave()) {\n        var x = confirm(\"There are unsaved modifications. Do you want to discard them?\");\n        if(x) {\n          editor_model.undoStack = [];\n          editor_model.redoStack = [];\n          return true;\n        } else {\n          return false;\n        }\n      }\n      editor_model.undoStack = [];\n      editor_model.redoStack = [];\n      return true;\n    }\n    //(outer lastEditScript)\n    /*\n    State is currently (8/12) being kept track of in many variables. I'm setting out to condense that\n    into one variable, \"state\", a string describing the current state of the system. \n    For the sake of clarity, I will list the current variables within the editor_model that are used to keep track of state\n\n      visible :v\n      advanced :a\n      show_log :s\n      insertElement :i //(not defined in our inital editor_model object)\n      linkSelectMode :l\n      isDraftSwitcherVisible :d\n    */\n    var editor_model = { // Change this and call updateInteractionDiv() to get something consistent.\n      visible: ifAlreadyRunning ? editor_model.visible : false, //here\n      clickedElem: ifAlreadyRunning ? editor.fromTreasureMap(editor_model.clickedElem) : undefined,\n      displayClickedElemAsMainElem: true, // Dom selector status switch signal\n      previousVisitedElem: [], // stack<DOM node> which helps showing previous selected child in the dom selector\n      notextselection: false, // When using the relative DOM selector, set to true to avoid considering the caret (e.g. for insertions and deletions)\n      savedTextSelection: undefined, // Text range to restore when the edition bar closes, on mobile\n      selectionRange: ifAlreadyRunning ? recoverSelectionRangeFromData(editor_model.selectionRange) : undefined,\n      caretPosition: ifAlreadyRunning ? recoverCaretPositionFromData(editor_model.caretPosition) : undefined,\n      link: undefined,\n      disambiguationMenu: undefined, //here\n      isSaving: false,\n      undosBeforeSave: ifAlreadyRunning ? editor_model.undosBeforeSave : 0,\n      //data structures to represent undo/redo \"stack\"\n      undoStack: ifAlreadyRunning ? editor_model.undoStack : [],\n      redoStack: ifAlreadyRunning ? editor_model.redoStack : [],\n      actionsDuringSave: ifAlreadyRunning ? editor_model.actionsDuringSave : [],\n      isDraftSwitcherVisible : ifAlreadyRunning ? editor_model.isDraftSwitcherVisible : false,\n      //observer to listen for muts\n      outputObserver: ifAlreadyRunning ? editor_model.outputObserver : undefined,\n      //worker for interface with the server\n      serverWorker: ifAlreadyRunning ? editor_model.serverWorker :\n                    apache_server ?\n                      typeof thaditor_worker != \"undefined\" ? thaditor_worker : new Worker(\"/Thaditor/editor.js\") :\n                      undefined,\n      send_notif:ifAlreadyRunning ? editor_model.send_notif : \"\",\n      //editor log\n      editor_log: ifAlreadyRunning ? editor_model.editor_log : [],\n      show_log: ifAlreadyRunning ? editor_model.show_log : false, //here\n      linkSelectMode: false, //here\n      linkSelectCallback: undefined, // Callback that is going to be called with the selected node.\n      idNum: ifAlreadyRunning ? editor_model.idNum : 1,\n      //new attribute to keep menu state after reload\n      textareaPropertiesSaved: ifAlreadyRunning ? editor_model.textareaPropertiesSaved : [],\n      askQuestions: ifAlreadyRunning ? editor_model.askQuestions : askQuestions,\n      autosave: ifAlreadyRunning ? editor_model.autosave : autosave,\n      path: path,\n      version : verz,\n      interfaces: ifAlreadyRunning ? editor_model.interfaces : [],\n      disambiguationMenu: ifAlreadyRunning ? editor_model.disambiguationMenu : undefined\n    }\n    \n    if (!ifAlreadyRunning && editor_model.serverWorker) {\n      editor_model.serverWorker.onmessage = function(e) {\n        //handle confirmDone\n        if (e.data.action == \"confirmDone\") {\n          console.log(\"confirmDone\", e.data);\n          let xmlhttp = new XHRequest();\n          xmlhttp.response.setHeader(\"New-Local-URL\", e.data.newLocalURL);\n          xmlhttp.response.setHeader(\"New-Query\", e.data.newQueryStr);\n          xmlhttp.response.setHeader(\"Ambiguity-Key\", e.data.ambiguityKey);\n          xmlhttp.response.setHeader(\"Ambiguity-Number\", e.data.ambiguityNumber);\n          xmlhttp.response.setHeader(\"Ambiguity-Selected\", e.data.ambiguitySelected);\n          xmlhttp.response.setHeader(\"Ambiguity-End\", e.data.ambiguityEnd);\n          xmlhttp.response.setHeader(\"Ambiguity-Summaries\", e.data.ambiguitySummaries);\n          xmlhttp.response.setHeader(\"Operations-Summary\", e.data.opSummaryEncoded);\n          xmlhttp.customRequestHeaders = e.data.customRequestHeaders;\n          xmlhttp.response.text = e.data.text;\n          /*\n            We want to undo everything in the undo stack that has been done since the save began.\n            In the process of vanilla undoing this (using mark's function), the items will be\n            pushed onto the redoStack in the normal way, s.t. we can redo them in a moment.\n            Once we're at the state we were at when we began to save, we re-write the page\n            with the confirmed content that the worker gave us.\n            Once the confirmed content has been rewritten, we have undo/redo stacks that point,\n            as the undo/redo stacks are an array of array of MutationRecords, all of whose target\n            has just been erased and replaced with a new object. \n            So we need to convert the old UR stacks to be pointing to the right objects.\n            We solve this in the undo()/redo() functions, by checking to see if the object\n            pointed to in the mutationrecord is still connected to the active DOM. if not,\n            we use the inactive node to record the path up the tree, and search for the\n            corresponding node in the newly active tree, replacing the MR.target with the active one.\n            Once we have the UR stacks set up, we just need to vanilla undo/redo to get back to\n            the state pre-update & post-save.\n          */\n          // TODO: In case of ambiguity, only replay undo/redo after ambiguity has been resolved.\n          const ads = editor_model.actionsDuringSave;\n          const adsLen = editor_model.actionsDuringSave.length;\n          ads.forEach((action) => {\n            if (action == \"undo\") {\n              undo();\n            } else if (action == \"redo\") {\n              redo();\n            } else {\n              throw new Error(\"Unidentified action in restoring post-save state post-save\");\n            }\n          });\n          \n          editor_model.outputObserver.disconnect();\n          xmlhttp.onreadystatechange = handleServerPOSTResponse(xmlhttp, () => {});\n          xmlhttp.readyState = XMLHttpRequest.DONE;\n          xmlhttp.onreadystatechange();\n          var replayActionsAfterSave = msg => function(msgOverride) {\n            console.log(\"replaying actions after save\");\n            const newAds = editor_model.actionsDuringSave;\n            const newAdsLen = newAds.length;\n            for (let i = 0; i < adsLen; i++) {\n              if (newAds[i] == \"undo\") {\n                undo();\n              } else if (newAds[i] == \"redo\") {\n                redo();\n              } else {\n                throw new Error(\"unidentified action in actionsduringsave\");\n              }\n            }\n            if(newAdsLen) {\n              updateInteractionDiv();\n            }\n            if(msg) {\n              setTimeout(() => {\n                 sendNotification(newAdsLen === 0 || !msgOverride ? msg : msgOverride);\n              }, 0);\n            }\n          }\n          let what = e.data.what ? e.data.what + \" completed.\" : undefined;\n          if(!e.data.isAmbiguous || !editor_model.disambiguationMenu) {\n            replayActionsAfterSave(what)();\n          } else {\n            editor_model.disambiguationMenu.replayActionsAfterSave = replayActionsAfterSave(what);\n          }\n        } else if(e.data.action == \"message\") {\n          sendNotification(e.data.message)\n        } else if(e.data.action == \"reconnect\") {\n          thaditor_reconnect();\n        } else if (e.data.action == \"delete_complete\") {\n          //todo\n          updateInteractionDiv();\n          sendNotification(\"Permanently deleted draft named: \" + e.data.nm);\n        } else if (e.data.action == \"publish_complete\") {\n          //just send a notif, no more naving to live\n          sendNotification(\"Successfully published \" + e.data.nm + \" to live.\");\n        } else if (e.data.action == \"clone_complete\") {\n          //just send a notif, no more naving to the clone\n          updateInteractionDiv();\n          sendNotification(\"Successfully cloned \" + e.data.nm + \" to \" + e.data.draft_name);\n        } else if (e.data.action == \"rename_complete\") {\n          let marker = false;\n          if (e.data.nm == e.data.version) {\n            navigateLocal(\"/Thaditor/versions/\" + e.data.draft_name + \"/?edit\");\n            marker = true;\n          }\n          updateInteractionDiv();\n          if (marker) {\n            setTimeout(sendNotification(\"Successfully renamed \" + e.data.nm + \" to \" + e.data.draft_name), 2000)\n          } else {\n            sendNotification(\"Successfully renamed \" + e.data.nm + \" to \" + e.data.draft_name);\n          }\n        }\n      }\n    }\n    \n    // Helpers: Text preview and summary\n    function textPreview(element, maxLength) {\n      let x = element.textContent;\n      let result = \"'\" + x + \"'\";;\n      if(x == \"\") {\n        if(element.tagName === \"META\") {\n          result = element.getAttribute(\"charset\") ? \"charset:\" + element.getAttribute(\"charset\")  :\n                  (element.getAttribute(\"name\") || element.getAttribute(\"http-equiv\") || \"(name?)\") + \": \" + (element.getAttribute(\"content\") || \"(content?)\");\n        } else if(element.tagName === \"SCRIPT\" || element.tagName === \"IMG\") {\n          result = typeof element.getAttribute(\"src\") === \"string\" ? (element.getAttribute(\"src\") || \"(src?)\").replace(/(https?:\\/\\/)?(www\\.)?/, \"\") : \"empty script\";\n        } else if(element.tagName === \"LINK\") {\n          result = typeof element.getAttribute(\"href\") === \"string\" ? (element.getAttribute(\"href\") || \"(src?)\").replace(/(https?:\\/\\/)?(www\\.)?/, \"\") : \"empty script\";\n        }\n      }\n      if(typeof maxLength !== \"undefined\" && result.length > maxLength) {\n        return result.substring(0, maxLength) + \"...'\";\n      }\n      return result;\n    }\n    function summary(element, idAndClasses, maxLength) {\n      var summary = element.tagName.toLowerCase();\n      if(idAndClasses && element.getAttribute(\"id\")) {\n        summary += \"#\" + element.getAttribute(\"id\");\n      }\n      var elemClass = element.getAttribute(\"class\");\n      if(idAndClasses && elemClass && elemClass.trim().length) {\n        summary += \".\" + elemClass.split(/\\s+/g).join(\".\");\n      }\n      summary += \" \" + textPreview(element);\n      maxLength = maxLength || 80;\n      summary = summary.substring(0, maxLength || 80) + (summary.length > 80 ? \"...\" : \"\");\n      return summary;\n    }\n    \n    function getTempCSSName(CSSFilePath) {\n      let newFilePath = CSSFilePath.split(\"/\");\n      let newFileName = `tmp-${userName}-${newFilePath[newFilePath.length - 1]}`;\n      newFilePath[newFilePath.length - 1] = newFileName;\n      newFilePath = newFilePath.join(\"/\");\n      return newFilePath;\n    }\n    \n    function editor_stopWatching() {\n      editor_model.outputObserver.disconnect();\n    }\n    \n    function editor_resumeWatching() {\n      editor_model.outputObserver.observe\n        ( document.body.parentElement\n        , { attributes: true\n          , childList: true\n          , characterData: true\n          , attributeOldValue: true\n          , characterDataOldValue: true\n          , subtree: true\n          });\n    }\n    \n    // newValue can be a function, in which it should be applied on the current content.\n    // Returns the old value.\n    async function assignTmpCss(linkNode, newValue, notUndoable) {\n      if(!notUndoable) { // We send this to undo.\n        editor_stopWatching();\n        let oldValue = await assignTmpCss(linkNode, newValue, true);\n        let m = {type: \"linkHrefCSS\", target: linkNode, oldValue: oldValue, newValue: newValue};\n        sendToUndo(m);\n        syncUndoRedoButtons();\n        editor_resumeWatching();\n        return;\n      }\n      // Here the change should not take care of doing the undo/redo part. \n      let ghostHref = linkNode.getAttribute(\"ghost-href\");\n      let hasGhostHref = typeof ghostHref === \"string\";\n      let oldHref = hasGhostHref ? ghostHref : linkNode.getAttribute(\"href\")\n      let CSSFilePath = relativeToAbsolute(removeTimestamp(oldHref));\n      let currentContent = typeof linkNode.cachedContent === \"string\" ? linkNode.cachedContent :\n                               (await getServer(\"read\", CSSFilePath)).slice(1);\n      if(typeof linkNode.cachedContent !== \"string\") {\n        linkNode.cachedContent = currentContent;\n      }\n      if(hasGhostHref) { // Proxied\n        console.log(\"Was proxied\");\n        let tmpCachedContent = typeof linkNode.tmpCachedContent == \"string\" ? linkNode.tmpCachedContent :\n                               (await getServer(\"read\", linkNode.getAttribute(\"href\"))).slice(1);\n        if(typeof newValue === \"function\") {\n          newValue = newValue(tmpCachedContent);\n        }\n        if(currentContent === newValue) { // We can remove the proxy\n          if(!notUndoable) {\n            editor_model.outputObserver.disconnect();\n          }\n          let CSSTmpFilePath = linkNode.getAttribute(\"href\");\n          await postServer(\"unlink\", removeTimestamp(CSSTmpFilePath));\n          linkNode.setAttribute(\"href\", oldHref);\n          linkNode.removeAttribute(\"ghost-href\");\n          linkNode.tmpCachedContent = newValue;\n        } else { // We keep the proxy, just update the href\n          let CSSTmpFilePath = linkNode.getAttribute(\"href\");\n          await postServer(\"write\", removeTimestamp(CSSTmpFilePath), newValue);\n          linkNode.setAttribute(\"href\", setTimestamp(CSSTmpFilePath));\n          linkNode.tmpCachedContent = newValue;\n        }\n        return tmpCachedContent;\n      } else {// Unproxied\n        console.log(\"Was not proxied\")\n        if(typeof newValue === \"function\") {\n          newValue = newValue(currentContent);\n        }\n        if(currentContent !== newValue) { // Create the proxy file\n          console.log(\"Value updated\")\n          //add dummy counter, force reload\n          linkNode.setAttribute(\"ghost-href\", oldHref);\n          let CSSTmpFilePath = getTempCSSName(CSSFilePath);\n          await postServer(\"write\", CSSTmpFilePath, newValue);\n          linkNode.setAttribute(\"href\", setTimestamp(CSSTmpFilePath));\n          linkNode.tmpCachedContent = newValue;\n        } // else nothing to change, leave unproxied.\n        return currentContent;\n      }\n    }\n         \n    function init_interfaces() {\n      function findText(parsed, startIndex, endIndex) { //for css + img replacement\n        let textSegment = \"\";\n        for(let i = startIndex; i < endIndex; i++) {\n          textSegment += parsed ? parsed[0].selector ? CSSparser.unparseCSS([parsed[i]]) :\n            (parsed[0].directive ? CSSparser.unparseRules([parsed[i]]) : \"\") : \"\";\n          //console.log(textSegment);\n        }\n        return textSegment;\n      }\n      let linkSelect = function() {\n        activateNodeSelectionMode(\"to link to\",\n          (linkFrom => linkTo => {\n            let targetID = linkTo.getAttribute(\"id\");\n            if(!targetID) {\n              targetID = \"ID\" + editor_model.idNum\n              linkTo.setAttribute(\"id\", targetID);\n              editor_model.idNum += 1;\n            }\n            else if(targetID.length > 100) {\n              targetID = targetID.trim();\n              linkTo.setAttribute(\"id\", targetID);\n            }\n            linkFrom.setAttribute(\"href\", \"#\" + targetID);\n          })(editor_model.clickedElem)\n        );\n      }\n      var CSSparser = new losslesscssjs();\n      let createButton = function(innerHTML, attributes, properties) {\n        let button = el(\"div\", attributes, [], properties);\n        button.onmousedown = button.onmousedown ? button.onmousedown : preventTextDeselection;\n        button.classList.add(\"modify-menu-button\");\n        button.innerHTML = innerHTML;\n        return button;\n      } //you can append a createbutton to the element returning in render\n      let add_btn_to_div = (div, innerHTML, attributes, properties) => {\n        div.append(createButton(innerHTML, attributes, properties));\n      };\n      if(!(EDITOR_VERSION & 1)) {\n        if(typeof simple_editor_interface !== \"undefined\") {\n          editor_model.interfaces.push(simple_editor_interface);\n        }\n        return;\n      }\n      if(typeof simple_editor_interface !== \"undefined\" && EDITOR_VERSION & 16) {\n        editor_model.interfaces.push(simple_editor_interface);\n      }\n      editor_model.interfaces.push({\n        title: \"Selected Element Tree\",\n        minimized: true,\n        priority(editor_model) {\n          return undefined;\n        },\n        enabled(editor_model) {\n          return editor_model.clickedElem;\n        },\n        render: function render(editor_model, innerBox) {\n          let domSelector = el(\"div.dom-selector.noselect\"); // create dom selector interface\n          const clickedElem = editor_model.clickedElem;\n          if (!clickedElem) return \"Click on an element to view its location in DOM tree\";\n          domSelector.classList.add(\"dom-selector-style\");\n          let mainElemDiv = el(\"div.mainElem\");\n          let childrenElemDiv = el(\"div.childrenElem\");\n          domSelector.append(\n            mainElemDiv, childrenElemDiv\n          );\n          let displayMainElem = function(elem) {\n            mainElemDiv.append(\n              el(\"div\", {\"class\":\"mainElemName\", \"type\":\"text\", value: elem.tagName.toLowerCase()}, \"<\" + elem.tagName.toLowerCase() + \">\", {\n                onmouseenter: (c => () => { c.setAttribute(\"ghost-hovered\", \"true\") })(elem),\n                onmouseleave: (c => () => { c.removeAttribute(\"ghost-hovered\") })(elem)\n              }),\n              el(\"div\", {\"class\": \"mainElemInfo\"}, textPreview(elem, 50))\n            );\n          }\n          let displayChildrenElem = function(elem) {\n            childrenElemDiv.append(\n              el(\"div\", {\n                  \"class\": \"childrenSelector\" + (elem.matches(\".editor-interface\") ? \" editor-interface-dom-selector\" : \"\") +\n                    (isGhostNode(elem) ? \" editor-recorded-ghost-node\" : \"\"),\n                  title: elem.matches(\".editor-interface\") ? \"This is part of Editor\" : (isGhostNode(elem) ? \"(temporary) \" : \"\") + textPreview(elem, 20)\n                  },\n                [\n                  el(\"div\", {\"class\": \"childrenSelectorName\"}, \"<\" + elem.tagName.toLowerCase() + \">\", {}),\n                  // el(\"div\", {\"class\": \"childrenSelectorInfo\"}, textPreview(elem, 20))\n                ], \n                {\n                  onmouseenter: (c => () => { c.setAttribute(\"ghost-hovered\", \"true\") })(elem),\n                  onmouseleave: (c => () => { c.removeAttribute(\"ghost-hovered\") })(elem)\n                }\n              )\n            );\n          }\n          // show attributes of element on the dom selector\n          let displayElemAttr = function(targetDiv, elem) {\n            for (let i = 0; elem && elem.attributes && i < elem.attributes.length; i++) {\n              let name = elem.attributes[i].name;\n              let value = elem.attributes[i].value;\n              if (name === \"ghost-clicked\" || name === \"ghost-hovered\") continue;\n              targetDiv.append(\n                el(\"div\", { \"class\": \"elementAttr\" },\n                  [\n                    el(\"span\", { title: \"This element has attribute name '\" + name + \"'\" }, name + \": \"),\n                    el(\"span\", { title: \"This element has attribute value '\" + value + \"'\" }, value)\n                  ]\n                )\n              );\n            }\n          }\n          // display children and siblings in the second part of selector\n          console.log (\"rendering DOM naver\");\n          let displayChildrenSiblings = function(middleChild, selectMiddleChild) {\n            // display clicked element's previous sibling, clicked element, clicked element's next sibling\n            let cnt = 0;\n            // display previous sibling\n            if (middleChild.previousElementSibling && \n                (middleChild.previousElementSibling.id !== \"context-menu\" || middleChild.previousElementSibling.id !== \"modify-menu\" || middleChild.previousElementSibling.id !== \"editbox\")) {\n              displayChildrenElem(middleChild.previousElementSibling);\n              let qs = childrenElemDiv.querySelectorAll(\".childrenElem > .childrenSelector\");\n              console.log ({qs});\n              qs[cnt].onclick = function () {\n                let c = middleChild.previousElementSibling;\n                if ((c.tagName && c.tagName === \"HTML\") || !c.tagName) {\n                  return;\n                }\n                // still in status 2, but clicked element change to previous sibling\n                editor_model.displayClickedElemAsMainElem = false;\n                editor_model.previousVisitedElem = []; // clear the stack\n                editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\n                editor_model.clickedElem = c;\n                editor_model.notextselection = true;\n                if(onMobile()) editor_model.savedTextSelection = clearTextSelection();\n                updateInteractionDiv();\n              }\n            } else {\n              childrenElemDiv.append(\n                el(\"div\", {\"class\": \"childrenSelector no-sibling\"}, \"no sibling\")\n              );\n            }\n            cnt++;\n            // display certain child in the middle\n            displayChildrenElem(middleChild);\n            childrenElemDiv.querySelectorAll(\".childrenElem > .childrenSelector\")[cnt].onclick = function () {\n              let c = middleChild;\n              if (!c.tagName) {\n                return;\n              }\n\n              if (!c.hasChildNodes() || (clickedElem.childNodes.length == 1 && clickedElem.childNodes[0].nodeType === 3)) {\n                // still in status 2\n                editor_model.displayClickedElemAsMainElem = false;\n              } else {\n                // switch to status 1\n                editor_model.displayClickedElemAsMainElem = true;\n              }\n              editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\n              editor_model.clickedElem = c;\n              editor_model.notextselection = true;\n              if(onMobile()) editor_model.savedTextSelection = clearTextSelection();\n              updateInteractionDiv();\n            }\n            if (selectMiddleChild) {\n              childrenElemDiv.querySelectorAll(\".childrenElem > .childrenSelector\")[cnt].classList.add(\"selectedDom\");\n            }\n            cnt++;\n            // display next sibling\n            if (middleChild.nextElementSibling && \n              (middleChild.nextElementSibling.id !== \"context-menu\" || middleChild.nextElementSibling.id !== \"modify-menu\" || middleChild.nextElementSibling.id !== \"editbox\")) {\n              displayChildrenElem(middleChild.nextElementSibling);\n              childrenElemDiv.querySelectorAll(\".childrenElem > .childrenSelector\")[cnt].onclick = function () {\n                let c = middleChild.nextElementSibling;\n                if ((c.tagName && c.tagName === \"HTML\") || !c.tagName) {\n                  return;\n                }\n                // still in status 2, but clicked element change to next sibling\n                editor_model.displayClickedElemAsMainElem = false;\n                editor_model.previousVisitedElem = []; // clear the stack\n                editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\n                editor_model.clickedElem = c;\n                editor_model.notextselection = true;\n                if(onMobile()) editor_model.savedTextSelection = clearTextSelection();\n                updateInteractionDiv();\n              }\n            } else {\n              childrenElemDiv.append(\n                el(\"div\", {\"class\": \"childrenSelector no-sibling\"}, \"no sibling\")\n              );\n            }\n          }\n          // editor itself should be invisible\n          if (clickedElem.id !== \"context-menu\" || clickedElem.id !== \"modify-menu\" || clickedElem.id !== \"editbox\") {\n            if (!clickedElem.hasChildNodes() || (clickedElem.childNodes.length == 1 && clickedElem.childNodes[0].nodeType === 3)) {\n              editor_model.displayClickedElemAsMainElem = false;\n            }\n            // status 1. display clicked element in main part\n            if (editor_model.displayClickedElemAsMainElem) {\n              displayMainElem(clickedElem);\n              domSelector.classList.add(\"selectedDom\");\n              mainElemDiv.onclick = function () {\n                if (!clickedElem.tagName) {\n                  return;\n                }\n                // When the main element in selector is clicked, selector switch to status 2 so that user can see its parent element\n                editor_model.displayClickedElemAsMainElem = false;\n                editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\n                editor_model.clickedElem = clickedElem;\n                editor_model.notextselection = true;\n                if(onMobile()) editor_model.savedTextSelection = clearTextSelection();\n                updateInteractionDiv();\n              }\n              displayElemAttr(mainElemDiv, clickedElem);\n              // display children, if no previous selected child, display first 3 children elements in second part of selector\n              if (editor_model.previousVisitedElem.length < 2 ||\n                  (editor_model.previousVisitedElem[editor_model.previousVisitedElem.length - 1] != clickedElem)) {\n                if (editor_model.previousVisitedElem.length !== 0) {\n                  editor_model.previousVisitedElem = [];\n                }\n                if (clickedElem.children.length > 0) {\n                  // only display first 3 children elements\n                  let childrenElem = clickedElem.children;\n                  for (let i = 0, cnt = 0; i < childrenElem.length && cnt < 3; ++i) {\n                    // prevent displaying editor itself\n                    if (cnt === 0 && (childrenElem[i].matches(\".editor-interface\") || isGhostNode(childrenElem[i]))) {\n                      continue;\n                    }\n                    displayChildrenElem(childrenElem[i]);\n                    let qs = childrenElemDiv.querySelectorAll(\".childrenElem > .childrenSelector\");\n                    console.log ({qs});\n                    qs[cnt].onclick = function () {\n                      let c = childrenElem[i];\n                      if (!c.tagName) {\n                        return;\n                      }\n                      if (!c.hasChildNodes() || (clickedElem.childNodes.length == 1 && clickedElem.childNodes[0].nodeType === 3)) {\n                        editor_model.displayClickedElemAsMainElem = false;\n                      } else {\n                        // still in status 1\n                        editor_model.displayClickedElemAsMainElem = true;\n                      }\n                      editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\n                      editor_model.clickedElem = c;\n                      editor_model.notextselection = true;\n                      updateInteractionDiv();\n                    }\n                    cnt++;\n                  }\n                }\n                // else: bottom of DOM tree\n              } else {\n                editor_model.previousVisitedElem.pop();\n                let middleChild = editor_model.previousVisitedElem[editor_model.previousVisitedElem.length - 1];\n                displayChildrenSiblings(middleChild, false);\n              }\n            } else {\n              // status 2. display clicked element's parent element in main part\n              // <html> has no parent element\n              if(clickedElem.parentElement) {\n                displayMainElem(clickedElem.parentElement);\n                mainElemDiv.onclick = function () {\n                  if (!clickedElem.parentElement.tagName) {\n                    return;\n                  }\n                  // still in status 2 while current clicked element's parent element becomes clicked element so that user can see grandparent element\n                  editor_model.displayClickedElemAsMainElem = false;\n                  // memoization. when user click parent element:\n                  if (editor_model.previousVisitedElem.length === 0) {\n                    editor_model.previousVisitedElem.push(clickedElem);\n                    editor_model.previousVisitedElem.push(clickedElem.parentElement);\n                  } else {\n                    if (editor_model.previousVisitedElem[editor_model.previousVisitedElem.length - 1] == clickedElem) {\n                      editor_model.previousVisitedElem.push(clickedElem.parentElement);   // continuous storing path\n                    } else {\n                      editor_model.previousVisitedElem = []; // clear the stack\n                    }\n                  }\n                  editor_model.clickedElem.removeAttribute(\"ghost-hovered\");\n                  editor_model.clickedElem = clickedElem.parentElement;\n                  editor_model.notextselection = true;\n                  if(onMobile()) editor_model.savedTextSelection = clearTextSelection();\n                  updateInteractionDiv();\n                }\n                displayElemAttr(mainElemDiv, clickedElem.parentElement);\n              } else {\n                // for <html>\n                displayMainElem(clickedElem);\n                displayElemAttr(mainElemDiv, clickedElem);\n              } \n              displayChildrenSiblings(clickedElem, true);\n            }\n          }\n          return domSelector;\n        }\n      });\n      editor_model.interfaces.push({\n        title: \"Attributes\",\n        minimized: true,\n        priority(editor_model) {\n          return undefined;\n        },\n        enabled(editor_model) {\n          return editor_model.clickedElem;\n        },\n        render: function render(editor_model, innerBox) {\n          let keyvalues = el(\"div\", {\"class\":\"keyvalues\"});\n          const clickedElem = editor_model.clickedElem;\n          if (!clickedElem) return \"Click on an element to see its attributes\";\n          // modify tagname\n          keyvalues.append(\n            el(\"div\", {\"class\": \"keyvalue\"}, [\n              el(\"span\", {title: \"This element has tag name '\" + clickedElem.tagName.toLowerCase() + \"'\"}, \"Tag: \"),\n              el(\"span\", {class:\"attribute-key-value\"}, [\n                el(\"input\", {\"type\": \"text\", value: clickedElem.tagName.toLowerCase(), \"id\": \"newTagName\"}, \n                  [], {\n                    oninput() {\n                      let applyNewTagNameButton = document.querySelector(\"#applyNewTagName\");\n                      applyNewTagNameButton.classList.toggle(\"visible\", this.value !== this.getAttribute(\"value\") && this.value.match(/^\\w*$/));\n                      applyNewTagNameButton.value = this.value === \"\" ? \"-\" : \"Set\";\n                      applyNewTagNameButton.setAttribute(\"title\", this.value === \"\" ? \"Lift element's children and delete element\" :  \"Change tag name to '\"+this.value+\"'\");\n                    }\n                  }),\n                  el(\"input\", {\"type\": \"button\", id: \"applyNewTagName\", value: \"Set\", title: \"Apply new tag name\"}, [], {onclick() {\n                        let newTagName = document.querySelector(\"#newTagName\").value;\n                        let newel;\n                        if(newTagName === \"\") {\n                          while(clickedElem.childNodes.length) {\n                            newel = clickedElem.childNodes[0];\n                            clickedElem.parentElement.insertBefore(newel, clickedElem);\n                          }\n                          clickedElem.remove();\n                        } else {\n                          newel = el(document.querySelector(\"#newTagName\").value);\n                          let elements = clickedElem.childNodes;\n                          while(elements.length) {\n                            newel.append(elements[0]);\n                          }\n                          for(let i = 0; i < clickedElem.attributes.length; i++) {\n                            newel.setAttribute(clickedElem.attributes[i].name, clickedElem.attributes[i].value);\n                          }\n                          clickedElem.parentElement.insertBefore(newel, clickedElem);\n                          clickedElem.remove();\n                        }\n                        editor_model.clickedElem = newel;\n                        updateInteractionDiv();\n                      }\n                    }\n                  ),\n                  el(\"div\", {id:\"newtagname-align-placeholder\"}, \" \")\n                ]\n              )\n            ])\n          );\n          let isGhostAttributeKey = isSpecificGhostAttributeKeyFromNode(clickedElem);\n          let isIgnoredAttributeKey = isIgnoredAttributeKeyFromNode(clickedElem);\n\n          for(let i = 0; clickedElem.attributes && i < clickedElem.attributes.length; i++) {\n            let name = clickedElem.attributes[i].name;\n            if(name === \"ghost-clicked\" || name === \"ghost-hovered\") continue;\n            let value = clickedElem.attributes[i].value;\n            // Inline styles incoporated into CSS display editor\n            if(name !== \"style\") {\n              let isGhost = isGhostAttributeKey(name);\n              let isIgnored = isIgnoredAttributeKey(name);\n              let isHref = name === \"href\" && clickedElem.tagName === \"A\";\n              keyvalues.append(\n                el(\"div\", {\"class\": \"keyvalue\" + (isGhost ? \" editor-recorded-ghost-attribute\" : \"\")\n                                              + (isIgnored ? \" editor-ignored-attribute\" : \"\"),\n                          \"title\": isGhost ? \"Key/value generated by a script\" : isIgnored ? \"key/value ignored after being modified by a script\" : undefined\n                }, [\n                  el(\"span\", {title: \"Element attribute name\"}, name + \": \"),\n                  el(\"span\", {class: \"attribute-key-value\", title: \"Element attribute value of \" + name}, [\n                    el(\"input\", {\"type\": \"text\", value: value, \"id\": (\"dom-attr-\" + name)}, [], {\n                        oninput: ((name, isHref) => function () {\n                            clickedElem.setAttribute(name, this.value);\n                            if(isHref) {\n                              let livelinks = document.querySelectorAll(\".livelink\");\n                              for(let livelink of livelinks) {\n                                let finalLink = livelink.matches(\"#context-menu *\") ?\n                                  `javascript:if(nothingToLose()) { navigateLocal(relativeToAbsolute('${linkToEdit(this.value)}')) }` : this.value;\n                                livelink.setAttribute(\"href\", finalLink);\n                                livelink.setAttribute(\"title\", \"Go to \" + this.value);\n                              }\n                            }\n                        })(name, isHref)\n                      }),\n                    isHref ? el(\"div\", {title: \"Go to \" + value, \"class\": \"modify-menu-icon inert\"}, [], {\n                      innerHTML: liveLinkSVG(value)\n                    }) : undefined,\n                    isHref ? el(\"div\", {title: \"Select a node on the page to refer to\", \"class\": \"modify-menu-icon inert\"}, [], { \n                      innerHTML: linkModeSVG,\n                      onclick: linkSelect\n                    }) : undefined,\n                    el(\"div\", {\"class\":\"modify-menu-icon\", title: \"Delete attribute '\" + name + \"'\"}, [], {\n                      innerHTML: wasteBasketSVG,\n                      onclick: ((name) => function() {\n                        clickedElem.removeAttribute(name);\n                        editor_model.clickedElem = clickedElem;\n                        updateInteractionDiv();\n                        })(name)\n                      })\n                    ]\n                  )\n                ]\n              ));\n            }\n            else {\n              for(let i in editor_model.interfaces) {\n                if(editor_model.interfaces[i].title === \"Style\") {\n                  editor_model.interfaces[i].minimized = false;\n                  editor_model.inline = clickedElem.getAttribute(\"style\");                  \n                  editor_model.interfaces[i].priority(editor_model);               \n                }\n              }\n            }\n          }\n          let highlightsubmit = function() {\n            let attrName = this.parentElement.parentElement.querySelector(\"[name=name]\").value;\n            this.parentElement.parentElement.querySelector(\"div.modify-menu-icon\").disabled =\n              attrName === \"\" || attrName.trim() !== attrName\n          }\n\n          if(clickedElem.nodeType === 1) {\n            keyvalues.append(\n              el(\"div\", {\"class\": \"keyvalue keyvalueadder\"}, [\n                el(\"span\", {class: \"attribute-key\"}, el(\"input\", {\"type\": \"text\", placeholder: \"key\", value: \"\", name: \"name\"}, [], {oninput: highlightsubmit})),\n                el(\"span\", {class: \"attribute-key-value\"}, [\n                  el(\"span\", {}, el(\"input\", {\"type\": \"text\", placeholder: \"value\", value: \"\", name: \"value\"}, [], {\n                    onfocus: function() {\n                      let keyInput = document.querySelector(\"div.keyvalueadder input[name=name]\");\n                      if(keyInput && keyInput.value != \"\") {\n                        let name = document.querySelector(\"div.keyvalueadder input[name=name]\").value;\n                        clickedElem.setAttribute(\n                          name,\n                          document.querySelector(\"div.keyvalueadder input[name=value]\").value\n                        );\n                        updateInteractionDiv();\n                        let d =  document.querySelector(\"div.keyvalue input#dom-attr-\" + name);\n                        if(d) d.focus();\n                      }\n                    },\n                    oninput: highlightsubmit})),\n                  el(\"div\", {\"class\":\"modify-menu-icon\", title: \"Add this name/value attribute\"}, [], {innerHTML: plusSVG,\n                    disabled: true,\n                    onclick() {\n                      clickedElem.setAttribute(\n                        this.parentElement.querySelector(\"[name=name]\").value,\n                        this.parentElement.querySelector(\"[name=value]\").value\n                      );\n                      updateInteractionDiv();\n                    },\n                    oninput: highlightsubmit })])\n              ])\n            );\n          }\n          return keyvalues;\n        }\n      });\n      \n      editor_model.interfaces.push({\n        title: \"Style\",\n        minimized: true,\n        priority(editor_model) {\n          if(editor_model.inline) return 1;\n          return undefined;\n        },\n        enabled(editor_model) {\n          return editor_model.clickedElem;\n        },\n        render: function render(editor_model, innerBox) {\n          const clickedElem = editor_model.clickedElem;\n          if(!clickedElem) {\n            return \"Click on an element to see its style\";\n          }\n          const do_css = (clickedElem && clickedElem.id !== \"context-menu\" && clickedElem.id !== \"modify-menu\" && clickedElem.id !== \"editbox\" &&\n                          !editor_model.insertElement);\n          let CSSarea = el(\"div\", {id: \"CSS-modification\", value: \"\"}, [], {}); \n          if (!do_css) return CSSarea;\n          //parse relevant CSS, recording prior and post CSS text as well \n\n          async function fullParseCSS() {\n            var fullCSS = [], keyframes = [], rawCSS = [];\n            //console.log(\"All style tags:\", document.querySelectorAll(\"style\"));\n            let CSSstyles = document.querySelectorAll(\"link[rel=stylesheet], style\");\n            for(let i in CSSstyles) {\n              let linkOrStyleNode = CSSstyles[i];\n              if(linkOrStyleNode.tagName === \"LINK\" && linkOrStyleNode.getAttribute(\"rel\") === \"stylesheet\" &&\n                 linkOrStyleNode.getAttribute(\"href\") && !linkOrStyleNode.getAttribute(\"isghost\")) {\n                let CSSFilePath = relativeToAbsolute(removeTimestamp(linkOrStyleNode.getAttribute(\"href\")));\n                if(!(linkOrStyleNode.className && linkOrStyleNode.className === \"editor-interface\") && (CSSFilePath.indexOf(\"http\") < 0)) {\n                  let CSSvalue = typeof linkOrStyleNode.tmpCachedContent === \"string\" ?\n                        linkOrStyleNode.tmpCachedContent :\n                        (await getServer(\"read\", CSSFilePath)).slice(1);\n                  rawCSS.push({text: CSSvalue, tag: linkOrStyleNode});\n                }\n              }\n              else if(linkOrStyleNode.tagName === \"STYLE\" && !linkOrStyleNode.getAttribute(\"isghost\")) {\n                rawCSS.push({text: linkOrStyleNode.textContent, tag: linkOrStyleNode});\n              }\n            }\n            for(let z in rawCSS) {  \n              var parsedCSS = CSSparser.parseCSS(rawCSS[z].text);\n              for(let i in parsedCSS) {\n                if(parsedCSS[i].kind === 'cssBlock' && editor.matches(clickedElem, parsedCSS[i].selector.replace(/:(?=(:?after|:?before|:?hover))[^,]*(?=,|$)/g, \"\"))) {\n                  let content = CSSparser.unparseCSS([parsedCSS[i]]);\n                  let wsBefore = content.replace(/^(\\s*\\n|)[\\s\\S]*$/g, (m, ws) => ws);\n                  let contentTrimmed = content.replace(/\\s*\\n/,\"\");\n                  //calculating before and after text\n                  fullCSS.push({type: 'cssBlock', content: contentTrimmed, \n                    before: findText(parsedCSS, 0, Number(i)) + wsBefore, after: findText(parsedCSS, Number(i) + 1, parsedCSS.length), orgTag: rawCSS[z].tag});\n                }\n                else if(parsedCSS[i].kind === '@@media' && window.matchMedia(parsedCSS[i].atNameValue).matches) {\n                  let curMedia = parsedCSS[i];\n                  for(let j in curMedia.content) {\n                    if(curMedia.content[j].kind === 'cssBlock' && editor.matches(clickedElem, curMedia.content[j].selector.replace(/:(?=(:?after|:?before|:?hover))[^,]*(?=,|$)/g, \"\"))) {\n                      var insertMedia = {type: '@@media', content: CSSparser.unparseCSS([curMedia.content[j]]), \n                        mediaSelector: curMedia.wsBefore + curMedia.selector + curMedia.wsBeforeAtNameValue + curMedia.atNameValue + curMedia.wsBeforeOpeningBrace + \"{\",\n                        innerBefore: findText(curMedia.content, 0, j), innerAfter: findText(curMedia.content, Number(j) + 1, curMedia.content.length),\n                        before: findText(parsedCSS, 0, Number(i)), after: findText(parsedCSS, Number(i) + 1, parsedCSS.length), orgTag: rawCSS[z].tag, bracketAfter: curMedia.wsBeforeClosingBrace + \"}\"};\n                      //console.log(\"Insert media:\");\n                      //console.log(insertMedia);\n                      fullCSS.push(insertMedia);\n                      //console.log(\"got here first!\");\n                    }\n                  }\n                }\n                else if(parsedCSS[i].kind === '@@charset') {\n                  if(!(parsedCSS[i].wsBefore === \"\" && parsedCSS[i].wsBeforeAndSemicolon === \";\" && parsedCSS[i].wsBeforeValue === \" \"\n                    && parsedCSS[i].value.startsWith(\"\\\"\") && parsedCSS[i].value.endsWith(\"\\\"\"))) {\n                    sendNotification(\"CSS @@charset declaration is invalid due to extraneous white space.\");\t\n                  }\n                  if(editor_model.clickedElem.tagName != \"STYLE\" && editor_model.clickedElem.tagName != \"LINK\") {\n                    fullCSS.push({type: '@@charset', content: CSSparser.unparseCSS([parsedCSS[i]]), \n                      before: findText(parsedCSS, 0, i), after: findText(parsedCSS, Number(i) + 1, parsedCSS.length), orgTag: rawCSS[z].tag});\n                  }\n                }\n                else if(parsedCSS[i].kind === '@@keyframes') {\n                  keyframes.push({type: '@@keyframes', content: CSSparser.unparseCSS([parsedCSS[i]]), \n                    before: findText(parsedCSS, 0, Number(i)), after: findText(parsedCSS, Number(i) + 1, parsedCSS.length), orgTag: rawCSS[z].tag,\n                    animationName: parsedCSS[i].atNameValue});\n                }\n                else if(parsedCSS[i].kind === 'whitespace') { \n                  continue;\n                }\n                if(i === parsedCSS.length - 1 && !fullCSS.length) {\n                  console.log(\"Nothing relevant in style tag: \", rawCSS[z].tag);\n                }\n              }\n              //console.log(\"The parsed text looks like:\", curCSS);\n            }\n            for(i in keyframes) {\n              for(j in fullCSS) {\n                let parsedSection = CSSparser.parseCSS(fullCSS[j].content);\n                for(k in parsedSection.content) {\n                  for(l in parsedSection.content[k].rules) {\n                    if(Number(parsedSection.content[k].rules[l].search(keyframes[i].animationName)) >= 0) {\n                      fullCSS.push(keyframes[i]);\n                    }\n                  }\n                }\n                for(k in parsedSection.rules) {\n                  if(Number(parsedSection.rules[k].search(keyframes[i].animationName)) >= 0) {\n                    fullCSS.push(keyframes[i]);\n                  }\n                }\n              }\n            }\n            //console.log(fullCSS);\n            return fullCSS;\n          } // fullParseCSS\n          \n          function fullUnparseCSS(curCSS) {\n            let curTag = curCSS.orgTag;\n            let CSSString = \"\";\n            if(curCSS.type === 'cssBlock' || curCSS.type === \"@@charset\") {\n              //console.log(curCSS.content);\n              CSSString = curCSS.before + curCSS.content + curCSS.after;\n              //console.log(CSSString);\n            }\n            else if(curCSS.type === '@@media') { \n              console.log(curCSS);\n              CSSString = curCSS.before + curCSS.mediaSelector + curCSS.innerBefore + curCSS.content + curCSS.innerAfter + curCSS.bracketAfter + curCSS.after;   \n            }\n            if(curTag.tagName === \"LINK\") {\n              return CSSString;\n            }\n            // Style elements\n            //console.log(\"Text is:\" + CSSString);\n            curTag.textContent = CSSString;\n            //debugger\n            //consolw.log(\"After\");\n          } // fullUnparseCSS\n          var curCSSWindow = undefined;\n\n          function setCSSAreas() {\n            //console.log(CSSarea.firstChild);\n            while(CSSarea.firstChild) {\n              console.log(\"Removed child:\", CSSarea.firstChild);\n              CSSarea.removeChild(CSSarea.firstChild);\n            }\n            //if there is linked CSS text\n            if(clickedElem.tagName === \"LINK\" && clickedElem.getAttribute(\"rel\") === \"stylesheet\" && clickedElem.getAttribute(\"href\")) {\n              let oldHref = clickedElem.getAttribute(\"href\"); // Even if it's a temporary href\n              let CSSFilePath = relativeToAbsolute(oldHref);\n              let CSSvalue = doReadServer(\"read\", CSSFilePath).slice(1);\n              CSSarea.append(el(\"div\", {\"class\": \"CSS-chain\"}, [], {innerHTML: \"STYLE TEXT:\"}));\n              CSSarea.append(\n                el(\"div\", {\"class\": \"CSS-modify-unit\"}, [\n                  el(\"textarea\", {\"class\": \"linked-CSS\"}, [], {\n                    value: CSSvalue,\n                    onfocusout() {\n                      setCSSAreas();\n                    },\n                    oninput() {\n                      (async () => { // Maybe create a new temporary CSS file.\n                        await assignTmpCss(clickedElem, this.value);\n                      })();\n                    }\n                  })\n                ])\n              );\n            }\n            //inline styles \n            editor_model.inline = clickedElem.getAttribute(\"style\"); //? CSSparser.parseCSS(clickedElement.getAttribute(\"style\")) : undefined;\n            if(editor_model.inline) {\n              console.log(\"We have inline CSS!\");\n              let inlineCSS = el(\"div\", {\"class\": \"CSS-modify-unit\"}, [\n                el(\"textarea\", {\"class\": \"inline-CSS\"}, [], {\n                  value: editor_model.inline,\n                  onfocusout() {\n                    setCSSAreas();\n                  },\n                  oninput() {\n                    clickedElem.setAttribute(\"style\", this.value);\n                  }\n                }),\n                el(\"div\", {\"class\": \"CSS-buttons\"}, [\n                  el(\"div\", {\"class\": \"CSS-action-button\"}, [], {\n                    innerHTML: cloneSVG,\n                    onclick() {\n                      let stylesLinks = document.querySelectorAll(\"style, link[rel=stylesheet]\");\n                      let i = stylesLinks.length - 1;\n                      let lastStyleLink = stylesLinks[i];\n                      while(i >= 0 && lastStyleLink.matches(\".editor-interface, .editor-interface *\")) {\n                        i--;\n                        lastStyleLink = stylesLinks[i];\n                      }\n                      if(lastStyleLink && (lastStyleLink.isghost || lastStyleLink.tagName === \"LINK\" && lastStyleLink.tagName.indexOf(\"http\") >= 0)) {\n                        lastStyleLink = undefined;\n                      }\n                      console.log(\"Closest CSS source:\", lastStyleLink);\n                      let inline_CSS = document.querySelectorAll(\".inline-CSS\");\n                      console.log(\"Finding inline CSS textarea:\", inline_CSS);  \n                      let postIndentCSS = \"\";\n                      let preIndentCSS = inline_CSS[0].value.split(\"\\n\");\n                      for(let i = 0; i < preIndentCSS.length; i++) {\n                        if(i !== preIndentCSS.length-1) {\n                          postIndentCSS += \"  \" + preIndentCSS[i] + \"\\n\";\n                        }\n                        else {\n                          postIndentCSS += \"  \" + preIndentCSS[i]; \n                        }\n                      }\n                      let curSelector = getShortestUniqueSelector(clickedElem);\n                      postIndentCSS = \"\\n\" + curSelector + \" {\\n\" + postIndentCSS + \"\\n}\";   \n                      console.log(\"lastStyleLink is:\", lastStyleLink);     \n                      if(lastStyleLink) {\n                        if(lastStyleLink.tagName === \"LINK\") {\n                          (async () => {\n                            await assignTmpCss(lastStyleLink, oldValue => oldValue + postIndentCSS);\n                            clickedElem.removeAttribute(\"style\");\n                            setCSSAreas();\n                          })();\n                        }\n                        else { // lastStyleLink is a <style>\n                          let curValue = lastStyleLink.textContent;\n                          lastStyleLink.textContent = curValue + postIndentCSS;\n                          clickedElem.removeAttribute(\"style\");\n                          setCSSAreas();\n                        }\n                      }\n                      else {\n                        //just default to style node for now\n                        document.body.appendChild(el(\"style.inserted-CSS\", {}, postIndentCSS));\n                        clickedElem.removeAttribute(\"style\");\n                        setCSSAreas();\n                      }\n                    }\n                  }),\n                  el(\"div\", {\"class\": \"CSS-action-button\"}, [], {\n                    innerHTML: wasteBasketSVG,\n                    onclick() {\n                      let inline_CSS = document.querySelectorAll(\".inline-CSS\");\n                      inline_CSS.value = \"\";\n                      clickedElem.setAttribute(\"style\", inline_CSS.value);\n                      setCSSAreas();\n                    }\n                  })\n                ])\n              ]);\n              CSSarea.append(el(\"div\", {\"class\": \"CSS-chain\"}, [], {innerHTML: \"Inline styles:\"}));\n              CSSarea.append(inlineCSS);\n            } // inline style present\n            else{\n              CSSarea.append(el(\"button.action-button#add-inline-style\", {}, [], {\n                innerHTML: \"Add inline style\",\n                onclick() {\n                  clickedElem.setAttribute(\"style\", \" \");\n                  updateInteractionDiv();\n                }}));\n            }\n            (async () => {\n            //rest of CSS\n            editor_model.CSSState = await fullParseCSS();\n            //console.log(\"CSS state is:\", editor_model.CSSState);\n            const count = (str) => {\n              const re = /\\n/g\n              return ((str || '').match(re) || []).length\n            }\n            for(let i in editor_model.CSSState) {\n              let cssState = editor_model.CSSState[i];\n              let orgTag = cssState.orgTag;\n              //console.log(\"cssState\", cssState);\n              let headerStr = orgTag.tagName.toLowerCase() + (orgTag.tagName === \"LINK\" ? \" (\" + removeTimestamp(orgTag.getAttribute(\"ghost-href\") || orgTag.getAttribute(\"href\"))+\":\" + (count(cssState.before) + 1) + \")\" : \"\");\n              for(let curElem = orgTag.parentElement; curElem; curElem = curElem.parentElement) {\n                headerStr =  curElem.tagName.toLowerCase() + \" > \" + headerStr; \n              }\n              CSSarea.append(el(\"div\", {\"class\": \"CSS-chain\"}, [], {\n                innerHTML: headerStr,\n                onclick: () => {\n                  editor_model.clickedElem = orgTag;\n                  updateInteractionDiv();\n                }\n                }));\n              if(cssState.type === '@@media') {\n                CSSarea.append(el(\"div\", {\"class\": \"@media-selector\", \"contenteditable\": true}, [], {\n                oninput: (cssState => function() {\n                  (async () => {\n                    if(window.matchMedia(cssState.selector).matches ? editor.matches(clickedElem, cssState.content.selector) : false) {\n                      //implement throwError;\n                    }\n                    cssState.mediaSelector = this.value;\n                    if(cssState.orgTag.tagName != \"LINK\") {\n                      fullUnparseCSS(cssState);\n                    } else {\n                      await assignTmpCss(cssState.orgTag, fullUnparseCSS(cssState));\n                    }\n                  })();\n                })(cssState),\n                innerHTML: cssState.mediaSelector\n                }))\n              }\n              let eachCSS = el(\"div\", {\"class\": \"CSS-modify-unit\"}, [\n                el(\"textarea\", {\"class\": \"CSS-selectors\" }, [], {\n                  defaultValue: cssState.content,\n                  onfocusout() {\n                    if(this.storedCSS.orgTag.tagName != \"LINK\") {\n                      setCSSAreas();\n                    }\n                  },\n                  oninput: function() {\n                    console.log(\"oninput called\");\n                    (async () => {\n                      if(this.storedCSS.orgTag.tagName != \"LINK\") { // style node\n                        let throwError = false;\n                        curCSSState = CSSparser.parseCSS(this.value);\n                        //console.log(curCSSState);\n                        //check to make sure CSS is still relevant to clicked element.\n                        if(curCSSState[i].kind === 'cssBlock' && !editor.matches(clickedElem, curCSSState[i].selector)) {\n                          sendNotification(\"CSS selector does not match\");\n                          this.setAttribute(\"wrong-selector\", true);\n                          this.setAttribute(\"title\", \"The current CSS selector doesn't apply to the selected element!\");\n                        }\n                        else {\n                          this.setAttribute(\"wrong-selector\", false);\n                          this.removeAttribute(\"title\");\n                        }\n                        this.storedCSS.content = this.value;\n                        fullUnparseCSS(this.storedCSS);\n                        //setCSSAreas();\n                      }\n                      else { // Link\n                        this.storedCSS.content = this.value;\n                        await assignTmpCss(this.storedCSS.orgTag, fullUnparseCSS(this.storedCSS));\n                      }\n                    })();\n                  },\n                  storedCSS: cssState\n                }),\n                orgTag.tagName === \"LINK\" ?\n                  el(\"div\", {\"class\": \"CSS-action-button\", \"title\": \"Delete this snippet of CSS\"}, [], {\n                    innerHTML: wasteBasketSVG,\n                    onclick() {\n                      (async () => {\n                        let linked_CSS = this.parentElement.childNodes[0];\n                        linked_CSS.value = \"\";\n                        linked_CSS.storedCSS.content = linked_CSS.value;\n                        await assignTmpCss(linked_CSS.storedCSS.orgTag, fullUnparseCSS(linked_CSS.storedCSS));\n                        setCSSAreas();\n                      }) ();\n                    }\n                  }) : // inline style case\n                  el(\"div\", {\"class\": \"CSS-action-button\", \"title\": \"Delete this CSS snippet\"}, [], {\n                    innerHTML: wasteBasketSVG,\n                    onclick() {\n                      let linked_CSS = this.parentElement.childNodes[0];\n                      //console.log(this.parentElements.childNodes);\n                      linked_CSS.value = \"\";\n                      linked_CSS.storedCSS.content = linked_CSS.value;\n                      fullUnparseCSS(linked_CSS.storedCSS);\n                      setCSSAreas();\n                    }\n                  })\n              ]);\n              CSSarea.append(eachCSS);\n            }\n            })(); // Async css set.\n          } // function setCSSAreas()\n          setCSSAreas();   \n          return CSSarea;\n        }\n      });\n      editor_model.interfaces.push({\n        title: \"Image Tools\",\n        minimized: true,\n        priority(editor_model) {\n          return this.enabled(editor_model) ? 1 : undefined; // It's likely we want to modify this image above all.\n        },\n        findURLS(styleStr) {\n          var urls = [];\n          var diffPics = styleStr.split(\",\");\n          for(let k in diffPics) {\n            //extracts only url(...)\n            var matches = diffPics[k].match(/url\\((.*?)\\)/g);\n            console.log(\"the matches are:\", matches);\n            //deepcopy string\n            var remainStr = diffPics[k].slice(0); \n            for(let j in matches) {\n              //from current understanding, there should only be one url(...) per split of ,\n              console.log(\"the current match is:\", matches[j]);\n              if(j == 1) {\n                console.log(`Odd syntax, ${matches[j]} also matched!`);\n              }\n              let sIndex = diffPics[k].indexOf(matches[j]);\n              //extracting the rest of the string \n              afterStr = remainStr.slice(sIndex + matches[j].length);\n              beforeStr = remainStr.slice(0, sIndex);\n              urls.push({remainderBefore: beforeStr, url: matches[j], remainderAfter: afterStr});  \n            }\n          }\n          return urls;\n        },\n        //checks the inline CSS of the clicked node/element to see if background or background-image is a rule, and if \n        //a link to an image is provided as part of the value for this rule;\n        //TODO: expand the set of CSS being checked to any style tags as well.\n        checkForBackgroundImg(clickedElem, findURLS) {\n          //console.log(\"clicked element is:\", clickedElem);\n          //clickedElem ? console.log(clickedElem.getAttribute(\"style\")) : console.log(\"nothing clicked\");\n          var clickedStyle = clickedElem ? CSSparser.parseRules(clickedElem.getAttribute(\"style\")) : []; \n          //console.log(clickedStyle);\n          //inefficient way of doing things, but since background takes precedence over background-image, we need to process the \n          //former first, if it contains a url. for now, I am looping through the CSS rules twice.\n          //console.log(\"^parsed rules \");\n          for(let i in clickedStyle) {\n            for(let j in clickedStyle[i]) {\n              if(clickedStyle[i][j].directive === \"background\") {\n                clickedStyle[i][j].value = findURLS(clickedStyle[i][j].value);  \n                if(clickedStyle[i][j].value.length) {\n                  //console.log(clickedStyle[i][j]);\n                  return {beforeCSS: findText(clickedStyle[i], 0, Number(j)), relCSS: clickedStyle[i][j], \n                    imageSelection: 0, afterCSS: findText(clickedStyle[i], Number(j) + 1, clickedStyle[i].length)};\n                }\n              }\n            }\n          }\n          for(let i in clickedStyle) {\n            for(let j in clickedStyle[i]) {\n              if(clickedStyle[i][j].directive === \"background-image\") {\n                //console.log(\"hello?\");\n                //console.log(clickedStyle[i][j].value);\n                clickedStyle[i][j].value = findURLS(clickedStyle[i][j].value);  \n                if(clickedStyle[i][j].value.length) {\n                  return {beforeCSS: findText(clickedStyle[i], 0, Number(j)), relCSS: clickedStyle[i][j], \n                    imageSelection: 0, afterCSS: findText(clickedStyle[i], Number(j) + 1, clickedStyle[i].length)};\n                }\n              }\n            }\n          } \n          //console.log(\"unsuccessful\");\n          return undefined;\n        },\n        enabled(editor_model) {\n          let clickedElem = editor_model.clickedElem;\n          let backgroundImgSrc = this.checkForBackgroundImg(clickedElem, this.findURLS);\n          const do_img_rpl = (clickedElem && (clickedElem.tagName === \"IMG\" || backgroundImgSrc));\n          this.backgroundImgSrc = backgroundImgSrc;\n          return do_img_rpl;\n        },\n        \n        // enabled has been called before, clickedElem is not empty and it contains a background image\n        render: function render(editor_model, innerBox) {\n          if(!this.enabled(editor_model)) {\n            return \"Click an element with a background image.\";\n          }\n          //extract url and extraneous text from specified CSS value (which is originally part of a rule)\n          const clickedElem = editor_model.clickedElem;\n          let ret = el(\"div\", {\"class\": \"information\"});\n          if (!clickedElem) return ret;\n          let backgroundImgSrc = this.backgroundImgSrc;\n          //unparse the background/background-image object\n          function unparseBackgroundImg(backImgObj) {\n            var textSegment = \"\";\n            let valueText = \"\";\n            for(let i in backImgObj.relCSS.value) {\n              valueText += (Number(i) !== 0 ? \", \" : \"\") + backImgObj.relCSS.value[i].remainderBefore + backImgObj.relCSS.value[i].url + backImgObj.relCSS.value[i].remainderAfter;\n              //console.log(valueText);\n            }\n            backImgObj.relCSS.value = valueText;\n            //console.log(\"Object about to be unparsed:\");\n            //console.log(backImgObj);\n            return backImgObj.beforeCSS + findText([backImgObj.relCSS], 0, 1) + backImgObj.afterCSS;\n          }\n          function uploadImagesAtCursor(files, srcName, backImgObj) {\n            for (var i = 0, file; file = files[i]; i++) {\n              var targetPathName =  editor.getStorageFolder(file) + file.name;\n              editor.uploadFile(targetPathName, file, (targetPathName, file) => {\n                if(backImgObj) {\n                  backImgObj.imageSelection = (() => {\n                    let radios = document.querySelectorAll(\".background-img-radio\");\n                    let defaultValue = 0;\n                    for (let i in radios) {\n                      //hopefully there aren't more than 10 images!\n                      if (radios[i].checked) defaultValue = Number(radios[i].getAttribute(\"value\").match(/[0-9]/g));\n                    }\n                    return defaultValue;\n                  })();\n                  backImgObj.relCSS.value[backImgObj.imageSelection].url = 'url(\"'+ targetPathName +'\")';\n                  clickedElem.setAttribute(\"style\", unparseBackgroundImg(backImgObj));\n                }\n                else {\n                  document.getElementById(\"dom-attr-src\").setAttribute(\"value\", file.name);\n                  clickedElem.setAttribute(\"src\", targetPathName);\n                }\n                // adapt to HTML5 new attribute 'srcset'\n                // IF website use 'srcset', we force to set this attribute to null then replace image using 'src'\n                if (clickedElem.getAttribute(\"srcset\") != undefined) {\n                  clickedElem.setAttribute(\"srcset\", \"\");\n                }\n              });\n            }\n            // refresh images list\n            showListsImages(targetPathName);  // targetPathName is the last file of files array, but it seems that user can only upload one file once\n            // automatically select upload image\n            let selectedImage = document.querySelectorAll(\".imgFolder > img\");\n            for (let i = 0; i < selectedImage.length; ++i) {\n              let imgName = selectedImage[i].getAttribute(\"src\").split(\"/\").pop();\n              if (imgName === files[files.length - 1].name) {\n                selectedImage[i].parentElement.classList.add(\"highlight-select-image\");\n              } else {\n                selectedImage[i].parentElement.classList.remove(\"highlight-select-image\");\n              }\n            }\n          }\n          async function showListsImages(srcName, backImgObj, checkBackImgObj, findURLS) {\n            if (isAbsolute(srcName)) {\n              return;\n            }\n            console.log(\"hello!\");\n            console.log(\"Source name is:\", srcName);\n            srcName = relativeToAbsolute(srcName)\n            let dir = \"\";\n            for(let i = 0, arr = srcName.split(/\\\\|\\//); i < arr.length - 1; ++i) {\n              dir += (arr[i] + \"/\");\n            }\n            files = await editor.fs.listdir(dir);\n            \n            let images = [];\n            let currentSelectedImage;\n            files.forEach(file => {\n              let ext = file.split('.').pop().toLowerCase();\n              if (ext == 'jpeg' || ext == 'jpg' || ext == 'png' || ext == 'gif' || ext == 'svg' || ext == 'bmp') {\n                if (file.split('/').pop() === srcName.split(\"/\").pop().split(\"?\")[0]) {   // note that srcName maybe \"/1.jpg?raw=true\"\n                  currentSelectedImage = file;\n                } else {\n                  images.push(file);\n                }\n              }\n            });\n            // sometimes website use 'srcset' as the url of image, we cannot find currentSelectedImage precisely\n            if (currentSelectedImage != null) {\n              images.unshift(currentSelectedImage);   // currentSelectedImage should be placed as the first one\n            }\n\n            // init: clear image list\n            let selectedImage = document.querySelectorAll(\".imgFolder\");\n            selectedImage.forEach(e => e.remove());\n\n            let imgDiv = el(\"div\", { \"id\": \"imgGallery\" });\n            if (!document.getElementById(\"imgGallery\")) {\n              ret.append(imgDiv);\n            } else {\n              imgDiv = document.getElementById(\"imgGallery\");\n            }\n\n            for (let i = 0; i < images.length; ++i) {\n              imgDiv.append(\n                el(\"div\", { \"class\": \"imgFolder\" }, el(\"img\", { \"src\": dir + images[i], \"title\": images[i], \"alt\": images[i] },  [], {}), {\n                  onclick() {\n                    //console.log(\"At the beginning:\");\n                    //console.log(JSON.stringify(backImgObj));\n                    // highlight the selected image\n                    let otherImages = document.querySelectorAll(\".imgFolder\");\n                    console.log ({otherImages, document});\n                    for (let i = 0; i < otherImages.length; ++i) {\n                      otherImages[i].classList.remove(\"highlight-select-image\");\n                    }\n                    console.log (\"thru\");\n                    // replace image\n                    if(backImgObj) {\n                      backImgObj.imageSelection = (() => {\n                        let radios = document.querySelectorAll(\".background-img-radio\");\n                        let defaultValue = 0;\n                        for (let i in radios) {\n                          //hopefully there aren't more than 10 images!\n                          if (radios[i].checked) defaultValue = Number(radios[i].getAttribute(\"value\").match(/[0-9]/g));\n                        }\n                        return defaultValue;\n                      })();\n                      //console.log(\"Here?\");\n                      //console.log(JSON.stringify(backImgObj));\n                      if(!(typeof backImgObj.relCSS.value === 'string')){\n                        //console.log(\"Here?\");\n                        //console.log(JSON.stringify(backImgObj));\n                        //console.log(backImgObj.relCSS.value.length);\n                        backImgObj.relCSS.value[backImgObj.imageSelection].url = 'url('+ this.children[0].getAttribute(\"src\") +')';\n                      }\n                      else {\n                        console.log(\"Second time around:\");\n                        backImgObj = checkBackImgObj(clickedElem, findURLS);\n                        backImgObj.relCSS.value[backImgObj.imageSelection].url = 'url('+ this.children[0].getAttribute(\"src\") +')';\n                      }\n                      //console.log(\"current link\", this.children[0].getAttribute(\"src\"));\n                      //console.log(\"current section number is:\", backImgObj.imageSelection);\n                      //console.log(\"current selection is:\", backImgObj.relCSS.value[backImgObj.imageSelection].url); \n                      clickedElem.setAttribute(\"style\", unparseBackgroundImg(backImgObj));\n                      //console.log(\"new style attribute is:\", clickedElem.getAttribute(\"style\"));\n\n                      console.log(JSON.stringify(backImgObj));\n\n                    }\n                    // adapt to HTML5 new attribute 'srcset'\n                    // IF website use 'srcset', we force to set this attribute to null then make image replacemenet\n                    else if (clickedElem.getAttribute(\"srcset\") != undefined) {\n                      clickedElem.setAttribute(\"srcset\", \"\");\n                    }\n                    else {\n                      clickedElem.setAttribute(\"src\", this.children[0].getAttribute(\"src\"));\n                      document.getElementById(\"dom-attr-src\").setAttribute(\"value\", this.children[0].getAttribute(\"src\"));\n                    }\n                    // this.style.outline = \"2px solid white\";\n                    console.log (\"pre1\");\n                    this.classList.add(\"highlight-select-image\");\n                    console.log (\"post1\");\n                  }\n                })\n              );\n            }\n            if (currentSelectedImage != null) {\n              console.log (\"pre2\");\n              ret.querySelectorAll(\".imgFolder\")[0].classList.add(\"highlight-select-image\");\n              console.log (\"post2\");\n            }\n          \n          }\n          let remParentheses = /\\((.*?)\\)/g;\n          let srcName = backgroundImgSrc ? remParentheses.exec(backgroundImgSrc.relCSS.value[0].url)[1] : clickedElem.getAttribute(\"src\");\n\n          //console.log(srcName);\n          //console.log(backgroundImgSrc.relCSS.value[0].url);\n          clickedElem.ondragover = function (e) {\n            e.preventDefault();\n          }\n          clickedElem.ondrop = function (e) {\n            // upload and replace the image \n            e.stopPropagation();\n            e.preventDefault();\n            var files = e.dataTransfer.files; // FileList object\n            if (files && files[0]) {\n              uploadImagesAtCursor(files);\n            }\n          }\n\n          // radio buttons for cases when there are two background images\n          if(backgroundImgSrc && backgroundImgSrc.relCSS.value.length > 1) {\n            for(let i in backgroundImgSrc.relCSS.value) {\n              ret.append(el(\"span\", {class: \"insertOption\"}, [\n                el(\"input\", {type: \"radio\", class: \"background-img-radio\", id: `radio${i}`, name: \"\", value: `Image {i}`}, [], {checked: Number(i) === 0}),\n                el(\"label\", {\"for\": \"radio${i}\"}, `Image {i}`)]),);\n            }         \n          }\n          // upload image button\n          ret.append(\n            el(\"a\", \n              { \"id\": \"upload-image-btn-a\" }, \n              el(\n                \"input\", {\"id\": \"upload-image-btn-input\", \"type\": \"file\", value: \"Please upload images...\"}, \n                [], \n                { onchange: function(evt) { uploadImagesAtCursor(evt.target.files, srcName, backgroundImgSrc); }}\n              ), \n              {}\n            )\n          );\n          if(srcName == undefined) {\n            ret.append(\n              el(\"button\", {}, \"Add src attribute\", {onclick: () => {\n                clickedElem.setAttribute(\"src\", \"\");\n                updateInteractionDiv();\n              }}));\n          } else {\n            showListsImages(srcName, backgroundImgSrc, this.checkForBackgroundImg, this.findURLS);\n            // show lists of images in selected image's folder\n          }\n          return ret;\n        }\n      });\n      editor_model.interfaces.push({\n        title: \"Text Editing\",\n        minimized: true,\n        priority(editor_model) {\n          return undefined;\n        },\n        enabled(editor_model) {\n          const clickedElem = editor_model.clickedElem;\n          if(!clickedElem) return false;\n          for(let i = 0; i < clickedElem.childNodes.length; i++) {\n            let node = clickedElem.childNodes[i];\n            if(node.nodeType === 3 && node.textContent.trim() !== \"\") {\n              return true;\n            }\n          }\n        },\n        render: function render(editor_model, innerBox) {\n          if(!this.enabled(editor_model)) {\n            return \"Click on an element that contains some text.\";\n          }\n          const clickedElem = editor_model.clickedElem;\n          //textarea textChildNodeContent\n          let ret = el(\"div\", {id: \"textChildNodeContentDiv\"}, []);\n          for(let i = 0; i < clickedElem.childNodes.length; i++) {\n            let node = clickedElem.childNodes[i];\n            if(node.nodeType === 3 && node.textContent.trim() !== \"\") { // Non-empty text nodes.\n              ret.append(\n                el(\"textarea\", {class:\"textChildNodeContent\"},\n                [], {\n                  value: node.textContent,\n                  oninput: (node => function() { node.textContent = this.value; })(node)\n                })\n              )\n            } else if(node.nodeType === 1) { // Make this a shortcut for the node\n              ret.append(\n                el(\"div.childrenSelector\", {}, \n                  el(\"div.childrenSelectorName\", {}, \"<\" + node.tagName + \">\"),\n                  {\n                    onclick: (node => () => {\n                      editor_model.clickedElem = node;\n                      updateInteractionDiv();\n                    })(node)\n                  }\n                )\n              )\n            }\n          }\n          setTimeout((ret => () => {\n            for(let i = 0; i < editor_model.textareaPropertiesSaved.length && i < ret.childNodes.length; i++) {\n              if(ret.childNodes[i].tagName === \"TEXTAREA\") {\n                ret.childNodes[i].scrollTop = editor_model.textareaPropertiesSaved[i].scrollTop;\n                ret.childNodes[i].selectionEnd = editor_model.textareaPropertiesSaved[i].selectionEnd;\n                ret.childNodes[i].selectionStart = editor_model.textareaPropertiesSaved[i].selectionStart;\n                if(editor_model.textareaPropertiesSaved[i].focus) {\n                  ret.childNodes[i].focus();\n                }\n              }\n            }\n          })(ret), 0);\n          return ret;\n        }\n      });\n      editor_model.interfaces.push({\n        title: \"Create\",\n        minimized: true,\n        priority(editor_model) {\n          return editor_model.insertElement ? 1 : undefined;\n        },\n        enabled(editor_model) {\n          return editor_model.clickedElem;\n        },\n        render: function render(editor_model, innerBox) {\n          if(!this.enabled(editor_model)) {\n            return \"Click on an element to view insert options.\";\n          }\n          let ret = el(\"div\", {\"class\": \"information\"});\n          const clickedElem = editor_model.clickedElem;\n          if (!clickedElem) return ret;\n          ret.classList.add(\"insert-information-style\");\n          ret.classList.add(\"information-style\");\n          let insertOption = function(value, msg, checked, title) {\n            return el(\"span\", {class: \"insertOption\"}, [\n              el(\"input\", {type: \"radio\", id: \"radioInsert\" + value, name: \"insertionPlace\", value: value}, [], {checked: checked || false}),\n              el(\"label\", {\"for\": \"radioInsert\" + value, title: title}, msg)], {onclick: restoreCaretPosition});\n          }\n          let t = clickedElem.tagName;\n          let isHTML = t === \"HTML\";\n          let isTop = isHTML || t === \"BODY\" || t === \"HEAD\";\n          let caretBlinks = editor_model.caretPosition;\n          ret.append(el(\"div\", {id: \"insertionPlace\"}, [\n            isTop ? undefined : insertOption(\"before\", \"Before node\"),\n            isHTML ? undefined : insertOption(\"first-child\", \"As first child\"),\n            isHTML || !caretBlinks ? undefined : insertOption(\"caret\", \"At caret\", !isTop && caretBlinks),\n            isHTML ? undefined : insertOption(\"last-child\", \"As last child\", isTop || !caretBlinks),\n            isTop ? undefined : insertOption(\"after\", \"After node\"),\n            isTop ? undefined : insertOption(\"wrap\", \"Wrap node\", false, \"Put the selected node inside the newly inserted node\"),\n            clickedElem.childNodes && clickedElem.childNodes.length ? insertOption(\"wrap-children\", \"Wrap children\", false, \"Insert all node's children as children of element, then add element as a child.\") : undefined\n          ]));\n          let getInsertionPlace = () => {\n            let radios = document.querySelectorAll('#insertionPlace input[name=insertionPlace]');\n            let value = \"after\";\n            for (let i = 0, length = radios.length; i < length; i++) {\n              if (radios[i].checked) return radios[i].getAttribute(\"value\");\n              value = radios[i].getAttribute(\"value\");\n            }\n            return value;\n          };\n          let insertTag = function(event, newElement, insertionStyle) {\n            newElement = newElement || (() => {\n              let parent = this;\n              while(parent && !parent.classList.contains(\"tagName\")) parent = parent.parentElement;\n              let m = parent.querySelector(\".templateengine\");\n              if(typeof m.innerHTMLCreate === \"string\") return m.innerHTMLCreate;\n              return el(m.createParams.tag, m.createParams.attrs, m.createParams.children, m.createParams.props);\n            })();\n            if(insertionStyle === \"after\") {\n              if(typeof newElement === \"string\") {\n                clickedElem.insertAdjacentHTML(\"afterend\", newElement);\n                newElement = clickedElem.nextElementSibling;\n              } else {\n                clickedElem.parentElement.insertBefore(newElement, clickedElem.nextSibling);\n              }\n            } else if(insertionStyle === \"before\") {\n              if(typeof newElement === \"string\") {\n                clickedElem.insertAdjacentHTML(\"beforebegin\", newElement);\n                newElement = clickedElem.previousElementSibling;\n              } else {\n                clickedElem.parentElement.insertBefore(newElement, clickedElem);\n              }\n            } else if(insertionStyle === \"wrap\") {\n              if(typeof newElement === \"string\") {\n                clickedElem.insertAdjacentHTML(\"beforebegin\", newElement);\n                newElement = clickedElem.previousElementSibling;\n              } else {\n                clickedElem.parentElement.insertBefore(newElement, clickedElem);\n              }\n              newElement.appendChild(clickedElem);\n              console.log(\"newElement's parent HTML\", newElement.parentElement.outerHTML);\n            } else if(insertionStyle === \"wrap-children\") {\n              if(typeof newElement === \"string\") {\n                clickedElem.insertAdjacentHTML(\"afterbegin\", newElement);\n                newElement = clickedElem.children[0];\n              } else {\n                clickedElem.insertBefore(newElement, clickedElem.childNodes[0]);\n              }\n              while(newElement.nextSibling) {\n                newElement.append(newElement.nextSibling);\n              }\n            } else if(insertionStyle === \"caret\") {\n              let s = editor_model.caretPosition;\n              let txt = s.startContainer;\n              if(txt.textContent.length > s.startOffset && s.startOffset > 0) { // split\n                // Need to split the text node.\n                txt.parentElement.insertBefore(document.createTextNode(txt.textContent.substring(s.startOffset)), txt.nextSibling);\n                txt.textContent = txt.textContent.substring(0, s.startOffset);\n              }\n              if(typeof newElement === \"string\") {\n                let tmpSpan = el(\"span\");\n                clickedElem.insertBefore(tmpSpan, txt.nextSibling)\n                tmpSpan.insertAdjacentHTML(\"afterend\", newElement);\n                newElement = tmpSpan.nextElementSibling;\n                tmpSpan.remove();\n              } else {\n                clickedElem.insertBefore(newElement, txt.nextSibling)\n              }\n            } else if(insertionStyle === \"last-child\") { // Insert at the end of the selected element, inside.\n              if(typeof newElement === \"string\") {\n                let tmpSpan = el(\"span\");\n                clickedElem.insertBefore(tmpSpan, null);\n                tmpSpan.insertAdjacentHTML(\"afterend\", newElement); // afterend or beforeend same, tmpSpan to be removed.\n                newElement = tmpSpan.nextElementSibling;\n                tmpSpan.remove();\n              } else {\n                console.log(\"insert at the end\");\n                // Insert at the end.\n                clickedElem.insertBefore(newElement, null);\n              }\n            } else if(insertionStyle === \"first-child\") { // Insert at the end of the selected element, inside.\n              if(typeof newElement === \"string\") {\n                let tmpSpan = el(\"span\");\n                clickedElem.insertBefore(tmpSpan, clickedElem.children[0]);\n                tmpSpan.insertAdjacentHTML(\"afterend\", newElement);// afterend or beforeend same, tmpSpan to be removed.\n                newElement = tmpSpan.nextElementSibling;\n                tmpSpan.remove();\n              } else {\n                console.log(\"insert at the beginning\");\n                // Insert at the beginning.\n                clickedElem.prepend(newElement);\n              }\n            }\n            editor_model.insertElement = false;\n            editor_model.visible = true;\n            editor_model.clickedElem  = typeof newElement !== \"string\" && typeof newElement !== \"undefined\" ?\n              newElement : clickedElem;\n            updateInteractionDiv();\n          }\n          let addElem = function(name, createParams) {\n            ret.append(\n              el(\"div\", {\"class\": \"tagName\", title: createParams.title},\n                el(\"span\", { \"class\": \"templateengine\"}, name, {createParams: createParams}), {\n                    onclick: function(event) {\n                      let insertionStyle = getInsertionPlace();\n                      insertTag.call(this, event, undefined, insertionStyle);\n                  }}\n              )\n            );\n          }\n          if(clickedElem.tagName === \"HEAD\") {\n            addElem(\"Title\", {tag:\"title\", children: \"Page_title\", title: \"Insert <title>\"});\n            addElem(\"Meta\", {tag:\"meta\", attrs:{name:\"\", content: \"\"}, props: {}, title: \"Insert <meta>\"});\n            addElem(\"Link\", {tag:\"link\", attrs:{rel:\"\", href: \"\"}, props: {}, title: \"Insert <link>\"});\n          }\n          if(clickedElem.tagName !== \"HEAD\") {\n            ret.append(el(\"input\", {\"type\": \"file\", multiple: \"\", value: \"Images or files...\"}, [], {\n              onchange: function(evt) { uploadFilesAtCursor(evt.target.files); }})\n            );\n            ret.append(\n              el(\"div\", {\"class\":\"modify-menu-icon\", id: \"selectExistingNodeToMove\", title: \"Select an existing node to move\"}, [], {\n                  innerHTML: linkModeSVG + \"<span>Move node</span>\",\n                  onclick: function(event) {\n                    editor_model.insertElement = false;\n                    let insertionStyle = getInsertionPlace();\n                    activateNodeSelectionMode(\n                      \"to move\",\n                      node => insertTag.call(this, event, node, insertionStyle),\n                      addPinnedModifyMenuIcon => {\n                        addPinnedModifyMenuIcon(cloneSVG + \"<span class='modify-menu-icon-label-link'>Clone</span>\", \n                          {\"class\": \"link-select-button\", title: \"Confirm to clone\",\n                            id: \"selectbutton\"\n                          },\n                          {onclick: function(event) {\n                            let node = editor_model.clickedElem;\n                            let clonedNode = editor.duplicate(node, {ignoreText: true});\n                            insertTag.call(this, event, clonedNode, insertionStyle);\n                            escapeLinkMode();\n                            editor_model.clickedElem = clonedNode;\n                            }\n                          }\n                        );\n                      }\n                    )\n                  }\n                })\n            )\n            // TODO: Filter and sort which one we can add, also depending on where to insert.\n            addElem(\"List item\", {tag:\"li\", props: { innerHTML: \"<br>\" }, title: \"Insert <li>\"});\n            addElem(\"Bulleted list\", {tag:\"ul\", props: { innerHTML: \"<ul>\\n<li><br></li>\\n</ul>\" }, title: \"Insert <ul>\"});\n            addElem(\"Numbered list\", {tag:\"ol\", props: { innerHTML: \"<ol>\\n<li><br></li>\\n</ol>\" }, title: \"Insert <ol>\"});\n            addElem(\"Button\", {tag: \"button\", props: {innerHTML: \"Button name\" }, title: \"Insert <button>\"});\n            addElem(\"Link\", {tag: \"a\", props: { innerHTML: \"Link name\", href: \"\" }, title: \"Insert <a href=''>\"});\n            addElem(\"Paragraph\", {tag: \"p\", props: { innerHTML: \"Your text here\" }, title: \"Insert <p>\"});\n            addElem(\"Division content\", {tag: \"div\", title: \"Insert <div>\"});\n            addElem(\"Section\", {tag: \"section\", title: \"Insert <section>\"});\n            addElem(\"Image\", {tag: \"img\", title: \"Insert <img>\", attrs: {src: \"\"}});\n            addElem(\"Preformatted text\", {tag: \"pre\", title: \"Insert <pre>\"});\n            for(let i = 1; i <= 6; i++) {\n              addElem(\"Header \" + i, {tag:\"h\" + i, props: { innerHTML: \"Title\" + i }, title: \"Insert <h\"+i+\">\"});\n            }\n            addElem(\"Newline\", {tag: \"br\", title: \"Insert <br>\"});\n          }\n          addElem(\"Stylesheet\", {tag:\"style\", children: \"/*Your CSS there*/\", title: \"Insert <style>\"});\n          addElem(\"JavaScript\", {tag:\"script\", children: \"/*Your CSS below*/\", title: \"Insert <script>\"});\n\n          ret.append(\n            el(\"div\", {\"class\": \"tagName\", id: \"customHTML\"}, [\n              el(\"textarea\", {id: \"customHTMLToInsert\", placeholder: \"Custom HTML here...\", \"class\": \"templateengine\", oninput: \"this.innerHTMLCreate = this.value\"}),\n              el(\"div\", {\"class\":\"modify-menu-icon\", title: \"Insert HTML\", style: \"display: inline-block\"}, [], {\n                  innerHTML: plusSVG, \n                  onclick: function(event) {\n                      let insertionStyle = getInsertionPlace();\n                      insertTag.call(this, event, undefined, insertionStyle);\n                  }\n                }\n              )\n            ])\n          );\n          //document.querySelector(\"#modify-menu\").classList.toggle(\"visible\", true);\n          return ret;\n        }\n      });\n      if (apache_server) {\n        editor_model.interfaces.push({\n          title: \"Drafts\",\n          minimized: true,\n          priority(editor_model) {\n            return undefined;\n          },\n          enabled(editor_model) {\n            return true;\n          },\n          render: (editor_model, innerBox) => {\n            \n            let draftListDiv = el(\"div\", {\"class\":\"draftList\"}, [], {});\n\n            (async () => {\n            const verzExist = JSON.parse(await getServer(\"isdir\", \"Thaditor/versions\"));\n\n            const get_switch_btn_for = (nm) => {\n              return el(\"button\", {\"class\":\"draft-switch\"}, [\"Open \" + nm], \n              {\n                onclick: (event) => {\n                  editor_model.version = nm;\n                  navigateLocal(\"/Thaditor/versions/\" + nm + \"/?edit\");\n                  setTimeout(() => sendNotification(\"Switched to \" + nm), 2000);\n                }\n              });\n            };\n\n            const get_switch_btn_live = () => {\n              return el(\"button\", {class:\"draft-switch-live draft-switch\"}, [\"Open live website\"],\n              {\n                onclick: (event) => {\n                  editor_model.version = \"Live\";\n                  navigateLocal(\"/?edit\");\n                  setTimeout(() => sendNotification(\"Switched to Live version\"), 2000);\n                }\n              })\n            }\n\n            const get_clone_btn_for = (nm) => {\n              return el(\"button\", {\"class\":\"draft-clone\", title: \"Clone \" + nm + \" to a new version\"}, [\"Clone\"],\n              {\n                onclick: (event) => {\n                  cloneSite(nm, verzExist); //confirms + sends notif inside method\n                }\n              })  \n            }\n\n            const get_delete_btn_for = (nm) => {\n              return el(\"button\", {\"class\":\"draft-delete\", title: \"Delete version \" + nm}, [\"Delete\"],\n              {\n                onclick: (event) => {\n                  deleteDraft(nm); //confirms + sends notif inside the method\n                }\n              })  \n            }\n\n            const get_rename_btn_for = (nm) => {\n              return el(\"button\", {\"class\":\"draft-publish\", title: \"Rename \" + nm}, [\"Rename\"],\n              {\n                onclick: (event) => { \n                  renameDraft(nm, verzExist); //confirms + sends notif inside\n                }\n              })\n            }\n\n            const get_publish_btn_for = (nm) => {\n              return el(\"button\", {\"class\":\"draft-publish\", title: \"Publish \" + nm + \" to live\"}, [\"Publish\"],\n              {\n                onclick: (event) => { \n                  publishDraft(nm); //confirms + sends notif inside\n                }\n              })\n            };\n\n            const get_current_label = () => {\n              return el(\"div\", {\"class\":\"draft-row\", \"id\": \"draft-title\"},\n                      [\n                        el(\"label\", {}, [editor_model.version], {}),\n                        (isLive() ? el(\"label\", {}, [\"\"]) : get_rename_btn_for(editor_model.version)),\n                        get_clone_btn_for(editor_model.version),\n                        (isLive() ? el(\"label\", {}, [\"Can't delete live\"]):\n                                                          el(\"button\", {}, [\"Delete\"],\n                                                          {\n                                                            onclick: (event) => {\n                                                              deleteDraft(editor_model.version);\n                                                            }\n                                                          })),\n\n                      ],\n                      {\n                        onclick: (event) => {\n                          //pass\n                        },\n                      })\n            };\n\n            const get_current_label_live = () => {\n              return el(\"div\", {\"class\":\"draft-row\", \"id\": \"draft-title\"},\n                      [\n                        el(\"label\", {style:\"font-style:italic\"}, [\"Currently viewing live website\"], {}),\n                        get_clone_btn_for(\"Live\"),\n                        \n\n                      ],\n                      {\n                        onclick: (event) => {\n                          //pass\n                        },\n                      })\n            };\n\n            const get_current_label_for = (nm) => {\n              return el(\"div\", {\"class\":\"draft-row\", \"id\": \"draft-title\"},\n                      [\n                        el(\"label\", {title: \"Currently viewing \" + nm + \" version\"}, [nm], {}),\n                        get_rename_btn_for(editor_model.version),\n                        get_clone_btn_for(nm),\n                        get_delete_btn_for(nm),\n                        get_publish_btn_for(nm),\n                      ],\n                      {\n                        onclick: (event) => {\n                          //pass\n                        },\n                      })\n            };\n            \n\n            const get_row_for_draft = (nm) => {\n              return el(\"div\", {\"class\": \"draft-row\"},\n              [\n                get_switch_btn_for(nm),\n                get_rename_btn_for(nm),\n                get_clone_btn_for(nm),\n                get_delete_btn_for(nm),\n              ]);\n            };\n\n            const get_row_for_live = () => {\n              return el(\"div\", {\"class\": \"draft-row\", \"id\": \"draft-row-live\"},\n              [\n                get_switch_btn_live(),\n                get_clone_btn_for(\"Live\")\n              ])\n            }\n\n            if (isLive()) {\n              draftListDiv.append(get_current_label_live());\n            } else {\n              draftListDiv.append(get_current_label_for(editor_model.version));\n              draftListDiv.append(get_row_for_live());\n            }\n            if (verzExist) {\n              const vers = JSON.parse(await getServer(\"listdir\", \"Thaditor/versions/\"));\n              vers.forEach(ver => {\n                if (!(ver == editor_model.version)){\n                  draftListDiv.append(get_row_for_draft(ver));\n                }\n              });\n            }\n            })();\n            return draftListDiv;\n          }\n        });\n       }\n      editor_model.interfaces.push({ \n        title: \"Advanced\",\n        minimized: true,\n        priority(editor_model) {\n          return editor_model.disambiguationMenu ? 0 : undefined;\n        },\n        enabled(editor_model) {\n          return true;\n        },\n        render: function render(editor_model, innerBox) {\n          let retDiv = el(\"div\", {\"class\":\"modify-menu-icons\"});\n          //We need 3 btns: refresh, filesystem + help.\n          add_btn_to_div(retDiv, reloadSVG,\n            {\"class\": \"tagName\", title: \"Reload the current page\"},\n              {onclick: function(event) {\n                if(nothingToLose()) {\n                  reloadPage();\n                }\n              } }\n            );\n          add_btn_to_div(retDiv, folderSVG,\n            {\"class\": \"tagName\", title: \"List files in current directory\"},\n              {onclick: function(event) {\n                let u =  new URL(location.href);\n                u.pathname = u.pathname.replace(/[^\\/]*$/, \"\");\n                u.searchParams.set(\"ls\", \"true\");\n                if(nothingToLose()) {\n                  navigateLocal(u.href);\n                }\n              }\n            }\n          );\n          if(apache_server) {\n            retDiv.append(\n              el(\"button.action-button#update-thaditor-btn\", {type: \"\"}, \"Update Thaditor\", {onclick() {\n                if(confirm(\"Are you ready to upgrade Thaditor?\")) {\n                  doWriteServer(\"updateversion\", \"latest\", \"\", response => {\n                    console.log(\"Result from Updating Thaditor to latest:\");\n                    console.log(response);\n                    location.reload(true);\n                  });\n                }\n              } })\n            );\n          }\n          retDiv.append(\n            el(\"label\", {class:\"switch\", title: \"If off, ambiguities are resolved automatically. Does not apply for HTML pages\"},\n              [el(\"input\", {class: \"global-setting\", id: \"input-question\", type: \"checkbox\"}, [], {\n                onchange: function() { editor_model.askQuestions = this.checked; },\n                checked: editor_model.askQuestions}),\n              el(\"span\", {class:\"slider round\"})]));\n          retDiv.append(\n            el(\"label\", {\"for\": \"input-question\", class: \"label-checkbox\"}, \"Ask questions\"));\n          \n          retDiv.append(\n            el(\"label\", {class:\"switch\", title: \"If on, changes are automatically propagated 1 second after the last edit\"}, [\n              el(\"input\", {class: \"global-setting\", id: \"input-autosave\", type:\"checkbox\"}, [], {\n                onchange: function() { editor_model.autosave = this.checked; },\n              checked: editor_model.autosave}),\n              el(\"span\", {class:\"slider round\"})])\n          );\n          retDiv.append(\n            el(\"label\", {\"for\": \"input-autosave\", class: \"label-checkbox\"}, \"Auto-save\"));\n          \n          if(apache_server) {\n            retDiv.append(\n              el(\"a\", {href:\"javascript:0\", id:\"thaditor-sign-out-button\", style:\"display:block\"}, \"Sign out of Google\", {\n                onclick() {\n                  let onOk = () => thaditor_sign_out(() => {\n                    retDiv.append(\n                      el(\"a\", {href:\"javascript:0\", id:\"thaditor-google-log-in-button\", style:\"display:block\"}, \"Sign in with Google\",\n                      {onclick: thaditor_sign_in()}));\n                    document.querySelector(\"#thaditor-sign-out-button\").remove();\n                  });\n                  if(!gapi.auth2) {\n                    thaditor_gapi_onload(onOk);\n                  } else {\n                    onOk();\n                  }\n                }})\n            );\n          }\n          if(editor_model.disambiguationMenu) {\n            retDiv.append(editor_model.disambiguationMenu);\n          }\n          return retDiv;\n        }\n      });\n      \n      editor_model.interfaces.push({\n        title: \"Log\",\n        minimized: true,\n        priority(editor_model) {\n          return undefined;\n        },\n        enabled(editor_model) {\n          return true;\n        },\n        currentBox: undefined,\n        render: function render(editor_model, innerBox) {\n          let retDiv = el(\"div#fullLog\", {\"class\":\"modify-menu-icons\"});\n          let logtxt = \"\";\n          const elog = editor_model.editor_log;\n          for (let i = 0; i < elog.length; i++) {\n            const l = elog[i];\n            logtxt = logtxt + (i > 0 ? \"<br>\" : \"\") + l;\n          }\n          retDiv.innerHTML = logtxt;\n          this.currentBox = retDiv;\n          return retDiv;\n        },\n        refresh() {\n          let currentBox = this.currentBox;\n          let newBox = this.render(editor_model);\n          currentBox.parentNode.insertBefore(newBox, currentBox);\n          currentBox.remove();\n        }\n      });\n      editor_model.interfaces.push({\n        title: \"Source\",\n        minimized: true,\n        priority(editor_model) {\n          return undefined;\n        },\n        enabled(editor_model) {\n          return true;\n        },\n        render: function render(editor_model, innerBox) {\n          let source = document.querySelector(\"#modify-menu\").getAttribute(\"sourcecontent\");\n          let ret = \n            el(\"div\", {\"class\": \"tagName nohover\"},\n             [el(\"textarea\",\n                  {style: \"width:100%\",\n                   id: \"sourcecontentmodifier\", placeholder: \"Source of the page, before evaluation\", \"class\": \"templateengine\"}, [], {\n                oninput: function() {\n                  if(document.querySelector(\"#modify-menu\").getAttribute('sourcecontent') !== this.value)\n                    document.querySelector(\"#modify-menu\").setAttribute('sourcecontent', this.value);\n                  },\n                value: source\n               })]);\n          return ret;\n        }\n      });\n      if(typeof thaditor !== \"undefined\" && thaditor.customInterfaces) {\n        editor_model.interfaces.push(...thaditor.customInterfaces);\n      }\n    }\n    \n    function getEditorInterfaceByTitle(title) {\n      return editor_model.interfaces.find(x => x.title === title);\n    }\n\n\n    if (!ifAlreadyRunning) {\n      const get_interface = nm => editor_model.interfaces.find(ele => ele.title == nm);\n      let do_interfaces;\n    }\n    do_interfaces = true;\n    // First time: We add the interface containers.\n    if(!ifAlreadyRunning && do_interfaces) {\n      \n      init_interfaces();\n      //editor_model.visible = true;\n      //updateInteractionDiv();\n    }\n    \n    //if no ID, tag/name, or class (if h1, h2, etc..., probably fine)\n    //split between common (section, div, span, p, ul,  etc...) and rare/better semantically defined tags (pre)\n\n    //check if selector applies to any ancestors or descendants, then its ok\n    //else add class or use > selector until it is precise \n    function getShortestUniqueSelector(clickedElem) {\n      let curSelector = clickedElem.tagName.toLowerCase();\n      if(clickedElem.getAttribute(\"id\")) {\n        curSelector += \"#\" + clickedElem.getAttribute(\"id\")\n      }\n      if (clickedElem.getAttribute(\"class\") && clickedElem.getAttribute(\"class\") != \"\") {\n        curSelector += (\" \" + clickedElem.getAttribute(\"class\")).replace(/\\s+/g, \".\");\n      }\n      //checking ancestors\n      let consideredParent = clickedElem.parentNode;\n      do {\n        var selectorIsOrg = true;\n        for(let curAncestor = clickedElem.parentNode; curAncestor; curAncestor = curAncestor.parentNode) {\n          if(editor.matches(curAncestor, curSelector)) {\n            selectorIsOrg = false;\n          }\n        }\n        //checking descendants\n        if(clickedElem.querySelector(curSelector)) {\n          selectorIsOrg = false;\n        }\n        if(!selectorIsOrg) {\n          curSelector =  consideredParent.tagName.toLowerCase() + \" > \" + curSelector; \n          consideredParent = consideredParent.parentNode;\n        }\n      } while(!selectorIsOrg && consideredParent);\n      return curSelector;\n    }\n    \n\n    function reorderCompatible(node1, node2){\n      let topLevelOrderableTags = {TABLE:1, P:1, LI:1, UL:1, OL:1, H1:1, H2:1, H3:1, H4:1, H5:1, H6:1, DIV:1, SECTION: 1, IMG: 1, PRE: 1};\n      let metaOrderableTags = {META:1, TITLE:1, SCRIPT: 1, LINK: 1, STYLE: 1};\n      return node1.tagName === node2.tagName && node1.tagName !== \"TD\" && node1.tagName !== \"TH\" ||\n        topLevelOrderableTags[node1.tagName] && topLevelOrderableTags[node2.tagName] ||\n        metaOrderableTags[node1.tagName] && metaOrderableTags[node2.tagName];\n    }\n    function preventTextDeselection(e){\n      e = e || window.event;\n      e.preventDefault();\n    }\n    function restoreCaretPosition() {\n      if(typeof editor_model.caretPosition != \"undefined\") {\n        var sel = window.getSelection();\n        sel.removeAllRanges();\n        var range = document.createRange();\n        range.setStart(editor_model.caretPosition.startContainer, editor_model.caretPosition.startOffset);\n        range.setEnd(editor_model.caretPosition.endContainer, editor_model.caretPosition.endOffset);\n        sel.addRange(range);\n      }\n    }\n    // This function activates the node selection mode, in which one DOM node can be selected,\n    // After clicking on confirm, the callback is called with the selected node.\n    // callbackUI is invoked to render other buttons along with the confirmation button.\n    function activateNodeSelectionMode(msg, callback, callbackUI) {\n      editor_model.visible = false;\n      \n      editor_model.linkSelectMode = true;\n      editor_model.clickedElem = document.body; //\"center\" clicked element on document body\n      //removes all context menu stuff \n      document.querySelector(\"#context-menu\").classList.remove(\"visible\");\n      editor_model.linkSelectCallback = callback;\n      editor_model.linkSelectMsg = \"Confirm \" + msg;\n      editor_model.linkSelectOtherMenus = callbackUI;\n      updateInteractionDiv();\n      sendNotification(editor_model.linkSelectMsg);\n      document.body.addEventListener('mouseover', linkModeHover1, false);\n      document.body.addEventListener('mouseout', linkModeHover2, false);\n    }\n\n    \n\n    function copy_website(source, dest) {\n      let website_files = JSON.parse(doReadServer(\"fullListDir\", source));\n      let is_dest_valid = doReadServer(\"isdir\", dest)\n      if (!website_files) throw \"copy_website(): invalid source\";\n      if (!is_dest_valid) throw \"copy_website(): invalid dest\";\n      \n      //filter out Thaditor files\n      website_files = website_files.filter(val => !thaditor_files.includes(val[0]));\n      website_files = website_files.filter(val => val[0][0] != \".\");\n      //cpy website_files to to dest\n      website_files.forEach(val => {\n        let [nm, isdir] = val;\n        const s = (source + nm);\n        const d = (dest + nm);\n        if (isdir) {\n          doWriteServer(\"fullCopy\", s, d);\n        } else {\n          doWriteServer(\"copy\", d, s);\n        }\n      });\n      let dh = doReadServer(\"read\", source + \"/.thaditor_meta\");\n      dh = dh.slice(1, dh.length);\n      let draft_history = (dh == \"\" ? undefined : JSON.parse(dh));\n      const get_date_meta = () => (new Date).toString();\n      if (draft_history == undefined) {\n        draft_history = [\"live:\" + get_date_meta()];\n      } else {\n        draft_history.push(editor_model.version + \":\" + get_date_meta());\n      }\n      doWriteServer(\"write\", dest + \"/.thaditor_meta\", JSON.stringify(draft_history));\n      return 1;\n    }\n    \n    function deleteDraftDef(nm) { //definitely delete the draft, without a prompt\n      //the path of the folder we want to delete is and always will be Thaditor/versions/$nm/\n      const pth_to_delete = \"Thaditor/versions/\" + nm + \"/\";\n      //here we want to hand doWriteServer to the worker in editor.js\n\n      const data = {action:\"drafts\",\n                    subaction:\"deletermrf\",\n                    pth_to_delete:pth_to_delete,\n                    nm:nm, thaditor_files:thaditor_files, version:editor_model.version};\n      if (editor_model.version == nm) {\n        doWriteServer(\"deletermrf\", pth_to_delete);\n        navigateLocal(\"/?edit\");\n      } else {\n        editor_model.serverWorker.postMessage(data);\n      }\n      updateInteractionDiv();\n    }\n\n    function deleteDraft(nm) {\n      if (nm == \"Live\") throw \"Shouldn't be able to call deleteDraft on live\";\n      const ans = window.confirm(\"Are you sure you want to permanently delete \" + nm + \"?\");\n      if (!ans) return;\n      deleteDraftDef(nm);\n    }\n\n\n    function getNewDraftName(nm, verzExist) {\n      const draft_name = window.prompt (\"Please provide the name for the new draft. Leave blank to cancel\");\n      if (!draft_name) {\n        return 0;\n      }\n      \n      let is_draft_name_valid = (nm) => {\n        return !(nm.startsWith(\"[^a-zA-Z0-9]\"));\n      };\n\n      if (!is_draft_name_valid(draft_name)) {\n        window.alert(\"Invalid draft name\");\n        return 0;\n      }\n      \n      let fail = false;\n      if (!verzExist) {\n        doWriteServer(\"mkdir\", \"Thaditor/versions\");\n      } else {\n        let versionsList = JSON.parse(doReadServer(\"fullListDir\", \"Thaditor/versions/\"));\n        versionsList.forEach(val => {\n          let [nm, isdir] = val;\n          if (isdir) {\n            if (nm == draft_name) {\n              fail = window.confirm(\"Overwrite existing draft?\");\n            }\n          }\n        });\n      }\n      if (fail) return 0;\n      return draft_name;\n    }\n\n\n    function cloneSite(nm, verzExist) {\n      //verzExist tells us if we need to mkdir versions\n      //nm could be live or any draft ==> make f_pth\n      const draft_name = getNewDraftName(nm, verzExist);\n      if (!draft_name) return 0;\n      //all of that above ^^ needs to happen in the UI thread.\n      const t_pth = \"Thaditor/versions/\" + draft_name + \"/\"\n      const f_pth = (nm == \"Live\" ? \"\" : \"Thaditor/versions/\" + nm + \"/\");\n      const data = {action:\"drafts\", subaction:\"clone\",\n                    draft_name:draft_name,\n                    t_pth:t_pth, f_pth:f_pth,\n                    nm:nm,thaditor_files:thaditor_files,version:editor_model.version};\n      editor_model.serverWorker.postMessage(data);\n      sendNotification(\"Creating draft \" + draft_name + \" from \" + nm);\n    }\n    \n    function renameDraft(nm, verzExist) {\n      //verzExist tells us if we need to mkdir versions\n      //nm could be live or any draft ==> make f_pth\n      const draft_name = getNewDraftName(nm, verzExist);\n      if (!draft_name) return 0;\n      //all of that above ^^ needs to happen in the UI thread.\n      const t_pth = \"Thaditor/versions/\" + draft_name + \"/\"\n      const f_pth = (nm == \"Live\" ? \"\" : \"Thaditor/versions/\" + nm + \"/\");\n      const data = {action:\"drafts\", subaction:\"rename\",\n                    draft_name:draft_name,\n                    t_pth:t_pth, f_pth:f_pth,\n                    nm:nm,thaditor_files:thaditor_files,version:editor_model.version};\n      editor_model.serverWorker.postMessage(data);\n      sendNotification(\"Renaming draft \" + nm + \" to \" + draft_name);\n    }\n\n    function publishDraft(nm) {\n      //We're copying out Thaditor/versions/$nm/ to \"\".\n      if (nm == \"Live\") throw \"Can't publish live to live\";\n      const conf = window.confirm(\"Are you sure you want to publish \" + nm + \" to live?\");\n      if (!conf) {\n        return;\n      }\n      let t_src = \"Thaditor/versions/\" + nm + \"/\";\n      const data = {action:\"drafts\",\n                    subaction:\"publish\",\n                    t_src:t_src,\n                    nm:nm,thaditor_files:thaditor_files,\n                    version:editor_model.version};\n      editor_model.serverWorker.postMessage(data);\n    }\n    \n\n    updateInteractionDiv(); //outer lastEditScript\n\n    \n\n    function updateInteractionDiv() {\n      const menuholder = document.querySelector(\"#modify-menu-holder\");\n      const old_scroll = menuholder ? menuholder.scrollTop : 0;\n      \n      // Set up\n      let model = editor_model;\n      var clickedElem = model.clickedElem;\n      var CSSparser = new losslesscssjs();\n      var contextMenu = document.querySelector(\"#context-menu\");\n      var modifyMenuDiv = document.querySelector(\"#modify-menu\");\n      \n      if(!modifyMenuDiv || !contextMenu) return;\n      modifyMenuDiv.classList.toggle(\"editor-interface\", true);\n      contextMenu.classList.toggle(\"editor-interface\", true);\n\n      // Display the interface or not\n      modifyMenuDiv.classList.toggle(\"visible\", editor_model.visible); //Mikael what does this do? -B\n\n      // Make sure at most one element is marked as ghost-clicked.\n      document.querySelectorAll(\"[ghost-clicked=true]\").forEach(e => e.removeAttribute(\"ghost-clicked\"));\n      if(clickedElem && clickedElem.nodeType === 1) {\n        clickedElem.setAttribute(\"ghost-clicked\", \"true\");\n      }\n      \n      // Recover selection if it exists\n      model.selectionRange = model.notextselection ? undefined : (() => {\n        let selection = window.getSelection();\n        if(!selection || !selection.rangeCount) return;\n        let f = selection.getRangeAt(0); \n        if(!f || !f.getBoundingClientRect ||\n            f.startOffset === f.endOffset && f.startContainer === f.endContainer) return;\n        return f;\n      })();\n      \n      // Recover caret position if it exists\n      model.caretPosition = model.notextselection || clickedElem && clickedElem.tagName === \"HEAD\" ? undefined : (() => {\n        let selection = window.getSelection();\n        if(!selection || !selection.rangeCount) return;\n        let f = selection.getRangeAt(0);\n        if(!f || f.startOffset !== f.endOffset && f.startContainer !== f.endContainer) return;\n        return f;\n      })();\n      \n      // We render the content of modifyMenuDiv from scratch\n      modifyMenuDiv.innerHTML = \"\";\n      let modifyMenuPinnedIconsDiv = el(\"div\", {\"class\":\"modify-menu-icons pinned\"}); // Icons always visible\n      let modifyMenuIconsDiv = el(\"div\", {\"class\":\"modify-menu-icons\"}); // Top-level icons on the top bar\n      let domSelector = el(\"div\", {\"class\": \"dom-selector noselect\"}); // create dom selector interface\n      let modifyMenuHolder = el(\"div\", {\"class\": \"modify-menu-holder\", \"id\":\"modify-menu-holder\"});\n      modifyMenuDiv.append(modifyMenuPinnedIconsDiv); // Keep this one as it.\n      \n      /*\n        Render interfaces / containers\n      */\n      for(let i = 1; i < editor_model.interfaces.length; i++) {\n        let x = editor_model.interfaces[i];\n        let priority = x.priority(editor_model);\n        if(i > 0 && typeof priority === \"number\") {\n          x.minimized = false;\n          let previous = editor_model.interfaces[i-1]\n          let beforePriority = previous.priority(editor_model);\n          if(typeof beforePriority === \"undefined\" && (!previous.enabled(editor_model) || previous.minimized)) {\n            var tmp = editor_model.interfaces[i];\n            editor_model.interfaces[i] = editor_model.interfaces[i-1];\n            editor_model.interfaces[i-1] = tmp;\n            i -= 2; // Bubble up\n          }\n        }\n      }\n      for(let i = 0; i < editor_model.interfaces.length; i++) {\n        let x = editor_model.interfaces[i];\n        let priority = x.priority(editor_model);\n        let initMinimized = typeof priority == \"number\" ? false :\n                            x.enabled(editor_model) ? x.minimized : true;\n        let renderedContent = x.render(editor_model);\n        let class_str = x.title.replace(\" \", \"_\");\n        let menu = el(\n          \"div\", {\n            class:\"editor-container\" + (x.enabled(editor_model) ? \"\" : \" disabled\") + (x.minimized ? \" minimized\" : \"\") + \" \" + class_str},\n          [ el(\"div.editor-container-title\", {\n                 title: typeof renderedContent === \"string\" ? renderedContent : undefined\n               },\n               [ el(\"div\", {title: \"Expand menu\", class: \"expand-menu\"}, x.title),\n                 el(\"div.editor-container-icon#displayarrow\", {}, [], {innerHTML: displayArrowSVG}),\n                 el(\"div.editor-container-icon.arrowdown\", {title: \"Move menu down\"}, [], {innerHTML: editorContainerArrowDown,\n                   onclick: function(event) {\n                     let d = this.parentElement.parentElement;\n                     var tmp = editor_model.interfaces[d.i];\n                     editor_model.interfaces[d.i] = editor_model.interfaces[d.i+1];\n                     editor_model.interfaces[d.i+1] = tmp;\n                     d.nextElementSibling.i = d.i;\n                     d.i = d.i + 1;\n                     d.parentElement.insertBefore(d.nextElementSibling, d);\n                     event.preventDefault();\n                     event.stop = true;\n                     return false;\n                   }}),\n                 el(\"div.editor-container-icon.arrowup\", {title: \"Move menu up\"}, [], {innerHTML: editorContainerArrowUp,\n                   i: i,\n                   onclick: function(event) {\n                     let d = this.parentElement.parentElement;\n                     var tmp = editor_model.interfaces[d.i];\n                     editor_model.interfaces[d.i] = editor_model.interfaces[d.i-1];\n                     editor_model.interfaces[d.i-1] = tmp;\n                     d.previousElementSibling.i = d.i;\n                     d.i = d.i - 1;\n                     d.parentElement.insertBefore(d, d.previousElementSibling);\n                     event.preventDefault();\n                     event.stop = true;\n                     return false;\n                   }})\n               ],\n               {\n                onclick: ((x) => event => {\n                  console.log(event);\n                  if(event.stop) return;\n                  let target = event.target;\n                  while(!target.matches(\".editor-container\")) target = target.parentNode;\n                  //console.log(\"onclick\", event.target);\n                  x.minimized = target.classList.contains(\"minimized\");\n                  x.minimized = !x.minimized;\n                  target.classList.toggle(\"minimized\", x.minimized);\n                })(x)\n               }),\n            el(\"div.editor-container-content\", {}, renderedContent),\n          ],\n        {i: i});\n        modifyMenuHolder.append(menu);\n      }\n      if (do_interfaces) {\n        //console.log ({old_scroll, modifyMenuHolder});\n        modifyMenuDiv.append(modifyMenuHolder);\n        if(modifyMenuHolder) modifyMenuHolder.scrollTop = old_scroll;\n      }\n\n      let createButton = function(innerHTML, attributes, properties) {\n        let button = el(\"div\", attributes, [], properties);\n        button.onmousedown = button.onmousedown ? button.onmousedown : preventTextDeselection;\n        button.classList.add(\"modify-menu-button\");\n        button.innerHTML = innerHTML;\n        return button;\n      }\n      let addPinnedModifyMenuIcon = function(innerHTML, attributes, properties) {\n        modifyMenuPinnedIconsDiv.append(createButton(innerHTML, attributes, properties));\n      }\n      var panelOpenCloseIcon = function() {\n        return document.querySelector(\"#modify-menu\").classList.contains(\"visible\") ?\n            onMobile() ? closeBottomSVG : closeRightSVG + \"<span class='modify-menu-icon-label'>Close</span>\"\n          : onMobile() ? openTopSVG : openLeftSVG + \"<span class='modify-menu-icon-label'>Open</span>\";\n      }\n      var alwaysVisibleButtonIndex = 0;\n      function nextVisibleBarButtonPosStyle() {\n        let result = \"position: absolute;\" +\n          (onMobile() ? \"top:-\"+buttonHeight()+\"px;left:\"+alwaysVisibleButtonIndex*buttonWidth()+\"px\" :\n                        \"left:-\"+buttonWidth()+\"px;top:\"+alwaysVisibleButtonIndex*buttonHeight()+\"px\")\n        alwaysVisibleButtonIndex++;\n        return result;\n      }\n      if(!editor_model.linkSelectMode) {\n        addPinnedModifyMenuIcon(\n          panelOpenCloseIcon(),\n          {title: \"Open/close settings tab\", \"class\": \"inert\" },\n          {onclick: function(event) {\n              document.querySelector(\"#modify-menu\").classList.toggle(\"visible\");\n              editor_model.visible = !editor_model.visible;\n              setTimeout(maybeRepositionContextMenu, 500);\n              this.innerHTML = panelOpenCloseIcon();\n              if(onMobile() && editor_model.savedTextSelection) {\n                window.getSelection().addRange(editor_model.savedTextSelection);\n                editor_model.savedTextSelection = undefined;\n              }\n            }\n        });\n        if(EDITOR_VERSION & 1) {\n          addPinnedModifyMenuIcon(undoSVG + \"<span class='modify-menu-icon-label'>Undo</span>\", \n            {\"class\": \"inert\" + (canUndo() ? \"\" : \" disabled\"), title: \"Undo most recent change\",\n              id: \"undobutton\"\n            },\n            {onclick: function(event) {\n              if(!undo()) sendNotification(\"Nothing to undo!\");\n              }\n            }   \n          );\n          addPinnedModifyMenuIcon(redoSVG + \"<span class='modify-menu-icon-label'>Redo</span>\",\n            {\"class\": \"inert\" + (canRedo() ? \"\" : \" disabled\"), title: \"Redo most recent undo\",\n              id: \"redobutton\"\n            },\n            {onclick: function(event) {\n             if(!redo()) sendNotification(\"Nothing to redo!\");\n              }\n            }\n          );\n        }\n        addPinnedModifyMenuIcon(saveSVG + \"<span class='modify-menu-icon-label'>Save</span>\",\n        {title: editor_model.disambiguationMenu ? \"Accept proposed solution\" : \"Save\", \"class\": \"saveButton\" + (editor_canSave() || editor_model.disambiguationMenu ? \"\" : \" disabled\") + (editor_model.isSaving ? \" to-be-selected\" : \"\"),\n          id: \"savebutton\"  \n        },\n          {onclick: editor_model.disambiguationMenu ? \n            ((ambiguityKey, selected) => () => acceptAmbiguity(ambiguityKey, selected))(\n              editor_model.disambiguationMenu.ambiguityKey, editor_model.disambiguationMenu.selected)\n            : function(event) {\n              if (editor_model.isSaving) {\n                sendNotification(\"Can't save while save is being undertaken\");\n              }\n              else {\n                //temp place to put CSS file loading stuff (may well be moved later)\n                let allPageLinks = document.querySelectorAll(\"link[rel=stylesheet]\");\n                (async () => {\n                  for(let e = 0; e < allPageLinks.length; e++) {\n                    let linkNode = allPageLinks[e];\n                    if(!isGhostNode(linkNode) && linkNode.getAttribute(\"ghost-href\")) {\n                      let linkNodeTmpHref = linkNode.getAttribute(\"href\");\n                      let linkNodeOriginalHref = linkNode.getAttribute(\"ghost-href\");\n                      let trueTempPath = removeTimestamp(linkNodeTmpHref); // This one is absolute normally\n                      let originalAbsPath = relativeToAbsolute(removeTimestamp(linkNodeOriginalHref));\n                      let newValue = (await getServer(\"read\", trueTempPath)).slice(1);\n                      await postServer(\"write\", originalAbsPath, newValue);\n                      linkNode.cachedContent = newValue;\n                      linkNode.tmpCachedContent = newValue;\n                      // Since we delete the temporary file, we cannot revert to the temporary href.\n                      // Problem: it's not possible to undo small changes.\n                      // Worse: The deletion of the tmp css file will make it impossible to undo to states before of before this saving.\n                      // Ghost attributes are not restored when doing undo.\n                      editor_stopWatching();\n                      linkNode.setAttribute(\"href\", setTimestamp(linkNodeOriginalHref));\n                      linkNode.removeAttribute(\"ghost-href\");\n                      editor_resumeWatching();\n                      await postServer(\"unlink\", trueTempPath);\n                    }                 \n                  }\n                  editor_model.undosBeforeSave = editor_model.undoStack.length;\n                  if(!this.classList.contains(\"disabled\")) {\n                    if (apache_server) {\n                      sendModificationsToServer();\n                    } else {\n                      sendModificationsToServerNode();\n                    }\n                  }\n                })();\n              }\n            }\n          }\n        )\n      }\n      else {\n        addPinnedModifyMenuIcon(escapeSVG + \"<span class='modify-menu-icon-label-link'>Cancel</span>\", \n          {\"class\": \"link-select-button\", title: \"Go back to original screen\",\n            id: \"escapebutton\"\n          },\n          {onclick: function(event) {\n              escapeLinkMode();\n            }\n          }\n        );\n        addPinnedModifyMenuIcon(checkSVG + \"<span class='modify-menu-icon-label-link'>Select</span>\", \n          {\"class\": \"link-select-button\", title: editor_model.linkSelectMsg || \"Select target\",\n            id: \"selectbutton\"\n          },\n          {onclick: function(event) {\n              editor_model.linkSelectCallback(editor_model.clickedElem);\n              escapeLinkMode();\n            }\n          }\n        );\n        if(editor_model.linkSelectOtherMenus) {\n          editor_model.linkSelectOtherMenus(addPinnedModifyMenuIcon)\n        }\n      } //keep all that above here^^\n      //1500 lines of code switched out to init_interfaces!!! yayay!!\n\n      //\n\n      if(!editor_model.linkSelectMode) {\n        contextMenu.innerHTML = \"\";\n        var whereToAddContextButtons = contextMenu;\n        var noContextMenu = false;\n        // What to put in context menu?\n        if(onMobile() || (editor_model.clickedElem && editor_model.clickedElem.matches(\"html, head, head *, body\"))) {\n          modifyMenuPinnedIconsDiv.parentElement.insertBefore(modifyMenuIconsDiv, modifyMenuPinnedIconsDiv.nextSibling);\n          whereToAddContextButtons = modifyMenuIconsDiv;\n          noContextMenu = true;\n        }\n        let numButtons = 0;\n        let addContextMenuButton = function(innerHTML, attributes, properties) {\n          let button = el(\"div\", attributes, [], properties);\n          button.onmousedown = button.onmousedown ? button.onmousedown : preventTextDeselection;\n          button.classList.add(\"context-menu-button\");\n          button.innerHTML = innerHTML;\n          whereToAddContextButtons.append(button);\n          numButtons++;\n        }\n        if(model.link) {\n          addContextMenuButton(liveLinkSVG(linkToEdit(model.link)),\n            {title: \"Go to \" + model.link, \"class\": \"inert\"});\n        }\n        if(!model.selectionRange && clickedElem && clickedElem.parentNode && EDITOR_VERSION & 1) {\n          addContextMenuButton(parentUpSVG,\n          {title: \"Select parent\", \"class\":\"inert\"},\n            {onclick: (c => event => {\n              editor_model.clickedElem = c;\n              updateInteractionDiv();\n            })(clickedElem.parentNode)}\n          );\n        }\n        \n        var computedStyle = clickedElem && window.getComputedStyle(clickedElem);\n        var isDisplayInline = computedStyle && (computedStyle.display.startsWith(\"inline\") || computedStyle.display === \"table-cell\");\n        if(!model.selectionRange && clickedElem && clickedElem.matches && !clickedElem.matches(\".editor-interface\") && clickedElem.previousElementSibling && !clickedElem.previousElementSibling.matches(\".editor-interface\") && reorderCompatible(clickedElem.previousElementSibling, clickedElem) && EDITOR_VERSION & 1) {\n          addContextMenuButton(isDisplayInline ? arrowLeft : arrowUp,\n          {title: \"Move selected element \" + (isDisplayInline ? \"to the left\" : \"up\")},\n          {onclick: (c => event => {\n              let wsTxtNode = c.previousSibling && c.previousSibling.nodeType == 3 &&\n                c.previousSibling.textContent.trim() === \"\" ? c.previousSibling : undefined;\n              // There is whitespace before this element, we try to reinsert\n              c.parentElement.insertBefore(c, c.previousElementSibling);\n              if(wsTxtNode) { // We move the whitespace as well.\n                c.parentElement.insertBefore(wsTxtNode, c.previousElementSibling);\n              }\n              editor_model.clickedElem = c;\n              updateInteractionDiv();\n            })(clickedElem)\n          });\n        }\n        if(!model.selectionRange && clickedElem && clickedElem.matches && !clickedElem.matches(\".editor-interface\") && clickedElem.nextElementSibling && !clickedElem.nextElementSibling.matches(\".editor-interface\") && reorderCompatible(clickedElem, clickedElem.nextElementSibling) && EDITOR_VERSION & 1) {\n          addContextMenuButton(isDisplayInline ? arrowRight : arrowDown,\n          {title: \"Move selected element \" + (isDisplayInline ? \"to the right\" : \"down\")},\n          {onclick: (c => (event) => {\n              let wsTxtNode = c.nextSibling && c.nextSibling.nodeType == 3 && \n                c.nextSibling.textContent.trim() === \"\" ? c.nextSibling : undefined;\n              let nodeToInsertAfter = c.nextElementSibling;\n              nodeToInsertAfter.insertAdjacentElement(\"afterend\", c);\n              if(wsTxtNode) { // We move the whitespace as well\n                nodeToInsertAfter.parentElement.insertBefore(wsTxtNode, nodeToInsertAfter.nextSibling);\n              }\n              editor_model.clickedElem = c;\n              updateInteractionDiv();\n            })(clickedElem)\n          });\n        }\n        if(!model.selectionRange && clickedElem && clickedElem.tagName !== \"HTML\" && clickedElem.tagName !== \"BODY\" && clickedElem.tagName !== \"HEAD\" && EDITOR_VERSION & 1) {\n          addContextMenuButton(cloneSVG,\n            {title: \"Clone selected element\"},\n            {onclick: ((c, contextMenu) => event => {\n                c.removeAttribute(\"ghost-clicked\");\n                let cloned = duplicate(c);\n                if(cloned) {\n                  editor_model.clickedElem = cloned;\n                  updateInteractionDiv();\n                } else contextMenu.classList.remove(\"visible\");\n              })(clickedElem, contextMenu)\n            });\n          addContextMenuButton(wasteBasketSVG,\n            {title: \"Delete selected element\"},\n            {onclick: (c => event => {\n                if(editor_model.clickedElem.nextElementSibling) editor_model.clickedElem = editor_model.clickedElem.nextElementSibling;\n                else editor_model.clickedElem = editor_model.clickedElem.previousElementSibling;\n                c.remove();\n                updateInteractionDiv();\n              })(clickedElem)\n            });\n        }\n        if(model.selectionRange && (model.selectionRange.startContainer === model.selectionRange.endContainer || model.selectionRange.startContainer.parentElement === model.selectionRange.commonAncestorContainer && model.selectionRange.endContainer.parentElement === model.selectionRange.commonAncestorContainer) && EDITOR_VERSION & 1) {\n          addContextMenuButton(plusSVG,\n              {title: \"Wrap selection\"},\n              {onclick: (s => event => {\n                let elements = [];\n                let tmp = s.startContainer;\n                let nodeToInsertAfter = s.startContainer;\n                let parent = nodeToInsertAfter.parentElement;\n                while(tmp && tmp !== s.endContainer.nextSibling) {\n                  if(tmp.nodeType === 3) {\n                    elements.push(tmp === s.startContainer ? tmp === s.endContainer ? tmp.textContent.substring(s.startOffset, s.endOffset) : tmp.textContent.substring(s.startOffset) :\n                      tmp === s.endContainer ? tmp.textContent.substring(0, s.endOffset) :\n                      tmp.textContent);\n                    if(tmp === s.startContainer) {\n                      if(tmp === s.endContainer && tmp.textContent.length > s.endOffset) {\n                        // Need to split the text node.\n                        tmp.parentElement.insertBefore(document.createTextNode(tmp.textContent.substring(s.endOffset)), tmp.nextSibling);\n                      }\n                      if(s.startOffset === 0) {\n                        nodeToInsertAfter = nodeToInsertAfter.previousSibling;\n                        tmp.remove();\n                      } else {\n                        tmp.textContent = tmp.textContent.substring(0, s.startOffset);\n                      }\n                    } else if(tmp === s.endContainer) {\n                      if(s.endOffset === s.endContainer.textContent.length) {\n                        tmp.remove();\n                      } else {\n                        tmp.textContent = tmp.textContent.substring(s.endOffset);\n                      }\n                    } else {\n                      tmp.remove();\n                    }\n                  } else {\n                    elements.push(tmp);\n                    tmp.remove();\n                  }\n                  tmp = tmp.nextSibling;\n                }\n                let insertedNode = el(\"span\", {\"ghost-clicked\": \"true\"});\n                for(let k of elements) {\n                  insertedNode.append(k);\n                }\n                let nodeToInsertBefore = nodeToInsertAfter ? nodeToInsertAfter.nextSibling : parent.childNodes[0];\n                parent.insertBefore(insertedNode, nodeToInsertBefore);\n                document.querySelector(\"#modify-menu\").classList.toggle(\"visible\", true);\n                editor_model.visible = true;\n                editor_model.clickedElem = insertedNode;\n                updateInteractionDiv();\n              })(model.selectionRange)}\n              )\n        }\n        if(!model.selectionRange && EDITOR_VERSION & 1) {\n          addContextMenuButton(plusSVG,\n              {title: \"Insert element\", contenteditable: false},\n              {onclick: event => {\n                editor_model.clickedElem = clickedElem;\n                editor_model.displayClickedElemAsMainElem = true;\n                editor_model.insertElement = true;\n                editor_model.visible = true;\n                getEditorInterfaceByTitle(\"Create\").minimized = false;\n                updateInteractionDiv();\n                restoreCaretPosition();\n              }});\n        }\n        if(model.clickedElem) {\n          // Thaditor-defined custom context menu buttons\n          if(typeof thaditor === \"object\") {\n            for(let button of thaditor.customContextMenuButtons(model.clickedElem)) {\n              addContextMenuButton(button.innerHTML, button.attributes, button.properties)\n            }\n          }\n          // Page-defined custom context menu buttons\n          for(let custom of editor.customContextMenuButtons) {\n            for(let button of custom(model.clickedElem)) {\n              addContextMenuButton(button.innerHTML, button.attributes, button.properties)\n            }\n          }\n        }\n\n        let baseElem = clickedElem;\n        while(baseElem && (baseElem.tagName == \"SCRIPT\" || baseElem.tagName == \"STYLE\")) {\n          baseElem = baseElem.nextElementSibling;\n        }\n        baseElem = model.selectionRange || baseElem || clickedElem;\n      \n        if(baseElem && !noContextMenu) {\n          let clientRect = baseElem.getBoundingClientRect();\n          // Find out where to place context menu.\n          let clickedElemLeft = window.scrollX + clientRect.left;\n          let clickedElemTop = window.scrollY + clientRect.top;\n          let clickedElemBottom = window.scrollY + clientRect.bottom;\n          let clickedElemRight = window.scrollX + clientRect.right;\n          let desiredWidth = numButtons * buttonWidth();\n          let desiredLeft = (clickedElemLeft + clickedElemRight) / 2 - desiredWidth;\n          if(desiredLeft < clickedElemLeft) desiredLeft = clickedElemLeft;\n          let desiredTop = clickedElemTop - buttonHeight(); \n          if(desiredTop - window.scrollY < 9) {\n            desiredTop = clickedElemBottom;\n            if(desiredTop + buttonHeight() > window.innerHeight) {\n              desiredTop = window.innerHeight - buttonHeight(); \n            }\n          }\n          if(desiredLeft < 0) desiredLeft = 0;\n          if(desiredTop < 0) desiredTop = 0;\n          contextMenu.style.left = desiredLeft + \"px\";\n          contextMenu.style.top = desiredTop + \"px\";\n          contextMenu.style.width = desiredWidth + \"px\";\n          contextMenu.classList.add(\"visible\");\n          setTimeout(maybeRepositionContextMenu, 0);\n        }\n        if(noContextMenu) {\n          contextMenu.classList.remove(\"visible\");\n        }\n      }\n      \n      return true;\n\n    } //end of updateInteractionDiv\n\n    function maybeRepositionContextMenu() {\n      //move the context menu if overlaps with modify-menu\n       let contextMenu = document.querySelector(\"#context-menu\");\n       let modifyMenuDiv = document.querySelector(\"#modify-menu\");\n       let pinnedIcons = document.querySelector(\".modify-menu-icons.pinned\")\n       let pcr = pinnedIcons.getBoundingClientRect();\n       let ccr = contextMenu.getBoundingClientRect();\n       let mcr = modifyMenuDiv.getBoundingClientRect();\n       if(onMobile()) {\n         if(ccr.bottom > pcr.top) {\n           contextMenu.style.top = (ccr.y - (ccr.bottom - pcr.top)) + \"px\"\n         } else if(ccr.bottom > mcr.top) {\n           contextMenu.style.top = (ccr.y - (ccr.bottom - mcr.top)) + \"px\"\n         }\n       } else {\n         if(ccr.right > pcr.left && ccr.top < pcr.bottom) { // Overlap with icons.\n           contextMenu.style.left = (ccr.x - (ccr.right - pcr.left)) + \"px\"\n         } else if(ccr.right > mcr.left) {\n           contextMenu.style.left = (ccr.x - (ccr.right - mcr.left)) + \"px\"\n         }\n       }\n    }\n    \n    function editor_close() {\n      if(editor_model.visible) {\n        editor_model.visible = false;\n        updateInteractionDiv();\n        //Hide the menu\n        //This is also working fine\n        return false;\n      }\n      return true;\n    }\n    \n    // Mobile only\n    document.addEventListener(\"deviceready\", function onDeviceReady(){\n      document.addEventListener(\"backbutton\", editor_close, false);\n    }, false);\n    \n    if(editIsFalseButDefaultIsTrue) {\n      // Special case when ?edit=false but the default behavior is edit=true if nothing is set.\n      document.onclick = function (e) {\n          e = e ||  window.event;\n          var node = e.target || e.srcElement;\n          while(node) {\n            if(node.tagName == \"A\" && node.getAttribute(\"href\") && !node.onclick && !node.getAttribute(\"onclick\")) {\n             var newLocation = addEditEqualToUrl(node.getAttribute(\"href\"), \"false\");\n             console.log(newLocation);\n             window.location.href = newLocation;\n             e.stopPropagation();\n             return false;\n            } else {\n              node = node.parentNode;\n            }\n          }\n        }\n    } else if(varedit) {\n      document.addEventListener('click', onClickGlobal, false);\n      document.addEventListener('mousedown', onMouseDownGlobal, false);\n    }\n    window.addEventListener(\"error\", function (message, source, lineno, colno, error) {\n      let msg;\n      if(message instanceof ErrorEvent) {\n        msg = message.message;\n      } else {\n        msg = message + \" from \" + source + \" L\" + lineno + \"C\" + colno;\n      }\n      editor_model.editor_log.push(msg);\n    });\n    \n    function editor_canSave() {\n      return editor_model.undoStack.length !== editor_model.undosBeforeSave;\n    }\n    \n    function editor_onbeforeunload(e) {\n      e = e || window.event;\n      if(onMobile() && editor_model.visible) { // Hack to ask before saving.\n        e.preventDefault();\n        e.returnValue = '';\n        return editor_close();\n      }\n      var askConfirmation = editor_canSave() || editor_model.isSaving || editor_model.disambiguationMenu;\n      const confirmation = 'You have unsaved modifications. Do you still want to exit?';\n      // For IE and Firefox prior to version 4\n      if (e) {\n        if(askConfirmation) {\n          e.returnValue = confirmation;\n        }\n      }\n      if(askConfirmation) {\n        // For Safari\n        return confirmation;\n      } else if(!apache_server) { // Send a close message in case this was a file opened from Desktop\n        var xmlhttp = new XHRequest();\n        xmlhttp.onreadystatechange = handleServerPOSTResponse(xmlhttp);\n        xmlhttp.open(\"POST\", location.pathname + location.search, false); // Async\n        xmlhttp.setRequestHeader(\"close\", \"true\");\n        xmlhttp.send(\"{\\\"a\\\":3}\");\n      }\n    } // End of editor_onbeforeunload\n     \n    window.onbeforeunload = editor_onbeforeunload;\n    if (typeof editor_model === \"object\" && typeof editor_model.outputObserver !== \"undefined\") {\n      editor_model.outputObserver.disconnect();\n    }\n\n    editor_model.outputObserver = new MutationObserver(handleMutations);\n    editor_model.outputObserver.observe\n      ( document.body.parentElement\n      , { attributes: true\n        , childList: true\n        , characterData: true\n        , attributeOldValue: true\n        , characterDataOldValue: true\n        , subtree: true\n        }\n      );\n    \n    // Store the current child list of nodes that ignore their children totally\n    (function() {\n      var elems = document.querySelectorAll(\"*\");\n      for(var i = 0; i < elems.length; i++) {\n        if(isIgnoringChildNodes(elems[i])) {\n          cacheChildNodes(elems[i]);\n        }\n      }\n    })();\n\"\"\"--end of lastEditionScript\n\ngooglesigninbutton = serverOwned \"the google sign-in button\" [\n<style>\na.closeGoogleSignIn {\n  margin-left: 2px;\n  padding-left: 4px;\n  padding-right: 5px;\n}\na.closeGoogleSignIn:hover {\n  background: #AAA;\n  color: white;\n  border-radius: 10px;\n}\n</style>,\n<div class=\"g-signin2\" data-onsuccess=\"onGoogleSignIn\" list-ghost-attributes=\"data-gapiscan data-onload\" children-are-ghosts=\"true\"></div>,\n<script>\nfunction onGoogleSignIn(googleUser) {\n  var profile = googleUser.getBasicProfile();\n  \n  var wasSignedIn = googleAuthIdToken ? true : false;\n  // When set, will be used throughout \n  googleAuthIdToken = googleUser.getAuthResponse().id_token;\n  var addSignout = (name) => {\n    var signin = document.querySelector(\".abcRioButtonContents\").children[1];\n    signin.setAttribute(\"title\", \"Signed in as \" + name);\n    var signout = document.createElement(\"a\");\n    signout.classList.add(\"closeGoogleSignIn\");\n    signout.setAttribute(\"title\", \"Sign out\");\n    signout.innerText = \"x\";\n    signout.onclick = () => {\n      var auth2 = gapi.auth2.getAuthInstance();\n      auth2.signOut().then(() => {\n        auth2.disconnect();\n        googleAuthIdToken = undefined;\n        console.log('User signed out.');\n      });\n    }\n    signin.append(signout);\n  }\n  addSignout(profile.getName());\n  if(!wasSignedIn) { // Necessary to ensure that we don't reload the page the second time it is loaded.\n    reloadPage();\n  }\n}\n</script>,\n<script id=\"googlesigninscript\" src=\"https://apis.google.com/js/platform.js\" async defer save-ghost-attributes=\"gapi_processed\"></script>\n]\n\ndefaultMarkdowncss = \"\"\"img {\n  max-width: 100%;\n}\npre {\n  padding: 10px 0 10px 30px;\n  color: cornflowerblue;\n}\na {\n  text-decoration: none;\n  font-weight: bold;\n  color: #0268cd;\n}\np {\n  margin: 1.0em 0 1.0em 0;\n}\nbody {\n  text-align: justify;\n  font-family: Geneva, Verdana, sans-serif;\n  line-height: 1.75em;\n  background-color: #C9CFCD;\n}\nh1, h2, h3, h4 {\n  letter-spacing: -1px;\n  font-weight: normal;\n  color: #171717;\n}\nh2 {\n\tfont-size: 2.25em;\n}\nh3 {\n  padding: 25px 0 0 0;\n\tfont-size: 1.75em;\n}\nh4 {\n\tfont-size: 1.25em;\n  margin-top: 1.25em;\n}\n.wrapper {\n  margin-left: auto;\n  margin-right: auto;\n  margin-top: 10px;\n  max-width: 900px;\n  padding-left: 20px;\n  padding-right: 20px;\n  padding-top: 20px;\n  background-color: white;\n}\"\"\"\n\nmain";
const useDefaultServerContent = true;

const defaultHtAccessFileContent = `if Regex.matchIn """\\.\\.(?:/|\\\\)|(?:/|\\\\)\\.\\.|^\\.\\.$""" path then False else
    not (Regex.matchIn """.*\\.pem""" path)`

function readServerFile() {
  if(fs.existsSync(serverFile) && !useDefaultServerContent) {
    return fs.readFileSync(serverFile, "utf8");
  } else
    return defaultServerContent;
}

function readHtAccessFile() {
  if(fs.existsSync(htaccessFile)) {
    return fs.readFileSync(htaccessFile, "utf8");
  } else
    return defaultHtAccessFileContent;
}

const sns = require("sketch-n-sketch");

function evaluateToHtml(path, env, serverFileContent) {
  var result = sns.objEnv.string.evaluateWithoutCache(env)(serverFileContent);
  if(result.ctor == "Ok") {
    var out = sns.valToHTMLSource(result._0)
    if(out.ctor == "Ok") {
      return out;
    } else {
      return { ctor: "Err", _0: "Error while converting the result to HTML source file: " + out._0}
    }
  } else {
    return { ctor: "Err", _0: `Error while interpreting ${path}: ` + result._0}
  }
}

function lazyListToList(ll) {
  var x = [];
  while(sns.lazyList.nonEmpty(ll)) {
    x.push(sns.lazyList.head(ll));
    ll = sns.lazyList.tail(ll);
  }
  return x;
}

cachedSolutions = {
  key: {
     timestamp: 0,
     computed: [["html page", "environment vars", "fileOperations"],
                ["html page 2", "environment vars 2", "fileOperations 2..."]],
     remaining: "false, or a LazyList whose head element is last computed solution. Call getOneSolution(this.path, this.serverFileContent, sns.lazyList.tail(remaining)) on it to get one more solution if it exists",
     path: "The path that is being computed",
     serverFileContent: "The original source file of the server. Maybe be overwritten in fileOperations"
  }
}

// Retrieves the given solution by 1-based index from the set of solutions
// If the solution is the last computed, computes remaining solutions
function getSolutionByNum(solutionSet, num) {
  if(solutionSet.computed.length >= num && num >= 1) {
    if(solutionSet.computed.length == num) { // If we select the last computed solution, we checked if we can compute more solutions.
      if(solutionSet.remaining !== false) {
        console.log("Checking for ambiguity #" + (num + 1));
        var lt = sns.lazyList.tail(solutionSet.remaining);
        var newSolution = getOneSolution(solutionSet.path, solutionSet.serverFileContent, lt);
        if(newSolution === false) {
          console.log("No more ambiguity");
          solutionSet.remaining = false;
        } else {
          console.log("Ambiguity #" + (num + 1) + " found");
          solutionSet.remaining = lt;
          solutionSet.computed.push(newSolution);
        }
      }
    }
    return solutionSet.computed[num - 1];
  } else {
    console.log(`Requested invalid solution number ${num}. Returning the first`)
    return solutionSet.computed[0];
  }
}

function uniqueKey() {
  var potentialkey = +(new Date());
  while(typeof cachedSolutions["" + potentialkey] != "undefined") {
    potentialkey++;
  }
  return "" + potentialkey;
}

function envToVars(env) { return env.vars; }

function getOneSolution(path, serverFileContent, allSolutions) {
  if(sns.lazyList.isEmpty(allSolutions)) return false;
  var {_0: newEnv, _1: newServerFileContent} = sns.lazyList.head(allSolutions);
  if(newServerFileContent != serverFileContent) { // server file itself modified from the update method
    var d =
      sns.process(sns.objEnv.string.evaluateWithoutCache({x: serverFileContent, y: newServerFileContent})(`__diff__ x y`))(sns.valToNative)
    var diffsServerFileContent = 
      d.ctor == "Ok" ? d._0 ? d._0.args ? d._0.args._1 ? d._0.args._1.args ? d._0.args._1.args._1 ? d._0.args._1.args._1 :
        false : false : false : false : false : false;

    newEnv.fileOperations.unshift(
      leo.Tuple2(
       serverFile,
       leo.data("Write")(serverFileContent, newServerFileContent,diffsServerFileContent)
       ));
  }
  var fo = newEnv.fileOperations;
  var evaluated = evaluateToHtml(path, newEnv, newServerFileContent);
  return [evaluated, envToVars(newEnv), fo]; 
  // Evaluates everything given the temporary context of writing the files.
}

// Apply the given operations to the file system. TODO: Merge different writes to a single file.
function applyOperations(operations) {
  for(var i = 0; i < operations.length; i++) {
    var {_1: path, _2: action} = operations[i];
    if(action["$d_ctor"] == "Write") {
      fs.writeFileSync(path, action.args._2, "utf8");
    } else if(action["$d_ctor"] == "Create") {
      // TODO: Create the path if necessary
      fs.writeFileSync(path, action.args._1, "utf8");
    } else if(action["$d_ctor"] == "Rename") {
      if(path.startsWith("/")) path = path.substring(1);
      var newName = action.args._1;
      if(newName.startsWith("/")) newName = newName.substring(1);
      fs.renameSync(path, newName);
    } else if(action["$d_ctor"] == "Delete") {
      fs.unlinkSync(path);
    } else {
      console.log("unrecognized action:", action);
    }
  }
}

function stringDiffSummary(oldString, newString, stringDiffs) {
  if(stringDiffs["$d_ctor"] == "Nothing") return "[No change observed]";
  if(stringDiffs["$d_ctor"] == "Just") stringDiffs = stringDiffs.args._1;
  var listStringDiffs = stringDiffs.args._1; // It's a VStringDiffs
  var offset = 0;
  var summary = "";
  var lastLineNumber = -1;
  var lastEnd = -1;
  var lastLine = "";
  var lastLineAfterRemoved = "";
  for(var i = 0; i < listStringDiffs.length; i++) {
    var {args: {_1: start, _2: end, _3: replaced}} = listStringDiffs[i];
    var removed = oldString.substring(start, end);
    var inserted = newString.substring(start + offset, start + offset + replaced);
    var beforeRemoved = oldString.substring(0, start);
    var afterRemoved = oldString.substring(end);
    var linesBeforeRemoved = beforeRemoved.split(/\r?\n/);
    var lineNumber = linesBeforeRemoved.length;
    var charNumber = linesBeforeRemoved[linesBeforeRemoved.length - 1].length + 1;
    var lineBeforeRemoved = linesBeforeRemoved[linesBeforeRemoved.length - 1];
    var lineAfterRemoved = afterRemoved.split(/\r?\n/)[0];
    if(lineNumber === lastLineNumber) {
      summary += oldString.substring(lastEnd, start);
    } else {
      summary += lastLineAfterRemoved + "\nL" + lineNumber + "C" + charNumber + ":" +
        lineBeforeRemoved;
    }
    summary +=
          (removed === "" ? "" : "(---" + removed + "---)") +
          (inserted === "" ? "" : "(+++" + inserted + "+++)");
    lastEnd = end;
    lastLineAfterRemoved = lineAfterRemoved;
    offset += replaced - (end - start);
    lastLineNumber = lineNumber;
  }
  summary += lastLineAfterRemoved;
  return summary;
}

function relativePath(filepath) {
  return filepath.substring(path.length);
}

function fileOperationSummary(operations) {
  if(operations == null) return "";
  var summary = "";
  for(var i = 0; i < operations.length; i++) {
    var {_1: filepath, _2: action} = operations[i];
    if(summary != "") summary += "\n";
    if(action["$d_ctor"] == "Write") {
      summary += relativePath(filepath) + ": " + stringDiffSummary(action.args._1, action.args._2, action.args._3);
    } else if(action["$d_ctor"] == "Create") {
      summary += "Created " + relativePath(filepath);
    } else if(action["$d_ctor"] == "Rename") {
      summary += "Renamed " + relativePath(filepath) + " to " + action.args._1;
    } else if(action["$d_ctor"] == "Delete") {
      summary += "Deleted " + relativePath(filepath);
    } else {
      console.log("unrecognized action:", action);
    }
  }
  return summary;
}

function detectHydefile($name) {
  if($name.length > 0 && $name.substring($name.length - 1,  $name.length) === "/") {
    $name = $name.substring(0, $name.length - 1);
  }
  let $hydefile = null, $result;
  while($name.length > 0) {
    $namex = $name == "" ? "" : `${$name}/`;
    if(fs.existsSync($namex+"hydefile.leo")) {
      $hydefile = $namex+"hydefile.leo"; break;
    }
    if(fs.existsSync($namex+"hydefile.elm")) {
      $hydefile = $namex+"hydefile.elm"; break;
    }
    if(fs.existsSync($namex+"hydefile")) {
      $hydefile = $namex+"hydefile"; break;
    }
    $newname = $name.replace(/\/[^\/]*$/,"");
    if($newname === $name) { // No more slashes
      $name = "";
    } else {
      $name = $newname;
    }
  }
  if($hydefile != null) {
    $result = {file : $hydefile};
    if(fs.existsSync($namex+".hydecache")) {
      $result["cache"] = fs.readFileSync($namex+".hydecache", "utf8");
      $result["cachefile"] = $namex+".hydecache";
    }
  } else {
    $result = {};
  }
  return $result;
}

function pushResultOn(array) {
  return name => { array.push(name); return 0 }
}

// Returns a [Result of string containing the requested page, new overrides]
// If newvalue is defined, performs an update before returning the page.
function loadpage(path, vars, user, newvalue) {
  // __dirname = path.resolve(); // If in the REPL
  if(typeof vars != "object") vars = {};
  var serverFileContent = readServerFile();
  var hydefilecache = defaultOptions.hyde ? detectHydefile(path) : undefined;
  console.log("hydefilecache", hydefilecache)
  var filesToWatch = [];
  var foldersToWatch = [];
  var generatedFiles = [];
  var writtenFiles = [];
  var env = {
      googleClientId: googleClientId,
      vars: vars,
      user: toLeoQuery(user || {}),
      defaultOptions: toLeoQuery(defaultOptions).concat(
          hydefilecache ? [leo.Tuple2("hydefilecache", hydefilecache)] : []),
      path: path,
      fileOperations: [] };
  if(hydefilecache) {
    env["recordFileRead"] = pushResultOn(filesToWatch);
    env["recordFolderList"] = pushResultOn(foldersToWatch);
    env["recordOutputFiles"] = tuplesToWrite => {
      writtenFiles = tuplesToWrite.map(({_1}) => _1);
      alwaysWriteAll(tuplesToWrite);
      return 0;
    }
  }
  if(typeof newvalue == "undefined") {
    let result = [evaluateToHtml(path, env, serverFileContent), vars];
    if(hydefilecache.cache) {
      console.log("overriding cache", [filesToWatch, foldersToWatch, writtenFiles, hydefilecache.cachefile]);
      let newCacheContent =
            sns.valToNative(sns.objEnv.string.evaluateWithoutCache(
              {a: {inputFiles: filesToWatch,
                   inputFolders: foldersToWatch,
                   outputFiles: writtenFiles
               }})("toString a")._0)._0;
      console.log("set cache to write");
      alwaysWrite(hydefilecache.cachefile, newCacheContent);
    }
    return result;
  } else { // We update the page and re-render it.
    var newVal = sns.nativeToVal(newvalue);
    console.log("Started to update...");
    var result = sns.objEnv.string.updateWithoutCache(env)(serverFileContent)(newVal);
    console.log("Update finished (first solution)");
    if(result.ctor == "Ok") {
      var allSolutions = result._0;
      // Instead of iterating through all the solutions, just detect if there is an ambiguity.
      var solution = getOneSolution(path, serverFileContent, allSolutions);
      if(solution === false) {
        return [{ctor: "Err", _0: "Empty list of solutions"}];
      } else {
        console.log("Checking for ambiguities");
        var allSolutionsTail = sns.lazyList.tail(allSolutions);
        var solution2 = getOneSolution(path, serverFileContent, allSolutionsTail);
        if(solution2 === false) { // No ambiguity, we can immediately process the change.
          console.log("No ambiguity");
          return solution;
        } else {
          console.log("Ambiguity found");
          var solutionKey = uniqueKey();
          var cachedSolution = {
              timestamp: (+ new Date()),
              computed: [solution, solution2],
              remaining: allSolutionsTail,
              path: path,
              serverFileContent: serverFileContent
          }
          cachedSolutions[solutionKey] = cachedSolution;
          return solution.concat(solutionKey);
        }
      }
    } else return [result];
  }
}

function toLeoQuery(query) {
  var result = [];
  for(key in query) {
    result.push(leo.Tuple2(key, query[key]));
  }
  return result;
}

var willkill = undefined;

var key = fs.existsSync(defaultOptions.key) ? fs.readFileSync(defaultOptions.key) : null;
var cert = fs.existsSync(defaultOptions.cert) ? fs.readFileSync(defaultOptions.cert) : null;
var httpsOptions = { key: key, cert: cert };
var protocol = key && cert ? "https" : "http";
var httpOrHttps = require(protocol);
if(protocol == "http") {
  console.log(`${defaultOptions.key} (--key) and/or ${defaultOptions.cert} (--cert) files missing. Starting http server instead of https.`);
}

function combinePath(prefix, path) {
  return (prefix == "" ? "." : prefix) + "/" + (path && path.length && path[0] === "/" ? path.substring(1) : path);
}

function alwaysWrite($name, $content) {
  if (!fs.lstatSync($name).isDirectory(fspath.dirname($name))) {
    fs.mkdirSync(fspath.dirname($name), { recursive: true });
  }
  fs.writeFileSync($name, $content, "utf8");
}

function alwaysWriteAll($toWrite, callback) {
  for(let $nameContent of $toWrite) {
      alwaysWrite($nameContent._1, $nameContent._2);
      if(callback) callback($nameContent);
  }
}

const server = httpOrHttps.createServer(httpsOptions, (request, response) => {
  var requestURL = request.headers["url"] ? request.headers["url"] : request.url; // Possibility to override the URL.
  var urlParts = url.parse(requestURL, parseQueryString=true);
  var query = toLeoQuery(urlParts.query);
  var pn = urlParts.pathname;
  var path = decodeURIComponent(pn.length && pn[0] == "/" ? pn.substring(1) : pn); // Without the slash.
  var accessResult = sns.objEnv.string.evaluateWithoutCache({path:path,method:request.method})(readHtAccessFile());
  var access = sns.process(accessResult)(sns.valToNative);
  var header = 'text/html; charset=utf-8';
  if(access.ctor == "Err") {
    console.log("Error in htaccess", access._0);
    response.setHeader('Content-Type', header);
    response.statusCode = 500;
    response.end(`<html><body style="color:#cc0000"><div   style="max-width:600px;margin-left:auto;margin-right:auto"><h1>htaccess.elm internal Error report</h1><pre style="white-space:pre-wrap">${access._0}</pre></div></body></html>`);
  } else if(access._0) {
    if(typeof willkill != "undefined") {
      clearTimeout(willkill);
      willkill = undefined;
    }
    if(request.method == "GET") {
      let $action = request.headers["action"];
      let $name = request.headers["name"];
      if(typeof $action != "undefined" && typeof $name != "undefined") { // AJAX requests to read info from the file system
        if($name.substring(0, 1) === "/") {
          $name = $name.substring(1);
        }
        if($action == "isdir") {
          response.statusCode = 200;
          if($name == "") $name = ".";
          response.end(fs.existsSync($name) && fs.lstatSync($name).isDirectory() || $name == "." || $name == ""  ? "true" : "false");
          return;
        } else if($action == "isfile") {
          response.statusCode = 200;
          response.end(fs.existsSync($name) && fs.lstatSync($name).isFile() ? "true" : "false");
          return;
        } else if($action == "listdir") {
          response.statusCode = 200;
          if($name == "") $name = ".";
          response.end(JSON.stringify((fs.readdirSync($name) || []).filter(i => i != "." && i != "..")));
          return;
        } else if($action == "read") {
          response.statusCode = 200;
          if(fs.existsSync($name)) {
            response.end("1" + fs.readFileSync($name));
          } else {
            response.end("0");
          }
          return;
        } else if ($action=="fullListDir") {
          if($name == "") $name = ".";
          let $result =
            (fs.readdirSync($name, {withFileTypes: true}) || [])
            .filter(f => f.name != "." && f.name != "..")
            .map(f => [f.name, f.isDirectory()]);
          response.statusCode = 200
          response.end(JSON.stringify($result));
          return;
        } else {
          response.statusCode = 500;
          response.end("Unsupported read action for this user: $action, $userId"); 
          return;
        }
      }
      var header = path.endsWith(".ico") ? "image/ico" : header;
      var header = path.endsWith(".jpg") ? "image/jpg" : header;
      var header = path.endsWith(".gif") ? "image/gif" : header;
      var header = path.endsWith(".png") ? "image/png" : header;
      var header = path.endsWith(".svg") ? "image/svg+xml" : header;
      var header = path.endsWith(".css") ? "text/css; charset=utf-8" : header;
      if(!header.startsWith("image/") && !header.startsWith("text/css")) {
        var [htmlContent] = loadpage(path, query, undefined);
        response.setHeader('Content-Type', header);
        response.statusCode = 200;
        if(htmlContent.ctor == "Err") {
          response.end(`<html><body style="color:#cc0000"><div   style="max-width:600px;margin-left:auto;margin-right:auto"><h1>Internal Error report</h1><pre style="white-space:pre-wrap">${htmlContent._0}</pre></div></body></html>`);
        } else {
          response.end(htmlContent._0);
        }
      } else {
        response.setHeader('Content-Type', header);
        let expectedFilePath = combinePath(defaultOptions.path, path);
        if(fs.existsSync(expectedFilePath)) {
          var content = fs.readFileSync(expectedFilePath);
          response.statusCode = 200;
          response.end(content);
        } else {
          response.statusCode = 404;
          response.end(`<html>body>${path} not found</body></html>`);
        }
      }
    } else if(request.method == "POST") {
      const chunks = [];
      request.on('data', chunk => chunks.push(chunk));
      request.on('end', function () {
        var allChunks = Buffer.concat(chunks);
        // Start ajax requests to modify the file system.
        let $action = request.headers["action"];
        let $name = request.headers["name"];
        if(typeof $action != "undefined" && typeof $name != "undefined") {
          $content = allChunks.toString();
          if($action == "write" || $action == "create") {
            if (!fs.lstatSync($name).isDirectory(fspath.dirname($name))) {
              fs.mkdirSync(fspath.dirname($name), { recursive: true });
            }
            fs.writeFileSync($name, $content, "utf8");
            response.statusCode = 200;
            if($action == "create") {
              response.end(`Written ${$name}`);
            } else {
              response.end(`Created ${$name}`);
            }
            return;
          } else if($action == "writeall") {
            let $toWrite = JSON.parse($content);
            let $i = 0;
            let msg = "";
            alwaysWriteAll($toWrite, $nameContent => {
              msg += "Written " + $nameContent._1 + "\n";
             $i = $i + 1;
            });
            response.end(msg + `\n$i files written`);
          } else if($action == "rename") {
            fs.renameSync($name, $content);
            response.statusCode = 200;
            response.end(`Renamed ${$name} to ${$content}`);
            return;
          } else if($action == "delete") {
            fs.unlinkSync($name);
            response.statusCode = 200;
            response.end(`Deleted ${$name}`);
            return;
          } else {
            response.statusCode = 500;
            response.end(`Unsupported write action for this user: ${$action}, ${userId}`)
            return;
          }
        } else if(request.headers["location"]) { // File overwriting
          $location = request.headers["location"];
          $location = $location.length && $location[0] == "/" ? $location.substring(1) : $location;
          $content = allChunks.toString();
          responde.send(`Writing ${location} whatever received on POST data`);
          fs.writeFileSync($location, $content, "utf8");
          responde.end(`Finished to write to $location`);
          return;
        }
        // End ajax requests

        if(defaultOptions.closeable && request.headers["close"]) {
          willkill = setTimeout(() => process.exit(), timeBeforeExit); // Kills the server after 2 seconds if the webpage is not requested.
          response.statusCode = 200;
          response.end('');
          return;
        } else if(request.headers["write-file"]) { // With this and with the correct permissions, we can overwrite any file.
          console.log("going to write file");
          // Just a file that we write on disk.
          var imageType = request.headers["write-file"];
          var imageLocation = combinePath(defaultOptions.path, path);
          console.log("going to write image file to ", imageLocation);
          fs.writeFileSync(imageLocation, allChunks);
          response.statusCode = 201;
          response.end('');
          return;
        }
        
        var continueWithLoading = (userdata) => {
          var canAskQuestion = (request.headers["question"] || urlParts.query["question"] || (defaultOptions.questions ? "true" : "false")) == "true";
          var body =  allChunks.toString();
          var ambiguityKey = request.headers["ambiguity-key"];
          var numberOfSolutionsSoFar = 2; // Only if Ambiguity-Key is set.
          var numSolutionSelected = 1;
          var htmlContent = {ctor:"Err", _0: "Not yet defined"};
          var newQuery = [];
          var fileOperations = [];
          var ambiguitiesSummary = [];
          if(ambiguityKey !== null && typeof ambiguityKey !== "undefined") {
            var selectAmbiguityStr = request.headers["select-ambiguity"];
            if(selectAmbiguityStr != null) {
              numSolutionSelected = JSON.parse(selectAmbiguityStr);
              var solutionSet = cachedSolutions[ambiguityKey];
              if(typeof solutionSet != "undefined") {
                [htmlContent, newQuery, fileOperations] = getSolutionByNum(solutionSet, numSolutionSelected);
                numberOfSolutionsSoFar = solutionSet.computed.length;
                ambiguitiesSummary = solutionSet.computed.map(a => fileOperationSummary(a[2]));
              } else {
                htmlContent = {ctor:"Err", _0: "Solution set not found"};
              }
            } else {
              var acceptAmbiguityStr = request.headers["accept-ambiguity"];
              if(acceptAmbiguityStr != null) {
                var acceptAmbiguity = JSON.parse(acceptAmbiguityStr);
                var solutionSet = cachedSolutions[ambiguityKey];
                [htmlContent, newQuery, fileOperations] = getSolutionByNum(solutionSet, acceptAmbiguity);
                ambiguityKey = undefined;
              } else {
                var cancelAmbiguityStr = request.headers["cancel-ambiguity"];
                if(cancelAmbiguityStr != null) {
                  ambiguityKey = undefined;
                  [htmlContent, newQuery, fileOperations] = loadpage(path, query, userdata);
                  fileOperations = [];
                } else {
                  htmlContent = {ctor:"Err", _0: "Solution set not found."};
                }
              }
            }
          } else if(request.headers["reload"]) {
            [htmlContent, newQuery, fileOperations] = loadpage(path, query, userdata);
          } else {
            var pushedValue = JSON.parse(body);
            [htmlContent, newQuery, fileOperations, ambiguityKey] = loadpage(path, query, userdata, pushedValue);
          }
          response.statusCode = 201;
          response.setHeader('Content-Type', 'text/html; charset=utf-8');
          if(htmlContent.ctor == "Err") {
            response.end(`<html><body style="color:#cc0000"><div   style="max-width:600px;margin-left:auto;margin-right:auto"><h1>Internal Error report</h1><pre style="white-space:pre-wrap">${htmlContent._0}</pre></div></body></html>`)
          } else {
            if(typeof request.headers["url"] === "string") {
              response.setHeader("New-Local-URL", request.headers["url"]);
            }
            response.setHeader('New-Query', JSON.stringify(newQuery));
            if(ambiguityKey != null && typeof ambiguityKey != "undefined" &&
               !path.endsWith(".html") && canAskQuestion &&
               (urlParts.query["edit"] == "true" || (urlParts.query["edit"] == null && defaultOptions.edit))) {
              var solutionSet = cachedSolutions[ambiguityKey];
              var ambiguityEnd = solutionSet.remaining === false;
              ambiguitiesSummary = solutionSet.computed.map(a => fileOperationSummary(a[2]));
              response.setHeader('Ambiguity-Key', ambiguityKey);
              response.setHeader('Ambiguity-Number', JSON.stringify(numberOfSolutionsSoFar));
              response.setHeader('Ambiguity-Selected', JSON.stringify(numSolutionSelected));
              response.setHeader('Ambiguity-Summaries', JSON.stringify(ambiguitiesSummary));
              response.setHeader('Ambiguity-End', ambiguityEnd ? "true" : "false");
            } else {
              if(fileOperations) {
                applyOperations(fileOperations);
                response.setHeader('Operations-Summary', encodeURI(fileOperationSummary(fileOperations)));
              }
            }
            response.end(htmlContent._0);
          }
        }
        
        var token = request.headers["id-token"];
        if(token) {
          const {OAuth2Client} = require('google-auth-library');
          const client = new OAuth2Client(googleClientId);
 
          async function verify() {
            const ticket = await client.verifyIdToken({
                idToken: token,
                audience: googleClientId // Array of client ids if multiple clients access the backend.
            });
            const userdata = ticket.getPayload();
            continueWithLoading(userdata); // Only authenticated users can access their information. Great!
          }
          verify().catch(err => {
            console.log(err);
            continueWithLoading(undefined);            
          });
          return;
        } else {
          continueWithLoading(undefined);
        }
      });
    } else {
      response.statusCode = 400;
      response.end("Unknown method");
    }
  } else {
    response.statusCode = 401;
    response.end(`<html><body style="color:#cc0000"><div   style="max-width:600px;margin-left:auto;margin-right:auto"><h1>Unauthorized access to ${path}</h1></div></body></html>`);
  }
});

port = await getPort({host: hostname, port: [port, 3000, 3001, 3002, 3003, 3004]})

// Load the Elm program into our namespace.
server.listen(port, hostname, () => {
  console.log("Editor Server serving path " + defaultOptions.path);
  if(defaultOptions.edit) {
    console.log("Edit mode:     activated.    (toggle option: 'edit=false')");
  } else {
    console.log("Edit mode:     deactivated.  (toggle option: 'edit=true')");
  }
  if(defaultOptions.autosave) {
    console.log("Autosave mode: activated.    (toggle option: 'autosave=false')");
  } else {
    console.log("Autosave mode: deactivated.  (toggle option: 'autosave=true')");
  }
  if(defaultOptions.question) {
    console.log("Questions:     activated.    (toggle option: 'question=false')");
  } else {
    console.log("Questions:     deactivated.  (toggle option: 'question=true')");
  }
  console.log("To toggle any of these options in the browser, join these toggle options using '&', prefix this with '?', and append the result to any URL, ");
  console.log(`Point your browser at ${protocol}://${hostname}:${port}`);
});

if(fileToOpen) {
  var opn = require('opn');

  // opens the url in the default browser 
  opn(protocol + "://" + hostname + ":" + port + "/" + fileToOpen);
} else if(defaultOptions.openbrowser) {
  var opn = require('opn');

  // opens the url in the default browser 
  opn(protocol + "://" + hostname + ":" + port);
}
} // async declaration of start()

// Never called when starting the server from command-line.
module.exports = function(requireOptions) {
  if(!requireOptions) {
    start();
    return;
  } else {
    for(var k in requireOptions) {
      defaultOptions[k] = requireOptions[k];
    }
    start();
    return;
  }
}


