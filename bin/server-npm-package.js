
var params = process.argv.slice(2);

function getParam(x, defaultValue) {
  var param = params.find(elem => elem.startsWith(x));
  if(typeof param !== "undefined") {
    var returnValue = param.substring(x.length + 1);
    if(returnValue == "") return defaultValue;
    return returnValue;
  } else {
    return defaultValue;
  }
}

function existsParam(x) {
  var param = params.find(elem => elem == x);
  return typeof param !== "undefined";
}

function isBoolParamTrue(x) {
  return existsParam(x) || getParam(x, "false") == true;
}

function getNonParam() {
  return params.find(elem => !elem.startsWith("-"))
}

const fs = require("fs");
const https = require('https');
//const http = require('http');
const url = require('url');
const hostname = getParam("hostname", 'localhost');
var port = parseInt(getParam("port", "3000"));

// The default client id is suitable only for localhost:3000
var googleClientId = getParam("google-client-id", "844835838734-2iphm3ff20ephn906md1ru8vbkpu4mg8.apps.googleusercontent.com");

const getPort = require('get-port');

const serverFile = "./server.elm";
const htaccessFile = "./htaccess.elm";
var path =  getParam("--path",    "");
var question = getParam("--question", "true") == "true";
var autosave = getParam("--autosave", "false") == "true";

var fileToOpen = getNonParam();
if(fileToOpen) {
  if(fileToOpen.indexOf("/") == -1 && fileToOpen.indexOf("\\") == -1) {
    path = "";
  } else {
    path = fileToOpen.replace(/[\/\\][^\/\\]*$/g, "");
  }
  fileToOpen = fileToOpen.replace(/.*[\/\\](?=[^\/\\]*$)/g, "");
  question = false; // When opening a file, by default we should not ask questions.
  autosave = false; // When opening a file, by default we want to let the user save it.
}
var timeBeforeExit = 2000; // Number of ms after receiving the closing signal (if file open) to kill the server.

var defaultOptions = {
  edit:     getParam("--edit",     "true") == "true",
  autosave: autosave,
  question: question,
  admin:    isBoolParamTrue("--admin"),
  production:    isBoolParamTrue("--production"),
  path:     path,
  closeable: !(!(fileToOpen)),
  openbrowser: isBoolParamTrue("--openbrowser"),
  key: "localhost-key.pem",
  cert: "localhost.pem"
};

async function start() {

// Don't modify, this will be replaced by the content of 'server.elm'
const defaultServerContent = "-- input: path            The file to serve.\n-- input: vars:           URL query vars.\n-- input: defaultOptions  default options (options that vars can override for certain parts).\n--                        If nodefs is set, will use it instead of nodejs.nodeFS\n--                        If browserSide is set, will use a different kind of request. \n-- input: fileOperations  The current set of delayed file disk operations.\n--    Note that Elm pages are given in context the path, the vars, and the file system (fs) to read other files\n-- output: The page, either (almost) uninstrumented or augmented with the toolbar and edit scripts.\n\n{--------------------------------------------------------\n    Permission handling, file system, options processing\n---------------------------------------------------------}\nlistGetOrElse key listDict default = listDict.get key listDict |> Maybe.withDefault default\n\npreludeEnv = let _ = googlesigninbutton in -- Forces googlesigninbutton to be evaluated before preludeEnv\n  __CurrentEnv__\n\nmbApplyPrefix = case listDict.get \"path\" defaultOptions of\n  Just \"\" -> Nothing\n  Nothing -> Nothing\n  Just prefix -> Just (\\name -> if name == \"\" then prefix\n      else if Regex.matchIn \"/$\" prefix then prefix + name\n      else prefix + \"/\" + name)\n\ndirectReadFileSystem =\n  listDict.get \"nodefs\" defaultOptions |> Maybe.withDefault nodejs.nodeFS\n\nfs = nodejs.delayedFS directReadFileSystem fileOperations\n\nfs = case mbApplyPrefix of\n  Nothing -> fs\n  Just applyPrefix -> { fs |\n    read name = fs.read (applyPrefix name)\n    listdir name = fs.listdir (applyPrefix name)\n    listdircontent name = fs.listdircontent (applyPrefix name)\n    isdir name = fs.isdir (applyPrefix name)\n    isfile name = fs.isfile (applyPrefix name)\n  }\n\neditdelay = 1000\n\nboolVar name resDefault =\n  listDict.get name vars |>\n  Maybe.map (\\original ->\n    Update.bijection\n      (case of \"true\" -> True; \"\" -> True; _ -> False)\n      (case of True -> if original == \"true\" || original == \"\" then original else \"true\"; _ -> \"false\") original) |>\n  Maybe.withDefaultReplace (\n    listDict.get name defaultOptions |> Maybe.withDefault resDefault |> freeze)\n\nvaradmin = boolVar \"admin\" False\nvaredit = boolVar \"edit\" True\ndefaultVarEdit = listDict.get \"edit\" defaultOptions |> Maybe.withDefault False\nvarproduction = listDict.get \"production\" defaultOptions |> Maybe.withDefault (freeze False)\niscloseable = listDict.get \"closeable\" defaultOptions |> Maybe.withDefault (freeze False)\n\nuserpermissions = {pageowner= True, admin= varadmin}\npermissionToCreate = userpermissions.admin\npermissionToEditServer = userpermissions.admin -- should be possibly get from user authentication\n-- List.contains (\"sub\", \"102014571179481340426\") user -- That's my Google user ID.\n\ncanEditPage = userpermissions.pageowner && varedit\n\n{freezeWhen} = Update\n\nserverOwned what = freezeWhen (not permissionToEditServer) (\\od -> \"\"\"You tried to modify @what, which is part of the server. We prevented you from doing so.<br><br>\n\nIf you really intended to modify this, add ?admin=true to the URL and redo this operation. This is likely going to create or modify the existing <code>server.elm</code> at the location where you launched Editor.<br><br>\n\nFor debugging purposes, below is the new value that was pushed:\n<pre>@(Regex.replace \"<\" (always \"&lt;\") \"\"\"@od\"\"\")</pre>\n\"\"\")\n\ncanEvaluate = listDict.get \"evaluate\" vars |> Maybe.withDefaultReplace (serverOwned \"default value of evaluate\" \"true\")\n\n{--------------------------------------------------------\n Rewrite path to either a folder or a default file under\n---------------------------------------------------------}\n\npath: String\npath =\n  if fs.isdir path then\n   if listDict.get \"ls\" vars /= Just \"true\" then\n     List.mapFirstSuccess (\\test ->\n       if fs.isfile <| path + test then Just (path + test) else Nothing)\n       [\"index.elm\" , \"/index.elm\", \"index.html\", \"/index.html\", \"README.md\" , \"/README.md\" ]\n     |> Maybe.withDefault path\n   else path\n  else path\n\n{---------------------------------------------------------------------------\n Retrieves the string content of the path. For folders, creates a custom page\n----------------------------------------------------------------------------}\n\n(sourcecontent, folderView): (String, Boolean)\n(sourcecontent, folderView) = Tuple.mapFirst String.newlines.toUnix <|\n  if path == \"server.elm\" then\n    (\"\"\"<html><head></head><body>The Elm server cannot display itself. This is a placeholder</body></html>\"\"\", False)\n  else\n    if fs.isdir path then\n      flip (,) True <|\n      let\n        pathprefix = if path == \"\" then path else path + \"/\"\n        maybeUp = case Regex.extract \"^(.*)/.*$\" path of\n          Just [prev] -> \"\"\"<li><a href=\"/@prev\">..</li> :: \"\"\"\n          _ -> if path == \"\" then \"\" else \"\"\"<li><a href=\"/\" contenteditable=\"false\">..</li> ::\"\"\"\n      in\n      \"\"\"\n      <html><head></head><body><h1><a href=''>/@path</a></h1>\n      @@([\"ul\", [], @maybeUp (List.map (\\name -> <li><a href=(\"/@pathprefix\" + name)>@@name</li>) (fs.listdir path))])\n      Hint: place a\n      <a href=(\"/@(pathprefix)README.md?edit=true\")  contenteditable=\"false\">README.md</a>,\n      <a href=(\"/@(pathprefix)index.html?edit=true\") contenteditable=\"false\">index.html</a> or\n      <a href=(\"/@(pathprefix)index.elm?edit=true\")  contenteditable=\"false\">index.elm</a>\n      file to display something else than this page.</body></html>\"\"\"\n    else\n      flip (,) False <|\n      if fs.isfile path && Regex.matchIn \"\"\"\\.(png|jpg|ico|gif|jpeg)$\"\"\" path then -- Normally not called because server.js takes care of these cases.\n        \"\"\"<html><head><title>@path</title></head><body><img src=\"@path\"></body></html>\"\"\"\n      else\n        fs.read path\n      |> Maybe.withDefaultReplace (\n        serverOwned \"404 page\" \"\"\"<html><head></head><body>@(\n            if permissionToCreate then \"\"\"<span>@path does not exist yet. Modify this page to create it!</span>\"\"\" else \"\"\"<span>Error 404, @path does not exist or you don't have admin rights to modify it (?admin=true)</span>\"\"\"\n          )</body></html>\"\"\"\n      )\n\n{---------------------------------------------------------------------------\n Evaluates the page according to the path extension.\n - Wraps html pages to parse them as raw html\n - Interprets markdown pages and evaluate them as raw html with CSS\n - Directly evaluate sources from elm/leo pages or folders\n----------------------------------------------------------------------------}\nevaluatedPage: Result String Html\nevaluatedPage =\n  if canEvaluate /= \"true\" then\n    Ok <html><head></head><body>URL parameter evaluate=@(canEvaluate) requested the page not to be evaluated</body></html>\n  else\n  let isPhp = Regex.matchIn \"\"\"\\.php$\"\"\" path in\n  let isHtml = Regex.matchIn \"\"\"\\.html$\"\"\" path in\n  if isHtml || isPhp then\n    let sourcecontent = if isHtml then sourcecontent else\n      let phpToElm =\n        let phpStringToElmString =\n          (Regex.replace \"\"\"(\\\")([^\\\"]*)(\\\")\"\"\" <| \\m ->\n            nth m.group 1 +\n            (nth m.group 2\n            |> Regex.replace \"\"\"\\$[0-9a-zA-Z_]*\"\"\" (\\n ->\n               freeze \"\\\" + \" + nth n.group 0 + freeze \" + \\\"\")) +\n            nth m.group 3) >>\n          (Regex.replace \"\"\"\\$_GET\\[([^\\]]*)\\]\"\"\" <| \\m ->\n            freeze \"listDict.get \"+ nth m.group 1 + freeze \" $_GET |> Maybe.withDefaultReplace ''\"\n          )\n        in\n        \\string ->\n        string |>\n        Regex.replace \"\"\"<\\?php\\s+echo\\s+([^;]+?);\\s+\\?>\"\"\"\n           (\\m -> freeze \"@(\" + nth m.group 1 + freeze \")\") |>\n        Regex.replace \"\"\"^\\s*<\\?php(\\s+(?:(?!\\?>)[\\s\\S])*)\\?>([\\s\\S]*)$\"\"\"\n          (\\m ->\n            nth m.group 1 \n            |> Regex.replace \"\"\"(\\r?\\n\\s*)(\\$[0-9a-zA-Z_]*\\s*=\\s*)((?:(?!;).)*)(;)\"\"\"\n                 (\\assign -> (nth assign.group 1) +\n                   freeze \"let \" +\n                   (nth assign.group 2) +\n                   phpStringToElmString (nth assign.group 3) +\n                   freeze \" in\")\n            |> (\\res -> res + freeze \" \" + String.q3 + nth m.group 2 + String.q3))\n      in\n      let elmSourceContent = phpToElm sourcecontent in\n      __evaluate__ ((\"$_GET\", vars)::(\"path\", path)::(\"fs\", fs)::preludeEnv) elmSourceContent |>\n      case of\n        Err msg -> serverOwned \"error message\" \"<html><head></head><body><pre>Error elm-reinterpreted php: \" + msg + \"</pre></body></html>\"\n        Ok sourcecontent -> sourcecontent\n    in\n    let interpretableData =\n          case Regex.extract \"\"\"^\\s*<!DOCTYPE(?:(?!>)[\\s\\S])*>([\\s\\S]*)$\"\"\" sourcecontent of\n            Just [interpretableHtml] -> serverOwned \"begin raw tag\" \"<raw>\" + interpretableHtml + serverOwned \"end raw tag\" \"</raw>\"\n            _ ->\n          case Regex.extract \"\"\"^[\\s\\S]*?(<html\\b[\\s\\S]*)$\"\"\" sourcecontent of\n            Just [interpretableHtml] -> serverOwned \"begin raw tag\" \"<raw>\" + interpretableHtml + serverOwned \"end raw tag\" \"</raw>\"\n            _ -> serverOwned \"raw display of html - beginning\" \"\"\"<raw><html><head></head><body>\"\"\" + sourcecontent + serverOwned \"raw display of html - end\" \"\"\"</body></html></raw>\"\"\"\n    in\n    __evaluate__ preludeEnv interpretableData\n    |> Result.andThen (case of\n      [\"raw\", _, nodes] ->\n        case List.find (case of [\"html\", _, _] as n -> True; _ -> False) nodes of\n          Just n -> Ok n\n          Nothing -> Err \"\"\"No top-level HTML node found\"\"\" \n      result -> Err \"\"\"Html interpretation error: The interpretation of raw html did not work but produced @result\"\"\"\n    )\n  else if Regex.matchIn \"\"\"\\.md$\"\"\" path then\n    let markdownized = String.markdown sourcecontent in\n      case Html.parseViaEval markdownized of\n        x -> \n          let markdownstyle = fs.read \"markdown.css\" |> Maybe.withDefaultReplace defaultMarkdowncss in\n          Ok <html><head></head><body><style title=\"If you modify me, I'll create a custom markdwon.css that will override the default CSS for markdown rendering\">@markdownstyle</style><div class=\"wrapper\">@x</div></body></html>\n  else if Regex.matchIn \"\"\"\\.(elm|leo)$\"\"\" path || fs.isdir path then\n    __evaluate__ ((\"vars\", vars)::(\"path\", path)::(\"fs\", fs)::preludeEnv) sourcecontent\n  else if Regex.matchIn \"\"\"\\.txt$\"\"\" path then\n    Ok <html><head></head><body>\n      <textarea id=\"thetext\" style=\"width:100%;height:100%\" initdata=@sourcecontent\n        onkeyup=\"if(this.getAttribute('initdata') !== this.value) this.setAttribute('initdata', this.value)\"></textarea>\n      <script>\n        document.getElementById('thetext').value = document.getElementById('thetext').getAttribute('initdata')\n      </script>\n    </body></html>\n  else Err \"\"\"Serving only .html, .md and .elm files. Got @path\"\"\"\n\n{---------------------------------------------------------------------------\n Recovers from evaluation errors\n----------------------------------------------------------------------------}\nrecoveredEvaluatedPage: Html\nrecoveredEvaluatedPage = case evaluatedPage of\n  Err msg -> serverOwned \"Error Report\" <|\n    <html><head></head><body style=\"color:#cc0000\"><div style=\"max-width:600px;margin-left:auto;margin-right:auto\"><h1>Error report</h1><pre style=\"white-space:pre-wrap\">@msg</pre></div></body></html>\n  Ok page -> page\n\n{---------------------------------------------------------------------------\n Instruments the resulting HTML page\n - Removes whitespace that are siblings of <head> and <body>\n - !f the page is editable:\n   * Adds the contenteditable attribute to body\n   * Adds the edition menu and the source preview area\n - Else: Adds the \"edit\" box to switch to edit mode\n - Adds the initial scripts\n - Append the edition scripts so that we can modify the page even without edit mode (that's dangerous, should we avoid this?)\n----------------------------------------------------------------------------}\nmain: Html\nmain = case recoveredEvaluatedPage of\n  [\"html\", htmlattrs, htmlchildren] -> [\"html\", htmlattrs, htmlchildren |>\n    List.filter (case of [_, _] -> False; _ -> True) |>\n    List.mapWithReverse identity (case of\n      [\"body\", bodyattrs, bodychildren] ->\n        [\"body\",\n           (if canEditPage then\n             [[\"contenteditable\", \"true\"]] |> serverOwned \"contenteditable attribute of the body due to edit=true\" \n            else freeze []) ++\n           bodyattrs,\n          (if canEditPage then ((serverOwned \"edition menu\" editionmenu) sourcecontent ++ Update.sizeFreeze [(serverOwned \"code preview box\" codepreview) sourcecontent]) else\n           if not varedit && not iscloseable && not varproduction then serverOwned \"open edit box\" [openEditBox] else\n           serverOwned \"edit prelude when not in edit mode\" []) ++\n           serverOwned \"initial script\" initialScript ++\n           bodychildren ++\n           (serverOwned \"synchronization script and placeholder\" [<script>@editionscript</script>, <div class=\"bottom-placeholder\"> </div>])]\n      x -> x -- head\n    )]\n  x-> <html><head></head><body>Not a valid html page: @(\"\"\"@x\"\"\")</body></html>\n  --|> Update.debug \"main\"\n\n{---------------------------------------------------------------------------\n Definitions for the pipeline above\n----------------------------------------------------------------------------}\n  \n-- Box to switch to edit mode.\nswitchEditBox toEdit = \n  let prev = if toEdit then \"false\" else \"true\"\n      next = if toEdit then \"true\" else \"false\"\n      msg = if toEdit then \"edit\" else \"x\"\n      title = if toEdit then \"Reload the page in edit mode\" else \"Reload the page without edit mode\" in\n<div id=\"editbox\" title=@title onclick=\"\"\"\n if(location.search.indexOf(\"edit=@prev\") == -1) {\n   location.search = location.search.startsWith(\"?\") ? location.search + \"&edit=@next\" : \"?edit=@next\"\n } else {\n   location.search = location.search.replace(/edit=@prev/, \"edit=@next\");\n }\n\"\"\">\n<style>#editbox {\n  @(if toEdit then \"\"\"position: fixed;\n  margin-top: 2px;\n  margin-left: 2px;\n  background: white;\n  padding: 2px;\n  border-radius: 10px;\n  transform: scale(0.6);\n  \"\"\" else \"\"\"position: absolute;\n  color: white;\n  background: black;\n  font-family: 'Helvetica', 'Arial', sans-serif;\n  font-size: 2em;\n  font-weight: bold;\n  text-align: center;\n  width: 40px;\n  height: 40px;\n  border-radius: 5px;\n  transform: translate(-0.7em, -0.7em) scale(0.3);\n  \"\"\"\n )z-index: 20000;\n  opacity: 0.5;\n  cursor: pointer;\n}\n#editbox:hover {\n  opacity: 1;\n}\n</style>@msg\n</div>\n\nopenEditBox = switchEditBox True\ncloseEditBox = switchEditBox False\n\nboolToCheck = Update.bijection (case of \"true\" -> [[\"checked\", \"\"]]; _ -> []) (case of [[\"checked\", \"\"]] -> \"true\"; _ -> \"false\")\n\n-- Everything inside the modify menu is generated and is not visible to Editor\neditionmenu thesource = [\n<div id=\"modify-menu\" list-ghost-attributes=\"style class\" sourcecontent=@thesource contenteditable=\"false\">\n<div class=\"information\" children-are-ghosts=\"true\"></div>\n</div>,\n<div id=\"context-menu\" children-are-ghosts=\"true\" list-ghost-attributes=\"style class\" contenteditable=\"false\"></div>,\n<menu id=\"themenu\" ignore-modifications=\"true\" class=\"edittoolbar\" contenteditable=\"false\">\n@(if iscloseable then [] else closeEditBox)\n<style>\nmenu .editor-logo {\n  display: inline-block;\n  margin-right: 5px;\n  font-weight: bold;\n}\n\nmenuitem.filename {\n  color: #777;\n  padding-left: 3px;\n}\n.editor-menu {\n  display: initial !important;\n}\n#menumargin {\n  padding-top: 2em;\n}\nmenu {\n  position: fixed;\n  margin-top: 0px;\n  z-index: 100000;\n  min-height: 1.5em;\n  font-family: sans-serif;\n  border: 1px solid #888;\n}\nmenu.edittoolbar {\n  display: block;\n  color: black;\n  background-color: #d5daff;\n  padding: 3px;\n  border-radius: 10px;\n}\nmenuitem.disabled {\n  color: #BBB;\n}\nmenu input[type=checkbox] {\n  display: none;\n}\nmenu input[type=checkbox] + .label-checkbox {\n}\nmenu input[type=checkbox]:checked + .label-checkbox {\n  background: #bcbbff;\n}\n/*\nmenu input[type=checkbox]:not(:checked) + .label-checkbox::after {\n  content: \": off\";\n}\nmenu input[type=checkbox]:checked + .label-checkbox::after {\n  content: \": on\";\n}\n*/\n.label-checkbox {\n  padding: 2px;\n  border-radius: 10px;\n}\n.label-checkbox:hover {\n  background-color: rgba(0,0,0,0.06);\n  cursor: pointer;\n}\n.menu-separator {\n  display: inline-block;\n  border-left: 1px solid #828282;\n  margin: 0 3px;\n  height: 1.5em;\n  padding: 0;\n  vertical-align: top;\n  line-height: normal;\n  outline: none;\n  overflow: hidden;\n  text-decoration: none;\n  width: 0;\n}\n\nmenuitem > .solution.selected {\n  outline: black 2px solid;\n}\n.to-be-selected {\n  outline: #FCC 2px solid;\n  animation:spin 1s linear infinite;\n}\n@@keyframes spin{\n\tfrom {\n    outline-color: #FAA;\n  }\n  33% {\n    outline-color: #AFA;\n  }\n  66% {\n    outline-color: #AAF;\n  }\n\tto {\n    outline-color: #FAA;\n  }\t\n}\nmenuitem > .solution:not(.selected):hover {\n  outline: #999 2px solid;\n  cursor: pointer;\n}\nmenuitem > .solution.notfinal {\n  color: #666;\n}\n#editor_codepreview, #manualsync-menuitem {\n  display: none;\n  z-index: 999;\n}\n[ghost-visible=true] {\n  display: initial !important;\n}\n[ghost-disabled=true] {\n  opacity: 0.5 !important;\n  cursor: initial;\n  pointer-events: none !important;\n}\n[ghost-disabled=false] {\n  opacity: 1  !important;\n  pointer-events: auto !important;\n}\n#manualsync-menuitem[ghost-disabled=false] > button {\n  cursor:pointer !important;\n  opacity: 1  !important;\n  pointer-events: auto !important;\n}\n#manualsync-menuitem[force-visible=true] {\n  display: initial;\n}\n[ghost-visible=false] {\n  display: none !important;\n}\n#manualsync-menuitem> button {\n  vertical-align: top;\n  opacity: 0.5;\n  cursor: initial;\n  pointer-events: none;\n}\n#editor_codepreview {\n  width: 100%;\n  height: 600px;\n}\n#editor_codepreview > textarea {\n  width: 100%;\n  height: 600px;\n  -webkit-box-shadow: 10px 10px 5px 0px rgba(0,0,0,0.75);\n  -moz-box-shadow: 10px 10px 5px 0px rgba(0,0,0,0.75);\n  box-shadow: 10px 10px 5px 0px rgba(0,0,0,0.75);\n}\n@@media screen and (pointer: coarse) {\n  body {\n    font-size: 48px;\n  }\n  menu.edittoolbar {\n    right: 10px;\n  }\n  div.editor-logo {\n    display: none;\n  }\n  menuitem.filename {\n    display: none;\n  }\n  /*menuitem {\n    font-size: 2.5em;\n  }*/\n  button {\n    font-size: 1em;\n  }\n  menuitem#question-menuitem {\n    display: none;\n  }\n  menuitem#autosave-menuitem {\n    display: none;\n  }\n  #menumargin {\n    padding-top: 5em;\n  }\n  #editor_codepreview {\n    width: 100%;\n    height: 600px;\n  }\n  div.menu-separator {\n    display: none;\n  }\n}\n.summary {\n  color: green;\n}\n\ndiv#modify-menu {\n  -webkit-box-shadow: 0px 0px 34px 0px rgba(0,0,0,0.75);\n  -moz-box-shadow: 0px 0px 34px 0px rgba(0,0,0,0.75);\n  box-shadow: 0px 0px 34px 0px rgba(0,0,0,0.75);\n  position: fixed;\n  top: 0px;\n  right: 0px;\n  width: 400px;\n  height: 100%;\n  background-color: var(--context-color);\n  color: white;\n  padding: 5px;\n  font-size: 16px;\n  transform: translate(100%, 0px);\n  transition-property: transform;\n  transition-duration: 0.5s;\n  z-index: 100001;\n}\n.modify-menu-icon {\n  vertical-align: middle;\n  cursor: pointer;\n  width: var(--context-menu-button-width);\n}\n.modify-menu-icon:hover {\n  background-color: var(--context-button-color-hover);\n}\ndiv#modify-menu.visible {\n  transform: translate(0%, 0%);\n}\ndiv#modify-menu h3 {\n  margin-top: 2px;\n  margin-bottom: 2px;\n}\ndiv#modify-menu div.keyvalues {\n  display: table;\n  width: 100%;\n  table-layout: fixed;\n}\ndiv#modify-menu div.keyvalues > div.keyvalue {\n  display: table-row;\n}\ndiv#modify-menu div.keyvalues > div.keyvalue > * {\n  display: table-cell;\n  padding: 4px;\n  vertical-align: middle;\n}\ndiv#modify-menu div.keyvalues > div.keyvalueadder {\n  opacity: 0.5;\n}\ndiv#modify-menu div.keyvalues > div.keyvalueadder:hover {\n  opacity: 1;\n}\ndiv#modify-menu input {\n  padding: 4px;\n  width: 100%;\n  font-size: 1em;\n}\ndiv#modify-menu input[type=radio] {\n  width: initial;\n  font-size: 1em;\n}\n.inline-input {\n  background: transparent;\n  color: white;\n  border: none;\n}\n\n:root {\n  --context-color: rgba(0, 128, 128, 0.8);\n  --context-color-next: rgba(0, 158, 158, 0.8); \n  --context-button-color: rgba(0, 192, 192, 0.8);\n  --context-button-color-hover: rgba(0, 212, 212, 0.8);\n  --context-button-color-inert: rgba(128, 128, 128, 0.8);\n  --context-button-color-inert-hover: rgba(150, 150, 150, 0.8);\n  --context-button-color-inert-active: rgba(182, 182, 182, 0.8);\n  --context-menu-height: 30px;\n  --context-menu-button-width: 40px;\n  --context-menu-padding-top: 0px;\n  --context-menu-padding-left: 0px;\n}\ndiv.tagName {\n  padding: 4px;\n  cursor: pointer;\n  background: var(--context-button-color);\n}\ndiv.tagName:hover {\n  background: var(--context-button-color-hover);\n}\n\n[ghost-hovered=true] {\n  outline: 2px dashed var(--context-color-next);\n}\n[ghost-clicked=true] {\n  outline: 2px solid var(--context-color);\n}\ndiv#context-menu {\n  position: absolute;\n  display: none;\n  background-color: var(--context-color);\n  color: white;\n  font-weight: bold;\n  z-index: 1000000;\n}\ndiv#context-menu.visible {\n  display: block;\n  height: var(--context-menu-height);\n  width: 200px;\n}\ndiv#context-menu .context-menu-button, div#modify-menu .modify-menu-button {\n  background: var(--context-button-color);\n  display: inline-block;\n  height: var(--context-menu-height);\n  width: var(--context-menu-button-width);\n  cursor: pointer;\n}\n\ndiv#modify-menu .modify-menu-button.inert.active {\n  background: var(--context-button-color-inert-active)\n}\ndiv#modify-menu .modify-menu-button.disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\ndiv#context-menu .context-menu-button > svg, div#modify-menu .modify-menu-button > svg {\n  padding-left: var(--context-menu-padding-left);\n  padding-right: var(--context-menu-padding-left);\n  padding-top: var(--context-menu-padding-top);\n  padding-bottom: var(--context-menu-padding-top);\n}\ndiv#context-menu .context-menu-button.inert, div#modify-menu .modify-menu-button.inert {\n  background: var(--context-button-color-inert)\n}\nsvg.context-menu-icon > path {\n  fill:none;\n  stroke:#FFFFFF;\n  stroke-width:2px;\n  stroke-linecap:butt;\n  -linejoin:miter;\n  stroke-opacity:1;\n}\nsvg.context-menu-icon.fill > path {\n  fill:#FFFFFF;\n  fill-rule:evenodd;\n  stroke-width:1px;\n}\ndiv#context-menu .context-menu-button:hover, div#modify-menu .modify-menu-button:hover:not(.disabled) {\n  background: var(--context-button-color-hover);\n}\ndiv#context-menu .context-menu-button.inert:hover, div#modify-menu .modify-menu-button.inert:hover:not(.disabled) {\n  background: var(--context-button-color-inert-hover)\n}\n#applyNewTagName {\n  display: none;\n}\n#applyNewTagName.visible {\n  display: inline-block;\n}\n@@media (pointer: coarse) {\n  div#modify-menu {\n    font-size: 48px;\n    bottom: 0px;\n    left: 0px;\n    top: initial;\n    right: initial;\n    height: 30%;\n    width: 100%;\n    transform: translate(0px, 100%);\n  }\n  div.bottom-placeholder {\n    width: 100%;\n    height: 30%;\n  }\n  \n  :root {\n    --context-menu-height: 48px;\n    --context-menu-button-width: 48px;\n    --context-menu-padding-top: 9px;\n    --context-menu-padding-left: 4px;\n  }\n}\n\n</style>\n<div class=\"editor-logo\">Editor <a href= \"https://github.com/MikaelMayer/Editor/issues\">(report issue)</a></div>\n<div class=\"menu-separator\"></div>\n<menuitem class= \"filename\" title= \"the path of the file you are currently viewing\">@(if path == \"\" then serverOwned \"empty path\" \"[root folder]\" else path)</menuitem>\n<div class=\"menu-separator\"></div><menuitem>\n<label title=\"Display the source code of this pagge below\"><input id=\"input-showsource\" type=\"checkbox\" save-properties=\"checked\"\n  onchange=\"\"\"\nvar cp = document.getElementById(\"editor_codepreview\");\nif(cp !== null) {\n   cp.setAttribute(\"ghost-visible\", this.checked ? \"true\": \"false\")\n}\"\"\"><span class= \"label-checkbox\">Source</span></label>\n</menuitem><div class=\"menu-separator\"></div>\n<menuitem id=\"question-menuitem\">\n<label title=\"If off, ambiguities are resolved automatically. Does not apply for HTML pages\"><input id=\"input-question\" type=\"checkbox\" save-properties=\"checked\" @(case listDict.get \"question\" vars of\n                       Just questionattr -> boolToCheck questionattr\n                       _ -> serverOwned \"initial checked attribute (use &question=false in query parameters to modify it)\" (\n                              if boolVar \"question\" True then [[\"checked\", \"\"]] else []))><span class= \"label-checkbox\">Ask questions</span></label>\n</menuitem>\n<div class=\"menu-separator\"></div>\n<menuitem id=\"autosave-menuitem\">\n<label title=\"If on, changes are automatically propagated 1 second after the last edit\"><input id=\"input-autosave\" type=\"checkbox\" save-properties=\"checked\" onchange=\"document.getElementById('manualsync-menuitem').setAttribute('ghost-visible', this.checked ? 'false' : 'true')\" @(case listDict.get \"autosave\" vars of\n                      Just autosaveattr -> boolToCheck autosaveattr\n                      _ -> serverOwned \"initial checked attribute (use &autosave=true or false in query parameters to modify it)\"  (\n                             if boolVar \"autosave\" True then [[\"checked\", \"\"]] else []))><span class= \"label-checkbox\">Auto-save</span></label>\n</menuitem>\n<menuitem id=\"manualsync-menuitem\" @(if boolVar \"autosave\" True then [] else [[\"force-visible\", \"true\"]])>\n<button onclick=\"sendModificationsToServer()\" title= \"Sends modifications to the server\">Save</button>\n</menuitem>\n</menu>,\n<div id=\"menumargin\"></div>]\n\ninitialScript = [\n<script>\nvar XHRequest = @(if listDict.get \"browserSide\" defaultOptions == Just True then \"ProxiedServerRequest\" else \"XMLHttpRequest\");\n\nfunction el(tag, attributes, children, properties) {\n  let x = document.createElement(tag);\n  if(typeof attributes == \"object\")\n    for(let k in attributes)\n      x.setAttribute(k, attributes[k]);\n  if(Array.isArray(children)) {\n    for(let child of children) {\n      if(typeof child !== \"undefined\")\n        x.appendChild(child);\n    }\n  } else if(typeof children !== \"undefined\") {\n    x.append(children);\n  }\n  if(typeof properties == \"object\") {\n    for(let k in properties)\n      x[k] = properties[k];\n  }\n  return x;\n}\n\n// TODO: Find a way to store a cookie containing credentials, and have this server refresh tokens.\n// https://developers.google.com/identity/sign-in/web/server-side-flow\n// https://stackoverflow.com/questions/32902734/how-to-make-google-sign-in-token-valid-for-longer-than-1-hour\n// https://www.w3schools.com/js/js_cookies.asp\nif(typeof googleAuthIdToken == \"undefined\") {\n  var googleAuthIdToken = undefined;\n}\n\nfunction isGhostNode(elem) {\n  return elem && elem.nodeType == 1 &&\n    (elem.tagName == \"GHOST\" || elem.getAttribute(\"isghost\") == \"true\");\n}\n\nfunction areChildrenGhosts(n) {\n  return n && n.getAttribute && n.getAttribute(\"children-are-ghosts\") == \"true\";\n}\nfunction hasGhostAncestor(htmlElem) {\n  if(htmlElem == null) return false;\n  if(isGhostNode(htmlElem)) return true;\n  return areChildrenGhosts(htmlElem.parentNode) || hasGhostAncestor(htmlElem.parentNode);\n}\nfunction isGhostAttributeKey(name) {\n  return name.startsWith(\"ghost-\");\n}\n\nglobalGhostAttributeKeysFromNode = [];\n(globalGhostAttributeKeysFromNode || []).push(n =>\n  ((n && n.getAttribute && n.getAttribute(\"list-ghost-attributes\")) || \"\").split(\" \").concat(\n    ((n && n.getAttribute && n.getAttribute(\"save-ghost-attributes\")) || \"\").split(\" \")).filter(a => a != \"\")\n);\n(globalGhostAttributeKeysFromNode || []).push(n =>\n  n && n.tagName == \"HTML\" ? [\"class\"] : []\n);\n(globalGhostAttributeKeysFromNode || []).push(n =>\n  n && n.tagName == \"BODY\" ? [\"data-gr-c-s-loaded\"] : []\n);\n\nfunction isSpecificGhostAttributeKeyFromNode(n) {\n  var additionalGhostAttributes = [];\n  for(var k in globalGhostAttributeKeysFromNode) {\n    additionalGhostAttributes = additionalGhostAttributes.concat(globalGhostAttributeKeysFromNode[k](n))\n  }\n  return (a => name => a.indexOf(name) != -1)(additionalGhostAttributes);\n}\n\nsetGhostOnInserted = [];\n\n// Analytics scripts\n(setGhostOnInserted || []).push(insertedNode =>\n  insertedNode.tagName == \"SCRIPT\" && typeof insertedNode.getAttribute(\"src\") == \"string\" &&\n     insertedNode.getAttribute(\"src\").indexOf(\"google-analytics.com/analytics.js\") != -1\n);\n\n// For for ace styles in header\n(setGhostOnInserted || []).push(insertedNode => {\n    if(insertedNode.tagName == \"STYLE\" && typeof insertedNode.getAttribute(\"id\") == \"string\" &&\n     (insertedNode.getAttribute(\"id\").startsWith(\"ace-\") ||\n      insertedNode.getAttribute(\"id\").startsWith(\"ace_\"))) {\n      insertedNode.setAttribute(\"save-ghost\", \"true\"); \n      return true;\n    } else {\n      return false;\n    }\n  }\n);\n// For Google sign-in buttons and i-frames\n(setGhostOnInserted || []).push(insertedNode =>\n  (insertedNode.tagName == \"DIV\" &&\n    insertedNode.classList.contains(\"abcRioButton\")) ||\n  (insertedNode.tagName == \"IFRAME\" &&\n    insertedNode.getAttribute(\"id\") == \"ssIFrame_google\")\n);\n// For anonymous styles inside HEAD (e.g. ace css themes and google sign-in)\n(setGhostOnInserted || []).push(insertedNode => \n  insertedNode.tagName == \"STYLE\" && insertedNode.getAttribute(\"id\") == null &&\n  insertedNode.parentElement.tagName == \"HEAD\" && (insertedNode.setAttribute(\"save-ghost\", \"true\") || true)\n);\n// For ace script for syntax highlight\n(setGhostOnInserted || []).push(insertedNode =>\n  insertedNode.tagName == \"SCRIPT\" && typeof insertedNode.getAttribute(\"src\") == \"string\" &&\n     insertedNode.getAttribute(\"src\").startsWith(\"https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.2/mode-j\")\n);\n// For ace script for syntax highlight\n(setGhostOnInserted || []).push(insertedNode =>\n  insertedNode.tagName == \"ACE_OUTER\"\n);\n// For the grammarly extension\n(setGhostOnInserted || []).push(insertedNode =>\n  insertedNode.classList.contains(\"gr-top-z-index\") || insertedNode.classList.contains(\"gr-top-zero\")\n);\n\nfunction handleScriptInsertion(mutations) {\n  for(var i = 0; i < mutations.length; i++) {\n    // A mutation is a ghost if either\n    // -- The attribute starts with 'ghost-'\n    // -- It is the insertion of a node whose tag is \"ghost\" or that contains an attribute \"isghost=true\"\n    // -- It is the modification of a node or an attribute inside a ghost node.\n    var mutation = mutations[i];\n    if(hasGhostAncestor(mutation.target)) continue;\n    if(mutation.type == \"childList\") {\n      for(var j = 0; j < mutation.addedNodes.length; j++) {\n        var insertedNode = mutation.addedNodes[j];\n        if(!hasGhostAncestor(insertedNode) && (insertedNode.nodeType == 1 && insertedNode.getAttribute(\"isghost\") != \"true\" || insertedNode.noteType == 3 && !insertedNode.isghost) && setGhostOnInserted.find(pred => pred(insertedNode))) {\n         if(insertedNode.nodeType == 1) insertedNode.setAttribute(\"isghost\", \"true\");\n         insertedNode.isghost = true;\n        }\n      }\n    }\n  }\n}\n\nif (typeof analyticsScriptNeutralizer !== \"undefined\") {\n  // console.log(\"analyticsScriptNeutralizer.disconnect()\");\n  analyticsScriptNeutralizer.disconnect();\n}\n\nanalyticsScriptNeutralizer = new MutationObserver(handleScriptInsertion);\nanalyticsScriptNeutralizer.observe\n ( document.body.parentElement\n , { attributes: false\n   , childList: true\n   , characterData: false\n   , attributeOldValue: false\n   , characterDataOldValue: false\n   , subtree: true\n   }\n )\n\n// Self-editing capabilities\nfunction getSelectionStart() {\n   var node = document.getSelection().anchorNode;\n   return (node != null && node.nodeType == 3 ? node.parentNode : node);\n}\nfunction getEnclosingCaret(tagName) {\n  var w = getSelectionStart();\n  while(w != null && w.tagName.toLowerCase() != tagName.toLowerCase()) {\n    w = w.parentNode;\n  }\n  return w;\n}\nfunction emptyTextContent(node) {\n  if(node != null) {\n    if(node.nodeType == 3) {\n      node.textContent = \"\";\n    } else {\n      for(i in node.childNodes) {\n        emptyTextContent(node.childNodes[i]);\n      }\n    }\n  }\n  return node;\n}\nfunction insertBefore(parent, node, beforeNode) {\n  if(beforeNode == null) {\n    parent.append(node);\n  } else {\n    parent.insertBefore(node, beforeNode);\n  }\n}\n\nfunction duplicate(node, options) {\n  if(typeof options == \"undefined\") options = {}\n  if(typeof options.onBeforeInsert != \"function\") options.onBeforeInsert = e => e;\n  if(node != null && node.parentNode != null) {\n    var insertBeforeNode = options.after ? node.nextSibling : node;\n    if(node.nextSibling != null) {\n      var next = node.nextSibling;\n      if(next.nodeType == 3 && next.nextSibling != null &&\n         next.nextSibling.tagName == node.tagName && (node.tagName == \"TR\" || node.tagName == \"TH\" || node.tagName == \"LI\" || node.tagName == \"TD\")) {\n        var textElement = next.cloneNode(true);\n        insertBefore(node.parentNode, textElement, options.after ? node.nextSibling : node);\n        if(options.after) {\n          insertBeforeNode = textElement.nextSibling;\n        } else {\n          insertBeforeNode = textElement\n        }\n      }\n    }\n    var cloned = options.onBeforeInsert(node.cloneNode(true));\n    insertBefore(node.parentNode, cloned, insertBeforeNode);\n    return cloned;\n  }\n}\nfunction remove(node) {\n  if(node.previousSibling != null) { // Remove whitespace as well\n    var next = node.nextSibling;\n    if(next.nodeType == 3 && next.nextSibling != null &&\n       next.nextSibling.tagName == node.tagName && (node.tagName == \"TR\" || node.tagName == \"TH\" || node.tagName == \"LI\" || node.tagName == \"TD\")) {\n      next.remove();\n    }\n  }\n  node.remove();\n}\n</script>\n]\n\ncodepreview thesource = \n<div class=\"codepreview\" id=\"editor_codepreview\">\n  <textarea id=\"editor_codepreview_textarea\" save-properties=\"scrollTop\"\n     v=thesource @(if boolVar \"autosave\" True then [] else [[\"onkeyup\", \"this.setAttribute('v', this.value)\"]]) onchange=\"this.setAttribute('v', this.value)\">@(Update.softFreeze (if Regex.matchIn \"^\\r?\\n\" thesource then \"\\n\" + thesource else thesource))</textarea>\n</div>\n    \neditionscript = \"\"\"\n  var onMobile = () => window.matchMedia(\"(pointer: coarse)\").matches;\n  var buttonHeight = () => onMobile() ? 48 : 30;\n  var buttonWidth  = () => onMobile() ? 48 : 40;\n  \n  // Save / Load ghost attributes after a page is reloaded.\n  // Same for some attributes\n  function saveGhostAttributes() {\n    var ghostModified = document.querySelectorAll(\"[ghost-visible]\");\n    var idGhostAttributes = [];\n    for(var i = 0; i < ghostModified.length; i++) {\n      var id = ghostModified[i].getAttribute(\"id\");\n      if(id !== null && typeof id !== \"undefined\") {\n        idGhostAttributes.push([id,\n          \"ghost-visible\", ghostModified[i].getAttribute(\"ghost-visible\")]);\n      }\n    }\n    var ghostAttributesModified = document.querySelectorAll(\"[save-ghost-attributes]\");\n    console.log(ghostAttributesModified);\n    for(var i = 0; i < ghostAttributesModified.length; i++) {\n      var elem = ghostAttributesModified[i];\n      var id = elem.getAttribute(\"id\");\n      if(id != null) {\n        var toSave = elem.getAttribute(\"save-ghost-attributes\").split(\" \");\n        for(j in toSave) {\n          var key = toSave[j];\n          idGhostAttributes.push([id, key, elem.getAttribute(key)]);\n        }\n      }\n    }\n    \n    var elemsWithAttributesToSave = document.querySelectorAll(\"[save-properties]\");\n    var idDynamicAttributes = [];\n    for(var i = 0; i < elemsWithAttributesToSave.length; i++) {\n      var elem = elemsWithAttributesToSave[i];\n      var id = elem.getAttribute(\"id\");\n      if(id !== null && typeof id !== \"undefined\") {\n        var toSave = elem.getAttribute(\"save-properties\").split(\" \");\n        for(j in toSave) {\n          var key = toSave[j];\n          idDynamicAttributes.push([id, key, elem[key]])\n        }\n      }\n    }\n    var ghostElemsToReinsert = document.querySelectorAll(\"[save-ghost]\");\n    var parentsGhostNodes = [];\n    for(var i = 0; i < ghostElemsToReinsert.length; i++) {\n      var elem = ghostElemsToReinsert[i];\n      if(elem.parentNode.tagName == \"HEAD\") {\n        parentsGhostNodes.push({parentSelector: \"HEAD\", node: elem});\n      } else {\n        var id =  elem.parentNode.getAttribute(\"id\");\n        if(id != null) {\n          parentsGhostNodes.push({parentSelector: \"#\"+id, node: elem});\n        }\n      }\n    }\n    return [idGhostAttributes, idDynamicAttributes, parentsGhostNodes];\n  }\n  function applyGhostAttributes(attrs) {\n    var [idGhostAttributes, idDynamicAttributes, parentsGhostNodes] = attrs;\n    for(var i in idGhostAttributes) {\n      var [id, key, attr] = idGhostAttributes[i];\n      var elem = document.getElementById(id);\n      if(elem != null) {\n        elem.setAttribute(key, attr);\n      }\n    }\n    for(var i in idDynamicAttributes) {\n      var [id, key, value] = idDynamicAttributes[i];\n      var elem = document.getElementById(id);\n      if(elem != null) {\n        elem[key] = value;\n      }\n    }\n    for(var i in parentsGhostNodes) {\n      var {parentSelector: selector, node: elem} = parentsGhostNodes[i];\n      var parent = document.querySelector(selector);\n      if(parent != null) {\n        if(!elem.getAttribute(\"id\") || !document.getElementById(elem.getAttribute(\"id\"))) {\n          parent.appendChild(elem);\n        }\n      }\n    }\n  }\n  \n  function domNodeToNativeValue(n) {\n      if(n.nodeType == \"3\") {\n        return [\"TEXT\", n.textContent];\n      } else if(n.nodeType == \"8\") {\n        return [\"COMMENT\", n.textContent];\n      } else {\n        var attributes = [];\n        var isSpecificGhostAttributeKey = isSpecificGhostAttributeKeyFromNode(n);\n        for(var i = 0; i < n.attributes.length; i++) {\n          var key = n.attributes[i].name;\n          var value = n.attributes[i].value;\n          if(!isGhostAttributeKey(key) && !isSpecificGhostAttributeKey(key)) {\n            if(key == \"style\") {\n              value = value.split(\";\").map(x => x.split(\":\")).filter(x => x.length == 2);\n            }\n            attributes.push([key, value]);\n          }\n        }\n        var children = [];\n        if(!areChildrenGhosts(n)) {\n          for(i = 0; i < n.childNodes.length; i++) {\n            if(!isGhostNode(n.childNodes[i])) {\n              children.push(domNodeToNativeValue(n.childNodes[i]));\n            }\n          }\n        }\n        return [n.tagName.toLowerCase(), attributes, children];\n      }\n    }\n    function replaceContent(NC) {\n      document.open();\n      document.write(NC);\n      document.close();\n    }\n    \n    var t = undefined;\n    \n    handleServerPOSTResponse = (xmlhttp, onBeforeUpdate) => function () {\n        if (xmlhttp.readyState == XMLHttpRequest.DONE) {\n          //console.log(\"Received new content. Replacing the page.\");\n          if(typeof onBeforeUpdate !== \"undefined\") onBeforeUpdate();\n          var saved = saveGhostAttributes();\n          replaceContent(xmlhttp.responseText);\n          applyGhostAttributes(saved);\n          \n          var newLocalURL = xmlhttp.getResponseHeader(\"New-Local-URL\");\n          var newQueryStr = xmlhttp.getResponseHeader(\"New-Query\");\n          var ambiguityKey = xmlhttp.getResponseHeader(\"Ambiguity-Key\");\n          var ambiguityNumber = xmlhttp.getResponseHeader(\"Ambiguity-Number\");\n          var ambiguitySelected = xmlhttp.getResponseHeader(\"Ambiguity-Selected\");\n          var ambiguityEnd = xmlhttp.getResponseHeader(\"Ambiguity-End\");\n          var ambiguitySummaries = xmlhttp.getResponseHeader(\"Ambiguity-Summaries\");\n          if(ambiguityKey !== null && typeof ambiguityKey != \"undefined\" &&\n             ambiguityNumber !== null && typeof ambiguityNumber != \"undefined\" &&\n             ambiguitySelected !== null && typeof ambiguitySelected != \"undefined\") {\n             \n            var n = JSON.parse(ambiguityNumber);\n            var selected = JSON.parse(ambiguitySelected);\n            var summaries = JSON.parse(ambiguitySummaries);\n            var newMenu = el(\"menuitem\", {isghost: \"true\"});\n            var disambiguationMenu = `<span style=\"color:red\" id=\"ambiguity-id\" v=\"${ambiguityKey}\">Ambiguity.</span> Solutions `;\n            for(var i = 1; i <= n; i++) {\n              var summary = summaries[i-1].replace(/\"/g,'&quot;');\n              if(i == selected) {\n                disambiguationMenu += ` <span class=\"solution selected\" title=\"${summary}\">#${i}</span>`\n              } else {\n                disambiguationMenu += ` <span class=\"solution${i == n && ambiguityEnd != 'true' ? ' notfinal' : ''}\" title=\"${summary}\" onclick=\"this.classList.add('to-be-selected'); selectAmbiguity('${ambiguityKey}', ${i})\">#${i}</span>`\n              }\n            }\n            disambiguationMenu += ` <button id=\"saveambiguity\" onclick='acceptAmbiguity(\"${ambiguityKey}\", ${selected})'>Save</button>`;\n            disambiguationMenu += ` <button id=\"cancelAmbiguity\" onclick='cancelAmbiguity(\"${ambiguityKey}\", ${selected})'>Cancel</button>`;\n            newMenu.innerHTML = disambiguationMenu;\n            if(document.getElementById(\"themenu\"))\n              document.getElementById(\"themenu\").append(newMenu);\n          } else {\n            var opSummaryEncoded = xmlhttp.getResponseHeader(\"Operations-Summary\");\n            if(opSummaryEncoded) {\n              var opSummary = decodeURI(opSummaryEncoded);\n              var newMenu =\n                el(\"menuitem\", {id: \"lastaction\", isghost: \"true\"},\n                  el(\"span\", {\"class\": \"summary\"}, \"Last action: \" + opSummary));\n              if(document.getElementById(\"themenu\"))\n                document.getElementById(\"themenu\").append(newMenu);\n                var newmenutimeout = setTimeout(function() { newMenu.remove(); }, 2000);\n                newMenu.onclick = ((n) => () => clearTimeout(n))(newmenutimeout);\n            }\n          }\n          var strQuery = \"\";\n          if(newQueryStr !== null) {\n            var newQuery = JSON.parse(newQueryStr);\n            for(var i = 0; i < newQuery.length; i++) {\n              var {_1: key, _2: value} = newQuery[i];\n              strQuery = strQuery + (i == 0 ? \"?\" : \"&\") + key + (value === \"\" && key == \"edit\" ? \"\" : \"=\" + value)\n            }\n          }\n          if(newLocalURL) { // Overrides query parameters\n            console.log(\"replaceState\", xmlhttp.replaceState ? \"replaceState\" : \"pushState\");\n            console.log(\"state\", {localURL: newLocalURL})\n            window.history[xmlhttp.replaceState ? \"replaceState\" : \"pushState\"]({localURL: newLocalURL}, \"Nav. to \" + newLocalURL, newLocalURL);\n          } else if(strQuery) {\n            window.history.replaceState({}, \"Current page\", strQuery);\n          }\n        }\n    }\n    \n    window.onpopstate = function(e){\n        console.log(\"onpopstate\", e);\n        if(e.state && e.state.localURL) {\n          navigateLocal(location, true);\n        } else {\n          navigateLocal(location.pathname + location.search, true);\n        }\n    };\n    \n    notifyServer = callback => {\n      var xmlhttp = new XHRequest();\n      xmlhttp.onreadystatechange = handleServerPOSTResponse(xmlhttp, () => {\n        if(document.getElementById(\"input-autosave\") && !document.getElementById(\"input-autosave\").checked) {\n          document.getElementById(\"manualsync-menuitem\").setAttribute(\"ghost-visible\", \"true\") // Because it will be saved\n        }\n      });\n      xmlhttp.open(\"POST\", location.pathname + location.search);\n      xmlhttp.setRequestHeader(\"Content-Type\", \"application/json\");\n      if(googleAuthIdToken) {\n        xmlhttp.setRequestHeader(\"id-token\", googleAuthIdToken)\n      }\n      var result = callback(xmlhttp);\n      xmlhttp.send(result || \"{\\\"a\\\":1}\");\n    }\n    \n    function reloadPage() { // Use this only after a successful login\n      notifyServer(xmlhttp => {\n        xmlhttp.setRequestHeader(\"reload\", \"true\");\n      })\n    }\n    \n    function navigateLocal(url, replaceState) {\n      notifyServer(xmlhttp => {\n        xmlhttp.setRequestHeader(\"reload\", \"true\");\n        xmlhttp.setRequestHeader(\"url\", url);\n        console.log(\"setting url to \", url);\n        xmlhttp.replaceState = replaceState;\n      });\n    }\n    \n    function selectAmbiguity(key, num) {\n      notifyServer(xmlhttp => {\n        xmlhttp.setRequestHeader(\"ambiguity-key\", key);\n        xmlhttp.setRequestHeader(\"select-ambiguity\", JSON.stringify(num));\n        xmlhttp.setRequestHeader(\"question\", \"true\");\n      });\n    }\n    \n    function acceptAmbiguity(key, num) {\n      notifyServer(xmlhttp => {\n        xmlhttp.setRequestHeader(\"ambiguity-key\", key);\n        xmlhttp.setRequestHeader(\"accept-ambiguity\", JSON.stringify(num));\n      });\n    }\n    \n    function cancelAmbiguity(key, num) {\n      notifyServer(xmlhttp => {\n        xmlhttp.setRequestHeader(\"ambiguity-key\", key);\n        xmlhttp.setRequestHeader(\"cancel-ambiguity\", JSON.stringify(num));\n      });\n    }\n    \n    function sendModificationsToServer() {\n      if(document.getElementById(\"notification-menu\") != null) {\n        //document.getElementById(\"notification-menu\").innerHTML = `cannot send the server more modifications until it resolves these ones. Refresh the page?`\n        return;\n      }\n      var newMenu = el(\"menuitem\",\n        {isghost: true, id: \"notification-menu\", class:\"to-be-selected\"},\n        `Updating the source files...`);\n      if(document.getElementById('lastaction')) {\n        document.getElementById('lastaction').remove();\n      }\n      if(document.getElementById(\"themenu\") && document.getElementById(\"manualsync-menuitem\")) {\n        document.getElementById(\"themenu\").append(newMenu);\n        document.getElementById(\"manualsync-menuitem\").setAttribute(\"ghost-visible\", \"false\");\n      }\n      notifyServer(xmlhttp => {\n        xmlhttp.setRequestHeader(\"question\", document.getElementById(\"input-question\") && document.getElementById(\"input-question\").checked ? \"true\" : \"false\");\n        return JSON.stringify(domNodeToNativeValue(document.body.parentElement));\n      })\n    }\n    \n    function handleMutations(mutations) {\n      var onlyGhosts = true;\n      for(var i = 0; i < mutations.length && onlyGhosts; i++) {\n        // A mutation is a ghost if either\n        // -- The attribute starts with 'ghost-'\n        // -- It is the insertion of a node whose tag is \"ghost\" or that contains an attribute \"isghost=true\"\n        // -- It is the modification of a node or an attribute inside a ghost node.\n        var mutation = mutations[i];\n        if(hasGhostAncestor(mutation.target)) {\n          continue;\n        }\n        if(mutation.type == \"attributes\") {\n          var isSpecificGhostAttributeKey = isSpecificGhostAttributeKeyFromNode(mutation.target);\n          if(isGhostAttributeKey(mutation.attributeName) || isSpecificGhostAttributeKey(mutation.attributeName)) {\n          } else {\n            onlyGhosts = false;\n            console.log(\"Attribute is not ghost\", mutation);\n          }\n        } else if(mutation.type == \"childList\") {\n          if(!areChildrenGhosts(mutation.target)) {\n            for(var j = 0; j < mutation.addedNodes.length && onlyGhosts; j++) {\n              if(!hasGhostAncestor(mutation.addedNodes[j])) {\n                onlyGhosts = false;\n                console.log(`Added node ${j} does not have a ghost ancestor`, mutation);\n              }\n            }\n            for(var j = 0; j < mutation.removedNodes.length && onlyGhosts; j++) {\n              if(!isGhostNode(mutation.removedNodes[j])) {\n                onlyGhosts = false;\n                console.log(`Removed node ${j} was not a ghost`, mutation);\n              }\n            }\n          }\n        } else {\n          onlyGhosts = false;\n          console.log(\"mutations other than attributes, childList and characterData are not ghosts\", mutations);\n        }\n      }\n      if(onlyGhosts) {\n        console.log(\"mutations are only ghosts, skipping\");\n        return;\n      } // Send in post the new HTML along with the URL\n      if(document.getElementById(\"input-autosave\") && !document.getElementById(\"input-autosave\").checked) {\n        if(document.getElementById(\"manualsync-menuitem\")) {\n          document.getElementById(\"manualsync-menuitem\").setAttribute(\"ghost-disabled\", \"false\");\n        }\n        editor_model.canSave = true;\n        var saveButtons = document.querySelectorAll(\".saveButton\");\n        // TODO: Can we regenerate the whole interface for consistency?\n        for(let sb of saveButtons) {\n          sb.classList.toggle(\"disabled\", false);\n        }\n        return;\n      }\n      \n      if(typeof t !== \"undefined\") {\n        clearTimeout(t);\n      }\n      t = setTimeout(function() {\n        t = undefined;\n        \n        sendModificationsToServer();\n      }, @editdelay)\n    }\n  \n    if (typeof outputValueObserver !== \"undefined\") {\n      // console.log(\"outputValueObserver.disconnect()\");\n      outputValueObserver.disconnect();\n    }\n    \n\n    setTimeout(function() {\n      outputValueObserver = new MutationObserver(handleMutations);\n      outputValueObserver.observe\n       ( document.body.parentElement\n       , { attributes: true\n         , childList: true\n         , characterData: true\n         , attributeOldValue: true\n         , characterDataOldValue: true\n         , subtree: true\n         }\n       )\n     }, 10)\n    \n    function pasteHtmlAtCaret(html) {\n      var sel, range;\n      if (window.getSelection) {\n          // IE9 and non-IE\n          sel = window.getSelection();\n          if (sel.getRangeAt && sel.rangeCount) {\n              range = sel.getRangeAt(0);\n              range.deleteContents();\n\n              // Range.createContextualFragment() would be useful here but is\n              // only relatively recently standardized and is not supported in\n              // some browsers (IE9, for one)\n              var div = document.createElement(\"div\");\n              div.innerHTML = html;\n              var frag = document.createDocumentFragment(), node, lastNode;\n              while ( (node = div.firstChild) ) {\n                  lastNode = frag.appendChild(node);\n              }\n              range.insertNode(frag);\n\n              // Preserve the selection\n              if (lastNode) {\n                  range = range.cloneRange();\n                  range.setStartAfter(lastNode);\n                  range.collapse(true);\n                  sel.removeAllRanges();\n                  sel.addRange(range);\n              }\n          }\n      } else if (document.selection && document.selection.type != \"Control\") {\n          // IE < 9\n          document.selection.createRange().pasteHTML(html);\n      }\n    }\n    \n    function handleFileSelect(evt) {\n      evt.stopPropagation();\n      evt.preventDefault();\n\n      var files = evt.dataTransfer.files; // FileList object.\n      uploadFilesAtCursor(files);\n    }\n      \n    function uploadFilesAtCursor(files) {\n      // files is a FileList of File objects. List some properties.\n      var insertRelative = true;\n      var output = [];\n      for (var i = 0, f; f = files[i]; i++) {\n        var xhr = new XMLHttpRequest();\n        var tmp = location.pathname.split(\"/\");\n        tmp = tmp.slice(0, tmp.length - 1);\n        var storageFolder = tmp.join(\"/\");\n        var storageLocation =  storageFolder + \"/\" + f.name;\n        //if(f.size < 30000000)\n        xhr.onreadystatechange = ((xhr, filetype, path, name) => () => {\n          if (xhr.readyState == XMLHttpRequest.DONE) {\n            if (xhr.status == 200 || xhr.status == 201) {@(if folderView then \"\"\"\n              reloadPage();\"\"\"\n              else \"\"\"\n              if(filetype.indexOf(\"image\") == 0) {\n                pasteHtmlAtCaret(`<img src=\"${path}\" alt=\"${name}\">`);\n              } else {\n                pasteHtmlAtCaret(`<a href=\"${path}\">${path}</a>`); \n              }\"\"\")\n            } else {\n              console.log(\"Error while uploading picture\", xhr);\n            }\n          }\n        })(xhr, f.type, insertRelative ? f.name : storageLocation, f.name);\n        @(if listDict.get \"browserSide\" defaultOptions == Just True then \"\"\"\n        xhr.open(\"POST\", \"/editor.php?location=\" + encodeURIComponent(storageLocation), true);\n        \"\"\" else \"\"\"\n        xhr.open(\"POST\", storageLocation, true);\n        \"\"\");\n        xhr.setRequestHeader(\"write-file\", f.type);\n        xhr.send(f);\n      }\n    }\n\n    function handleDragOver(evt) {\n      evt.stopPropagation();\n      evt.preventDefault();\n      evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.\n    }\n\n    if(@(if varedit then \"true\" else \"false\")) {\n      var dropZone = document.body;\n      dropZone.addEventListener('dragover', handleDragOver, false);\n      dropZone.addEventListener('drop', handleFileSelect, false);\n    \n      var lastclick = 0;\n      // Shortcuts\n      document.onkeydown = function(e) {\n        var key = e.which || e.keyCode;\n        if (e.which == 83 && (e.ctrlKey || e.metaKey)) { // CTRL+S or CMD+S: Save\n          closeLinkWindow();\n          if(document.getElementById(\"saveambiguity\")) {\n            eval(document.getElementById(\"saveambiguity\").getAttribute(\"onclick\") || \"console.log('no onclick for saveambiguity')\")\n          } else {\n            sendModificationsToServer();\n          }\n          e.preventDefault();\n        }\n        if(e.which == 75 && (e.ctrlKey || e.metaKey)) { // CTRL+K: Insert link\n          if(new Date().valueOf() - lastclick > 100) {\n            document.execCommand('createLink', false, 'http://');\n            e.preventDefault();\n            var s = getSelection();\n            s = s ? s.anchorNode : s;\n            s = s ? s.parentNode : s;\n            lastclick = new Date().valueOf();\n            onClickOnLink({target: s, modify: true});\n          }\n          // Open link.\n        }\n      };\n      document.onkeyup = document.onkeydown\n      \n      var bodyeditable = document.querySelector(\"body[contenteditable=true]\");\n      var onKeypress = e => {\n        if(e.keyCode==13 && !e.shiftKey){ // [Enter] key\n            // If we are inside a paragraph, we split the paragraph.\n            // If we are directly inside a div, we add a paragraph separator.\n            // We delete everything between anchorNode and focusNode\n            // TODO: Handle ul and li\n            var caretSelection = document.getSelection();\n            var x = caretSelection.anchorNode;\n            if(x && x.nodeType == 3 && caretSelection.rangeCount) { // text node\n              if(x.parentNode && getComputedStyle(x.parentNode).display == \"block\") {\n                e.preventDefault(); //Prevent default browser\n                var range = caretSelection.getRangeAt(0);\n                range.deleteContents();\n                caretSelection = document.getSelection();\n                x = caretSelection.anchorNode;\n                if(x.parentNode.tagName == \"p\") { // Split the p\n                  var newPar = document.createElement(\"p\");\n                  \n                  var fo = caretSelection.anchorOffset;\n                  if(fo < x.text.length) {\n                    newPar.append(document.createTextNode(x.text.substring(fo)));\n                    x.deleteData(fo,x.text.length - fo);\n                  }\n                  var y = x.nextSibling;\n                  while(y) {\n                    var yy = y;\n                    y = y.nextSibling;\n                    newPar.append(yy); // Moves yy\n                  }\n                  x.parentNode.insertAdjacentElement(\"afterend\", newPar);\n                } else { // insert br\n                  range.insertNode(document.createElement(\"br\"))\n                }\n              }\n            }\n        }\n      }\n      if(bodyeditable && !bodyeditable.configured) {\n        bodyeditable.configured = true;\n        bodyeditable.addEventListener(\"keypress\", onKeypress, true);\n      }\n    }\n    \n    observeTargetA = null;\n    \n    addEditEqualToUrl = function(href, what) {\n      if(href.indexOf(\"://\") == -1) { // Instrument the relative link so that it is edit=true\n        if(href.indexOf(\"?\") >= 0) {\n          if(href.endsWith(\"?\")) {\n            href = href + \"edit=\" + what\n          } else {\n            href = href + \"&edit=\" + what\n          }\n        } else {\n          href = href + \"?edit=\" + what\n        }\n      }\n      return href;\n    }\n    \n    var currentlySelectedElement = undefined;\n    \n    onClickOnLink = function (event) {\n      var clickedElem = event.target;\n      var ancestors = [];\n      var tmp = clickedElem;\n      var aElement;\n      var ancestorIsModifyBox = false;\n      var ancestorIsContextMenu = false;\n      var link = undefined;\n      while(tmp) {\n        ancestors.push(tmp);\n        if(tmp.getAttribute && tmp.getAttribute(\"id\") == \"modify-menu\") {\n          ancestorIsModifyBox = true;\n        }\n        if(tmp.getAttribute && tmp.getAttribute(\"id\") == \"context-menu\") {\n          ancestorIsContextMenu = true;\n        }\n        if(!aElement && clickedElem.tagName === \"A\") { // First link.\n          aElement = clickedElem;\n          link = aElement.getAttribute(\"href\");\n        }\n        tmp = tmp.parentElement;\n      }\n      document.querySelectorAll(\"[ghost-hovered=true]\").forEach(e => e.removeAttribute(\"ghost-hovered\"));\n      if(ancestorIsModifyBox || ancestorIsContextMenu || ancestors[ancestors.length - 1].tagName != \"HTML\") return;\n      //console.log(\"not modify box\", ancestors)\n      document.querySelector(\"#context-menu\").classList.remove(\"visible\");\n      \n      currentlySelectedElement = undefined;\n      if(clickedElem.setAttribute) {\n        currentlySelectedElement = clickedElem;\n      } else if(clickedElem.parentNode.setAttribute) {\n        currentlySelectedElement = clickedElem.parentNode;\n      }\n      editor_model.clickedElem = clickedElem;\n      editor_model.link = link;\n      editor_model.insertElement = false;\n      editor_model.advanced = false;\n      updateInteractionDiv();\n      // Check if the event.target matches some selector, and do things...\n    }\n    function mkSvg(path, fill) {\n      return `<svg class=\"context-menu-icon${fill ? \" fill\": \"\"}\" width=\"40\" height=\"30\">\n            <path d=\"${path}\" /></svg>`\n    }\n    var saveSVG = mkSvg(\"M 10,5 10,25 30,25 30,9 26,5 13,5 Z M 13,6 25,6 25,12 13,12 Z M 22,7 22,11 24,11 24,7 Z M 13,15 27,15 27,24 13,24 Z M 11,23 12,23 12,24 11,24 Z M 28,23 29,23 29,24 28,24 Z\", true);\n    var openLeftSVG = mkSvg(\"M 27.5,4 22.5,4 12.5,15 22.5,25 27.5,25 17.5,15 Z\", true);\n    var closeRightSVG = mkSvg(\"M 12.5,4 17.5,4 27.5,15 17.5,25 12.5,25 22.5,15 Z\", true);\n    var openTopSVG = mkSvg(\"M 9.5,22 9.5,17 20.5,7 30.5,17 30.5,22 20.5,12 Z\", true);\n    var closeBottomSVG = mkSvg(\"M 9.5,7 9.5,12 20.5,22 30.5,12 30.5,7 20.5,17 Z\", true);\n    var wasteBasketSVG = mkSvg(\"m 24,11.5 0,11 m -4,-11 0,11 m -4,-11 0,11 M 17,7 c 0,-4.5 6,-4.5 6,0 m -11,0.5 0,14 c 0,3 1,4 3,4 l 10,0 c 2,0 3,-1 3,-3.5 L 28,8 M 9,7.5 l 22,0\");\n    var plusSVG = mkSvg(\"M 18,5 22,5 22,13 30,13 30,17 22,17 22,25 18,25 18,17 10,17 10,13 18,13 Z\", true);\n    var liveLinkSVG = link => `<a class=\"livelink\" href=\"javascript:navigateLocal('${link}')\">${mkSvg(\"M 23,10 21,12 10,12 10,23 25,23 25,18 27,16 27,24 26,25 9,25 8,24 8,11 9,10 Z M 21,5 33,5 33,17 31,19 31,9 21,19 19,17 29,7 19,7 Z\", true)}</a>`;\n    var gearSVG = mkSvg(\"M 17.88,2.979 14.84,3.938 15.28,7.588 13.52,9.063 10,8 8.529,10.83 11.42,13.1 11.22,15.38 7.979,17.12 8.938,20.16 12.59,19.72 14.06,21.48 13,25 15.83,26.47 18.1,23.58 20.38,23.78 22.12,27.02 25.16,26.06 24.72,22.41 26.48,20.94 30,22 31.47,19.17 28.58,16.9 28.78,14.62 32.02,12.88 31.06,9.84 27.41,10.28 25.94,8.52 27,5 24.17,3.529 21.9,6.42 19.62,6.219 17.88,2.979 Z M 20,11 A 4,4 0 0 1 24,15 4,4 0 0 1 20,19 4,4 0 0 1 16,15 4,4 0 0 1 20,11 Z\", true);\n    var isAbsolute = url => url.match(/^https?:\\/\\/|^www\\.|^\\/\\//);\n    var linkToEdit = @(if defaultVarEdit then \"link => link\" else \n     \"\"\"link => link && !isAbsolute(link) ? link.match(/\\?/) ? link + \"&edit\" : link + \"?edit\" : link;\"\"\");\n    \n    var editor_model = { // Change this and call updateInteractionDiv() to get something consistent.\n      clickedElem: undefined,\n      notextselection: false,\n      caretPosition: undefined,\n      link: undefined,\n      advanced: false,\n      displaySource: false\n    }\n    updateInteractionDiv();\n    \n    function updateInteractionDiv() {\n      let model = editor_model;\n      var clickedElem = model.clickedElem;\n      var contextMenu = document.querySelector(\"#context-menu\");\n      var interactionDiv = document.querySelector(\"#modify-menu > .information\");\n      if(!interactionDiv || !contextMenu) return;\n      document.querySelectorAll(\"[ghost-clicked=true]\").forEach(e => e.removeAttribute(\"ghost-clicked\"));\n      if(clickedElem && clickedElem.nodeType === 1) {\n        clickedElem.setAttribute(\"ghost-clicked\", \"true\");\n      }\n      let selectionRange = model.notextselection ? undefined : (() => {\n        let selection = window.getSelection();\n        if(!selection || !selection.rangeCount) return;\n        let f = selection.getRangeAt(0); \n        if(!f || !f.getBoundingClientRect ||\n            f.startOffset === f.endOffset && f.startContainer === f.endContainer) return;\n        return f;\n      })();\n      let caretPosition = model.notextselection || clickedElem && clickedElem.tagName === \"HEAD\" ? undefined : (() => {\n        let selection = window.getSelection();\n        if(!selection || !selection.rangeCount) return;\n        let f = selection.getRangeAt(0);\n        if(!f || f.startOffset !== f.endOffset && f.startContainer !== f.endContainer) return;\n        return f;\n      })();\n      \n      function summary(element) {\n        var summary = element.tagName.toLowerCase();\n        if(element.getAttribute(\"id\")) {\n          summary += \"#\" + element.getAttribute(\"id\");\n        }\n        if(element.getAttribute(\"class\") && element.getAttribute(\"class\").trim().length) {\n          summary += \".\" + element.getAttribute(\"class\").split(\".\");\n        }\n        return summary;\n      }\n      let addInteractionDivButton = function(innerHTML, attributes, properties) {\n        let button = el(\"div\", attributes, [], properties);\n        button.classList.add(\"modify-menu-button\");\n        button.innerHTML = innerHTML;\n        interactionDiv.append(button);\n      }\n      interactionDiv.innerHTML = \"\";\n      var panelOpenCloseIcon = function() {\n        return document.querySelector(\"#modify-menu\").classList.contains(\"visible\") ?\n            onMobile() ? closeBottomSVG : closeRightSVG\n          : onMobile() ? openTopSVG : openLeftSVG;\n      }\n      addInteractionDivButton(\n        panelOpenCloseIcon(),\n        {title: \"Open/close settings tab\", \"class\": \"inert\", style: \"position: absolute;\" +\n          (onMobile() ? \"top:-\"+buttonHeight()+\"px;\" : \"left:-\"+buttonWidth()+\"px;\") },\n        {onclick: (contextMenu => function(event) {\n            document.querySelector(\"#modify-menu\").classList.toggle(\"visible\");\n            this.innerHTML = panelOpenCloseIcon();\n          })(contextMenu)\n        });\n      addInteractionDivButton(\n        gearSVG,\n        {title: \"Advanced\", \"class\": \"inert\" + (editor_model.advanced ? \" active\": \"\"),\n         style: \"position: absolute;\" +\n            (onMobile() ? \"top:-\"+buttonHeight()+\"px;left:\"+buttonWidth()+\"px\" :\n                          \"left:-\"+buttonWidth()+\"px;top:\"+buttonHeight()+\"px\")\n        },\n        {onclick: (c => function(event) {\n          editor_model.advanced = !editor_model.advanced;\n            document.querySelector(\"#modify-menu\").classList.toggle(\"visible\", true);\n          updateInteractionDiv();\n        })(clickedElem)}\n      )\n      addInteractionDivButton(saveSVG,\n      {title: \"Save\", \"class\": \"saveButton\" + (editor_model.canSave ? \"\" : \" disabled\"),\n          style: \"position: absolute;\" +\n          (onMobile() ? \"top:-\"+buttonHeight()+\"px;left:\"+2*buttonWidth()+\"px\" :\n                        \"left:-\"+buttonWidth()+\"px;top:\"+2*buttonHeight()+\"px\")\n      },\n        {onclick: function(event) {\n            if(!this.classList.contains(\"disabled\")) {\n              sendModificationsToServer();\n            }\n          }\n        }\n      )\n      if(model.advanced) {\n        // TODO: Ambiguity interaction (should be stored in the model)\n        // TODO: Current URL (can be changed) + reload button (double circular arrow) + list files button (folder icon)\n        // TODO: Stage/create draft (clone and save icon)\n        // TODO: Source code (expandable - can use Ace Editor)\n        // TODO: Options: Ask questions, Autosave.\n        // TODO: Report issue. About.\n        addInteractionDivButton(\"src\",\n          {\"class\": \"tagName\", title: model.displaySource ? \"Hide source\" : \"Show Source\"},\n            {onclick: function(event) { editor_model.displaySource = !editor_model.displaySource; updateInteractionDiv() } }\n        );\n        addInteractionDivButton(\"reload\",\n          {\"class\": \"tagName\", title: \"Reload the current page\"},\n            {onclick: function(event) { reloadPage() } }\n        );\n        if(model.displaySource) {\n          let source = document.querySelector(\"#modify-menu\").getAttribute(\"sourcecontent\");\n          interactionDiv.append(el(\"div\", {\"class\": \"tagName\"},\n             [el(\"textarea\",\n                  {style: \"width:100%; height: 100%\",\n                   id: \"sourcecontentmodifier\", placeholder: \"Source of the page, before evaluation\", \"class\": \"templateengine\"}, [], {\n                onkeyup: function() {\n                  if(document.querySelector(\"#modify-menu\").getAttribute('sourcecontent') !== this.value)\n                    document.querySelector(\"#modify-menu\").setAttribute('sourcecontent', this.value);\n                  },\n                value: source\n               })]));\n        }\n        return;\n      }\n      if(model.insertElement) {\n        interactionDiv.append(el(\"h1\", {}, \"Insert\"));\n        interactionDiv.append(el(\"div\", {id: \"insertionPlace\"}, [\n          clickedElem.tagName === \"BODY\" || clickedElem.tagName === \"HTML\" || clickedElem.tagName === \"HEAD\" ? undefined :\n          el(\"span\", {}, [\n            el(\"input\", {type: \"radio\", id: \"radioInsertBeforeNode\", name: \"insertionPlace\", value: \"before\"}),\n            el(\"label\", {\"for\": \"radioInsertBeforeNode\"}, \"Before node\")]),\n          clickedElem.tagName === \"HTML\" ? undefined :\n          el(\"span\", {}, [\n            el(\"input\", {type: \"radio\", id: \"radioInsertAtCaret\", name: \"insertionPlace\", value: \"caret\"}),\n            el(\"label\", {\"for\": \"radioInsertAtCaret\"}, caretPosition ? \"At caret\" : \"As child\")]),\n          clickedElem.tagName === \"BODY\" || clickedElem.tagName === \"HTML\" || clickedElem.tagName === \"HEAD\" ? undefined :\n          el(\"span\", {}, [\n            el(\"input\", {type: \"radio\", id: \"radioInsertAfterNode\", name: \"insertionPlace\", value: \"after\"}, [], {checked: true}),\n            el(\"label\", {\"for\": \"radioInsertAfterNode\"}, \"After node\")]),\n        ]));\n        let insertTag = function() {\n          let newElement = (() => {\n            let parent = this;\n            while(parent && !parent.classList.contains(\"tagName\")) parent = parent.parentElement;\n            let m = parent.querySelector(\".templateengine\");\n            if(typeof m.innerHTMLCreate === \"string\") return m.innerHTMLCreate;\n            return el(m.tag, m.attrs, m.children, m.props);\n          })();\n          let insertionStyle = (() => {\n            let radios = document.querySelectorAll('#insertionPlace input[name=insertionPlace]');\n            let defaultValue = \"after\";\n            for (let i = 0, length = radios.length; i < length; i++) {\n              if (radios[i].checked) return radios[i].getAttribute(\"value\");\n              defaultValue = radios[i].getAttribute(\"value\")\n            }\n            return defaultValue;\n          })();\n          if(insertionStyle === \"after\") {\n            if(typeof newElement === \"string\") {\n              clickedElem.insertAdjacentHTML(\"afterend\", newElement);\n            } else {\n              clickedElem.parentElement.insertBefore(newElement, clickedElem.nextSibling);\n            }\n          } else if(insertionStyle === \"before\") {\n            if(typeof newElement === \"string\") {\n              clickedElem.insertAdjacentHTML(\"beforebegin\", newElement);\n            } else {\n              clickedElem.parentElement.insertBefore(newElement, clickedElem);\n            }\n          } else if(typeof model.caretPosition !== \"undefined\") {\n            let s = model.caretPosition;\n            let txt = s.startContainer;\n            if(txt.textContent.length > s.startOffset && s.startOffset > 0) { // split\n              // Need to split the text node.\n              txt.parentElement.insertBefore(document.createTextNode(txt.textContent.substring(s.startOffset)), txt.nextSibling);\n              txt.textContent = txt.textContent.substring(0, s.startOffset);\n            }\n            if(typeof newElement === \"string\") {\n              let tmpSpan = el(\"span\");\n              clickedElem.insertBefore(tmpSpan, txt.nextSibling)\n              tmpSpan.insertAdjacentHTML(\"afterend\", newElement);\n              tmpSpan.remove();\n            } else {\n              clickedElem.insertBefore(newElement, txt.nextSibling)\n            }\n          } else { // Insert at the end of the selected element, inside.\n            if(typeof newElement === \"string\") {\n              // TODO: append at the element.\n              let tmpSpan = el(\"span\");\n              clickedElem.insertBefore(tmpSpan, null);\n              tmpSpan.insertAdjacentHTML(\"afterend\", newElement);\n              tmpSpan.remove();\n            } else {\n              // Insert at the end.\n              clickedElem.insertBefore(newElement, null);\n            }\n          }\n          if(typeof newElement !== \"string\") {\n            editor_model.clickedElem = newElement;\n            updateInteractionDiv();\n          } else {\n            editor_model.clickedElem = clickedElem;\n            updateInteractionDiv();\n          }\n        }\n        let addElem = function(name, createParams) {\n          interactionDiv.append(el(\"div\", {\"class\": \"tagName\"},\n            el(\"span\", { \"class\": \"templateengine\"}, name, createParams), {onclick: insertTag}));\n        }\n        if(clickedElem.tagName === \"HEAD\") {\n          addElem(\"Title\", {tag:\"title\", children: \"Page_title\"});\n          addElem(\"Style\", {tag:\"style\", children: \"/*Your CSS there*/\"});\n          addElem(\"Script\", {tag:\"script\", children: \"/*Your CSS below*/\"});\n        } else {\n          interactionDiv.append(el(\"input\", {\"type\": \"file\", multiple: \"\", value: \"Images or files...\"}, [], {\n            onchange: function(evt) { uploadFilesAtCursor(evt.target.files); }}));\n          // TODO: Filter and sort which one we can add\n          addElem(\"List item\", {tag:\"li\", props: { innerHTML: \"<br>\"}});\n          addElem(\"New bulleted list\", {tag:\"ul\", props: { innerHTML: \"<ul>\\n  <li><br></li>\\n</ul>\"}});\n          addElem(\"New numbered list\", {tag:\"ol\", props: { innerHTML: \"<ol>\\n  <li><br></li>\\n</ol>\"}});\n          addElem(\"Link\", {tag:\"a\", childCreate: \"Name_your_link\"});\n          addElem(\"Paragraph\", {tag:\"p\", childCreate: \"Inserted paragraph\"});\n          for(let i = 1; i <= 6; i++) {\n            addElem(\"Header \" + i, {tag:\"h\" + i, props: { innerHTML: \"Title\" + i}});\n          }\n        }\n        interactionDiv.append(el(\"div\", {\"class\": \"tagName\"},\n           [el(\"textarea\", {id: \"customHTMLToInsert\", placeholder: \"Custom HTML here...\", \"class\": \"templateengine\", onkeyup: \"this.innerHTMLCreate = this.value\"}),\n           el(\"div\", {\"class\":\"modify-menu-icon\", title: \"Insert HTML\", style: \"display: inline-block\"}, [], {\n              innerHTML: plusSVG,\n              onclick: insertTag\n            })]));\n        document.querySelector(\"#modify-menu\").classList.toggle(\"visible\", true);\n        return;\n      }\n      if(clickedElem && clickedElem.parentElement) {\n        let parent = selectionRange ? clickedElem : clickedElem.parentElement;\n        if(parent.tagName === \"TBODY\" && parent.parentElement && parent.parentElement.tagName === \"TABLE\") parent = parent.parentElement;\n        addInteractionDivButton(`<svg class=\"context-menu-icon\" width=\"40\" height=\"30\">\n            <path d=\"M 8,19 8,22 11,22 M 12,18 8,22 M 8,10 8,7 11,7 M 12,10 8,7 M 27,7 30,7 30,10 M 26,10 30,7 M 31,19 31,22 28,22 M 26,18 31,22 M 12,12 12,10 M 12,16 12,14 M 14,18 12,18 M 18,18 16,18 M 22,18 20,18 M 26,18 24,18 M 26,14 26,16 M 26,10 26,12 M 22,10 24,10 M 18,10 20,10 M 14,10 16,10 M 5,5 35,5 35,25 5,25 Z\"/></svg>`,\n              {title: \"Select parent (\" + summary(parent) + \")\", \"class\": \"inert\"},\n              {onclick: ((c, parent) => event => {\n                editor_model.clickedElem = parent;\n                editor_model.notextselection = true;\n                updateInteractionDiv()\n                })(clickedElem, parent),\n               onmouseenter() { parent.setAttribute(\"ghost-hovered\", \"true\") },\n               onmouseleave() { parent.removeAttribute(\"ghost-hovered\") }\n              }\n            );\n      }\n      if(!selectionRange && clickedElem && clickedElem.previousElementSibling) {\n        addInteractionDivButton(`<svg class=\"context-menu-icon fill\" width=\"40\" height=\"30\">\n          <path d=\"m 10,14 3,3 4,-4 0,14 6,0 0,-14 4,4 3,-3 L 20,4 Z\"/></svg>`,\n        {title: \"Select previous sibling (\" + summary(clickedElem.previousElementSibling) + \")\", class: \"inert\"},\n        {onclick: ((c, contextMenu) => (event) => {\n            editor_model.clickedElem = c.previousElementSibling;\n            editor_model.notextselection = true;\n            updateInteractionDiv();\n          })(clickedElem, contextMenu),\n         onmouseenter() { clickedElem.previousElementSibling.setAttribute(\"ghost-hovered\", \"true\") },\n         onmouseleave() { clickedElem.previousElementSibling.removeAttribute(\"ghost-hovered\") }\n        });\n      }\n      if(!selectionRange && clickedElem && clickedElem.nextElementSibling) {\n        addInteractionDivButton(`<svg class=\"context-menu-icon fill\" width=\"40\" height=\"30\">\n          <path d=\"m 10,17 3,-3 4,4 0,-14 6,0 0,14 4,-4 3,3 -10,10 z\"/></svg>`,\n        {title: \"Select next sibling (\" + summary(clickedElem.nextElementSibling) + \")\", class: \"inert\"},\n        {onclick: ((c, contextMenu) => (event) => {\n            editor_model.clickedElem = c.nextElementSibling;\n            editor_model.notextselection = true;\n            updateInteractionDiv();\n          })(clickedElem, contextMenu),\n         onmouseenter() { clickedElem.nextElementSibling.setAttribute(\"ghost-hovered\", \"true\") },\n         onmouseleave() { clickedElem.nextElementSibling.removeAttribute(\"ghost-hovered\") }\n        });\n      }\n      if(!selectionRange && clickedElem && clickedElem.children && clickedElem.children.length > 0) {\n        addInteractionDivButton(`<svg class=\"context-menu-icon\" width=\"40\" height=\"30\">\n            <path d=\"M 28,22 27,19 30,19 M 33,23 27,19 M 8,20 11,19 11,22 M 7,24 11,19 M 10,6 11,9 8,10 M 28,6 27,9 30,10 M 33,6 27,9 M 6,6 11,9 M 5,15 5,10 M 5,25 5,20 M 15,25 10,25 M 25,25 20,25 M 35,25 30,25 M 35,15 35,20 M 35,5 35,10 M 25,5 30,5 M 15,5 20,5 M 5,5 10,5 M 12,10 26,10 26,18 12,18 Z\"/></svg>`,\n              {title: \"Select first child (\" + summary(clickedElem.children[0]) + \")\", \"class\": \"inert\"},\n              {onclick: (c => event => {\n                let firstChild = c.children[0];\n                if(firstChild.tagName === \"TBODY\" && firstChild.children && firstChild.children.length > 0) firstChild = firstChild.children[0];\n                editor_model.clickedElem = firstChild;\n                editor_model.notextselection = true;\n                updateInteractionDiv()})(clickedElem),\n               onmouseenter() { clickedElem.children[0].setAttribute(\"ghost-hovered\", \"true\") },\n               onmouseleave() { clickedElem.children[0].removeAttribute(\"ghost-hovered\") }\n               }\n            );\n      }\n      interactionDiv.append(el(\"br\"));\n      if(clickedElem) {\n        interactionDiv.append(\n          el(\"input\", {\"id\":\"newTagName\", \"class\": \"inline-input\", \"type\":\"text\", value: clickedElem.tagName.toLowerCase(), title:\"This element's tag name\"}, [], { onkeyup() {\n            document.querySelector(\"#applyNewTagName\").classList.toggle(\"visible\", this.value !== this.getAttribute(\"value\") && this.value.match(/^\\w+$/));\n          }}));\n      }\n      interactionDiv.append(el(\"input\", {\"type\": \"button\", id: \"applyNewTagName\", value: \"Apply new tag name\"}, [], {onclick() {\n            let newel = el(document.querySelector(\"#newTagName\").value);\n            let elements = clickedElem.childNodes;\n            while(elements.length) {\n              newel.append(elements[0]);\n            }\n            for(let i = 0; i < clickedElem.attributes.length; i++) {\n              newel.setAttribute(clickedElem.attributes[i].name, clickedElem.attributes[i].value);\n            }\n            clickedElem.parentElement.insertBefore(newel, clickedElem);\n            clickedElem.remove();\n            editor_model.clickedElem = newel;\n            updateInteractionDiv();\n          }}));\n      let keyvalues = el(\"div\", {\"class\":\"keyvalues\"});\n      for(let i = 0; clickedElem && clickedElem.attributes && i < clickedElem.attributes.length; i++) {\n        let name = clickedElem.attributes[i].name;\n        if(name === \"ghost-clicked\" || name === \"ghost-hovered\") continue;\n        let value = clickedElem.attributes[i].value;\n        if(false /*name == \"style\"*/) {\n          // Do something special for styles.\n        } else {\n          let isHref = name === \"href\" && clickedElem.tagName === \"A\";\n          keyvalues.append(\n            el(\"div\", {\"class\": \"keyvalue\"}, [\n              el(\"span\", {title: \"This element has attribute name '\" + name + \"'\"}, name + \": \"),\n              el(\"span\", {},\n                el(\"input\", {\"type\": \"text\", value: value},\n                  [], {\n                    onkeyup: ((name, isHref) => function () {\n                        clickedElem.setAttribute(name, this.value);\n                        if(isHref) {\n                          let livelinks = document.querySelectorAll(\".livelink\");\n                          for(let livelink of livelinks) {\n                            let finalLink = livelink.matches(\"#context-menu *\") ?\n                              `javascript:navigateLocal('${linkToEdit(this.value)}')` : this.value;\n                            livelink.setAttribute(\"href\", finalLink);\n                            livelink.setAttribute(\"title\", \"Go to \" + this.value);\n                          }\n                        }\n                      })(name, isHref)\n                  })\n              ),\n              isHref ? el(\"span\", {title: \"Go to \" + model.link, \"class\": \"modify-menu-icon inert\"}, [],\n                        {innerHTML: liveLinkSVG(model.link)}): undefined,\n              el(\"div\", {\"class\":\"modify-menu-icon\", title: \"Delete attribute '\" + name + \"'\"}, [], {\n                innerHTML: wasteBasketSVG,\n                onclick: ((name) => function() {\n                  clickedElem.removeAttribute(name);\n                  editor_model.clickedElem = clickedElem;\n                  updateInteractionDiv();\n                })(name)\n              })\n              ]\n            ));\n        }\n      }\n      let highlightsubmit = function() {\n        let attrName = this.parentElement.parentElement.querySelector(\"[name=name]\").value;\n        this.parentElement.parentElement.querySelector(\"button\").disabled =\n          attrName === \"\" || attrName.trim() !== attrName\n      }\n      if(clickedElem && clickedElem.nodeType === 1) {\n        //      interactionDiv.append(el(\"div\", {}, \"Add an attribute:\"));\n        keyvalues.append(\n          el(\"div\", {\"class\": \"keyvalue keyvalueadder\"}, [\n             el(\"span\", {}, el(\"input\", {\"type\": \"text\", placeholder: \"key\", value: \"\", name:\"name\"}, [], {onkeyup: highlightsubmit})),\n             el(\"span\", {}, el(\"input\", {\"type\": \"text\", placeholder: \"value\", value: \"\", name:\"value\"}, [], {onkeyup: highlightsubmit})),\n             el(\"div\", {\"class\":\"modify-menu-icon\", title: \"Add this name/value attribute\"}, [], {innerHTML: plusSVG,\n               disabled: true,\n               onclick() {\n                 clickedElem.setAttribute(\n                   this.parentElement.querySelector(\"[name=name]\").value,\n                   this.parentElement.querySelector(\"[name=value]\").value);\n                 editor_model.clickedElem = clickedElem;\n                 updateInteractionDiv();\n             }})]));\n      }\n      interactionDiv.append(keyvalues);\n      //interactionDiv.append(el(\"hr\"));\n\n      if(clickedElem && (clickedElem.tagName === \"SCRIPT\" || clickedElem.tagName === \"STYLE\" || clickedElem.tagName === \"TITLE\")) {\n        interactionDiv.append(el(\"hr\"));\n        interactionDiv.append(el(\"textarea\", {style: \"width:100%; height:50%\"},\n                [], {\n                  value: clickedElem.childNodes[0].textContent,\n                  onkeyup: function () { clickedElem.childNodes[0].textContent = this.value; }\n                }));\n      }\n      \n      // What to put in context menu?\n      contextMenu.innerHTML = \"\";\n      let numButtons = 0;\n      let addContextMenuButton = function(innerHTML, attributes, properties) {\n        let button = el(\"div\", attributes, [], properties);\n        button.classList.add(\"context-menu-button\");\n        button.innerHTML = innerHTML;\n        contextMenu.append(button);\n        numButtons++;\n      }\n      let reorderCompatible = (node1, node2) => {\n        let topLevelOrderableTags = {TABLE:1, P:1, LI:1, UL:1, OL:1, H1:1, H2:1, H3:1, H4:1, H5:1, H6:1, DIV:1};\n        return node1.tagName === node2.tagName && node1.tagName !== \"TD\" && node1.tagName !== \"TH\" ||\n          topLevelOrderableTags[node1.tagName] && topLevelOrderableTags[node2.tagName]\n          ; \n      }\n      if(model.link) {\n        addContextMenuButton(liveLinkSVG(linkToEdit(model.link)),\n          {title: \"Go to \" + model.link, \"class\": \"inert\"});\n      }\n      if(!selectionRange && clickedElem && clickedElem.previousElementSibling && reorderCompatible(clickedElem.previousElementSibling, clickedElem)) {\n        addContextMenuButton(`<svg class=\"context-menu-icon fill\" width=\"40\" height=\"30\">\n          <path d=\"m 10,14 3,3 4,-4 0,14 6,0 0,-14 4,4 3,-3 L 20,4 Z\"/></svg>`,\n        {title: \"Move selected element up\"},\n        {onclick: ((c, contextMenu) => (event) => {\n            let wsTxtNode = c.previousSibling && c.previousSibling.nodeType == 3 &&\n               c.previousSibling.textContent.trim() === \"\" ? c.previousSibling : undefined;\n            // There is whitespace before this element, we try to reinsert\n            c.parentElement.insertBefore(c, c.previousElementSibling);\n            if(wsTxtNode) { // We move the whitespace as well.\n              c.parentElement.insertBefore(wsTxtNode, c.previousElementSibling);\n            }\n            editor_model.clickedElem = c;\n            updateInteractionDiv();\n          })(clickedElem, contextMenu)\n        });\n      }\n      if(!selectionRange && clickedElem && clickedElem.nextElementSibling && reorderCompatible(clickedElem, clickedElem.nextElementSibling)) {\n        addContextMenuButton(`<svg class=\"context-menu-icon fill\" width=\"40\" height=\"30\">\n          <path d=\"m 10,17 3,-3 4,4 0,-14 6,0 0,14 4,-4 3,3 -10,10 z\"/></svg>`,\n        {title: \"Move selected element down\"},\n        {onclick: ((c, contextMenu) => (event) => {\n            let wsTxtNode = c.nextSibling && c.nextSibling.nodeType == 3 &&\n              c.nextSibling.textContent.trim() === \"\" ? c.nextSibling : undefined;\n            let nodeToInsertAfter = c.nextElementSibling;\n            nodeToInsertAfter.insertAdjacentElement(\"afterend\", c);\n            if(wsTxtNode) { // We move the whitespace as well\n              nodeToInsertAfter.parentElement.insertBefore(wsTxtNode, nodeToInsertAfter.nextSibling);\n            }\n            editor_model.clickedElem = c;\n            updateInteractionDiv();\n          })(clickedElem, contextMenu)\n        });\n      }\n      if(!selectionRange && clickedElem && clickedElem.tagName !== \"HTML\" && clickedElem.tagName !== \"BODY\" && clickedElem.tagName !== \"HEAD\") {\n        addContextMenuButton(`<svg class=\"context-menu-icon\" width=\"40\" height=\"30\">\n            <path d=\"m 11,4 12,0 0,4 -4,0 0,14 -8,0 z\" />\n            <path d=\"m 19,8 12,0 0,18 -12,0 z\" /></svg>`,\n          {title: \"Clone selected element\"},\n          {onclick: ((c, contextMenu) => (event) => {\n              c.removeAttribute(\"ghost-clicked\");\n              let cloned = duplicate(c);\n              if(cloned) {\n                editor_model.clickedElem = cloned;\n                updateInteractionDiv();\n              } else contextMenu.classList.remove(\"visible\");\n            })(clickedElem, contextMenu)\n          });\n        addContextMenuButton(wasteBasketSVG,\n          {title: \"Delete selected element\"},\n          {onclick: ((c, contextMenu) => (event) => {\n              c.remove();\n              contextMenu.classList.remove(\"visible\");\n            })(clickedElem, contextMenu)\n          });\n      }\n      if(selectionRange && (selectionRange.startContainer === selectionRange.endContainer || selectionRange.startContainer.parentElement === selectionRange.commonAncestorContainer && selectionRange.endContainer.parentElement === selectionRange.commonAncestorContainer)) {\n        // There should be different ways to wrap the selection:\n        // a href, span, div.\n        addContextMenuButton(plusSVG,\n            {title: \"Wrap selection\"},\n            {onclick: (s => event => {\n              let elements = [];\n              let tmp = s.startContainer;\n              let nodeToInsertAfter = s.startContainer;\n              let parent = nodeToInsertAfter.parentElement;\n              while(tmp && tmp !== s.endContainer.nextSibling) {\n                if(tmp.nodeType === 3) {\n                  elements.push(tmp === s.startContainer ? tmp === s.endContainer ? tmp.textContent.substring(s.startOffset, s.endOffset) : tmp.textContent.substring(s.startOffset) :\n                    tmp === s.endContainer ? tmp.textContent.substring(0, s.endOffset) :\n                    tmp.textContent);\n                  if(tmp === s.startContainer) {\n                    if(tmp === s.endContainer && tmp.textContent.length > s.endOffset) {\n                      // Need to split the text node.\n                      tmp.parentElement.insertBefore(document.createTextNode(tmp.textContent.substring(s.endOffset)), tmp.nextSibling);\n                    }\n                    if(s.startOffset === 0) {\n                      nodeToInsertAfter = nodeToInsertAfter.previousSibling;\n                      tmp.remove();\n                    } else {\n                      tmp.textContent = tmp.textContent.substring(0, s.startOffset);\n                    }\n                  } else if(tmp === s.endContainer) {\n                    if(s.endOffset === s.endContainer.textContent.length) {\n                      tmp.remove();\n                    } else {\n                      tmp.textContent = tmp.textContent.substring(s.endOffset);\n                    }\n                  } else {\n                    tmp.remove();\n                  }\n                } else {\n                  elements.push(tmp);\n                  tmp.remove();\n                }\n                tmp = tmp.nextSibling;\n              }\n              let insertedNode = el(\"span\", {\"ghost-clicked\": \"true\"});\n              for(let k of elements) {\n                insertedNode.append(k);\n              }\n              let nodeToInsertBefore = nodeToInsertAfter ? nodeToInsertAfter.nextSibling : parent.childNodes[0];\n              parent.insertBefore(insertedNode, nodeToInsertBefore);\n              document.querySelector(\"#modify-menu\").classList.toggle(\"visible\", true);\n              editor_model.clickedElem = insertedNode;\n              updateInteractionDiv();\n            })(selectionRange)}\n            )\n      }\n      if(!selectionRange) {\n        addContextMenuButton(plusSVG,\n            {title: \"Insert element\", contenteditable: false},\n            {onclick: (caretPosition => event => {\n              editor_model.clickedElem = clickedElem;\n              editor_model.insertElement = true;\n              editor_model.caretPosition = caretPosition;\n              updateInteractionDiv();\n              var sel = window.getSelection();\n              sel.removeAllRanges();\n              var range = document.createRange();\n              range.setStart(caretPosition.startContainer, caretPosition.startOffset);\n              range.setEnd(caretPosition.endContainer, caretPosition.endOffset);\n              sel.addRange(range);\n            })(caretPosition)});\n      }\n      \n      let baseElem = clickedElem;\n      while(baseElem && (baseElem.tagName == \"SCRIPT\" || baseElem.tagName == \"STYLE\")) {\n        baseElem = baseElem.nextElementSibling;\n      }\n      baseElem = selectionRange || baseElem || clickedElem;\n      \n      if(baseElem) {\n        let clientRect = baseElem.getBoundingClientRect();\n        // Find out where to place context menu.\n        let clickedElemLeft = window.scrollX + clientRect.left;\n        let clickedElemTop = window.scrollY + clientRect.top;\n        let clickedElemBottom = window.scrollY + clientRect.bottom;\n        let clickedElemRight = window.scrollX + clientRect.right;\n        let desiredWidth = numButtons * buttonWidth();\n        let desiredLeft = (clickedElemLeft + clickedElemRight) / 2 - desiredWidth;\n        if(desiredLeft < clickedElemLeft) desiredLeft = clickedElemLeft;\n        let desiredTop = clickedElemTop - buttonHeight(); \n        if(desiredTop - window.scrollY < 9) {\n          desiredTop = clickedElemBottom;\n          if(desiredTop + buttonHeight() > window.innerHeight) {\n            desiredTop = window.innerHeight - buttonHeight(); \n          }\n        }\n        if(desiredLeft < 0) desiredLeft = 0;\n        if(desiredTop < 0) desiredTop = 0;\n        contextMenu.style.left = desiredLeft + \"px\";\n        contextMenu.style.top = desiredTop + \"px\";\n        contextMenu.style.width = desiredWidth + \"px\";\n        contextMenu.classList.add(\"visible\");\n      }\n      return true;\n    }\n    \n    // Links edition - Might be empty.\n    @(if varedit == False && (listDict.get \"edit\" defaultOptions |> Maybe.withDefault False) == True then\n      -- Special case when ?edit=false but the default behavior is edit=true if nothing is set.\n      \"\"\"document.onclick = function (e) {\n          e = e ||  window.event;\n          var node = e.target || e.srcElement;\n          while(node) {\n            if(node.tagName == \"A\" && node.getAttribute(\"href\") && !node.onclick && !node.getAttribute(\"onclick\")) {\n             var newLocation = addEditEqualToUrl(node.getAttribute(\"href\"), \"false\");\n             console.log(newLocation);\n             window.location.href = newLocation;\n             e.stopPropagation();\n             return false;\n            } else {\n              node = node.parentNode;\n            }\n          }\n        }\"\"\"\n    else if varedit then\n      \"\"\"document.addEventListener('click', onClickOnLink, false);\"\"\"\n    else \"\")\n@(if iscloseable then \"\"\"\nwindow.onbeforeunload = function (e) {\n    e = e || window.event;\n\n    var askConfirmation = document.getElementById(\"manualsync-menuitem\") &&\n         document.getElementById(\"manualsync-menuitem\").getAttribute(\"ghost-disabled\") == \"false\";\n    const confirmation = 'You have unsaved modifications. Do you still want to exit?';\n\n    // For IE and Firefox prior to version 4\n    if (e) {\n      if(askConfirmation) {\n        e.returnValue = confirmation;\n      }\n    }\n    if(askConfirmation) {\n      // For Safari\n      return confirmation;\n    } else {\n      var xmlhttp = new XHRequest();\n      xmlhttp.onreadystatechange = handleServerPOSTResponse(xmlhttp);\n      xmlhttp.open(\"POST\", location.pathname + location.search, false); // Async\n      xmlhttp.setRequestHeader(\"close\", \"true\");\n      xmlhttp.send(\"{\\\"a\\\":1}\");\n    }\n};\n\"\"\" else \"\")\n\"\"\"\n\ngooglesigninbutton = serverOwned \"the google sign-in button\" [\n<style>\na.closeGoogleSignIn {\n  margin-left: 2px;\n  padding-left: 4px;\n  padding-right: 5px;\n}\na.closeGoogleSignIn:hover {\n  background: #AAA;\n  color: white;\n  border-radius: 10px;\n}\n</style>,\n<div class=\"g-signin2\" data-onsuccess=\"onGoogleSignIn\" list-ghost-attributes=\"data-gapiscan data-onload\" children-are-ghosts=\"true\"></div>,\n<script>\nfunction onGoogleSignIn(googleUser) {\n  var profile = googleUser.getBasicProfile();\n  \n  var wasSignedIn = googleAuthIdToken ? true : false;\n  // When set, will be used throughout \n  googleAuthIdToken = googleUser.getAuthResponse().id_token;\n  var addSignout = (name) => {\n    var signin = document.querySelector(\".abcRioButtonContents\").children[1];\n    signin.setAttribute(\"title\", \"Signed in as \" + name);\n    var signout = document.createElement(\"a\");\n    signout.classList.add(\"closeGoogleSignIn\");\n    signout.setAttribute(\"title\", \"Sign out\");\n    signout.innerText = \"x\";\n    signout.onclick = () => {\n      var auth2 = gapi.auth2.getAuthInstance();\n      auth2.signOut().then(() => {\n        auth2.disconnect();\n        googleAuthIdToken = undefined;\n        console.log('User signed out.');\n      });\n    }\n    signin.append(signout);\n  }\n  addSignout(profile.getName());\n  if(!wasSignedIn) { // Necessary to ensure that we don't reload the page the second time it is loaded.\n    reloadPage();\n  }\n}\n</script>,\n<script id=\"googlesigninscript\" src=\"https://apis.google.com/js/platform.js\" async defer save-ghost-attributes=\"gapi_processed\"></script>\n]\n\ndefaultMarkdowncss = \"\"\"img {\n  max-width: 100%;\n}\npre {\n  padding: 10px 0 10px 30px;\n  color: cornflowerblue;\n}\na {\n  text-decoration: none;\n  font-weight: bold;\n  color: #0268cd;\n}\np {\n  margin: 1.0em 0 1.0em 0;\n}\nbody {\n  text-align: justify;\n  font-family: Geneva, Verdana, sans-serif;\n  line-height: 1.75em;\n  background-color: #C9CFCD;\n}\nh1, h2, h3, h4 {\n  letter-spacing: -1px;\n  font-weight: normal;\n  color: #171717;\n}\nh2 {\n\tfont-size: 2.25em;\n}\nh3 {\n  padding: 25px 0 0 0;\n\tfont-size: 1.75em;\n}\nh4 {\n\tfont-size: 1.25em;\n  margin-top: 1.25em;\n}\n.wrapper {\n  margin-left: auto;\n  margin-right: auto;\n  margin-top: 10px;\n  max-width: 900px;\n  padding-left: 20px;\n  padding-right: 20px;\n  padding-top: 20px;\n  background-color: white;\n}\"\"\"\n\nmain";

const defaultHtAccessFileContent = `if Regex.matchIn """\\.\\.(?:/|\\\\)|(?:/|\\\\)\\.\\.|^\\.\\.$""" path then False else
    not (Regex.matchIn """.*\\.pem""" path)`

function readServerFile() {
  if(fs.existsSync(serverFile)) {
    return fs.readFileSync(serverFile, "utf8");
  } else
    return defaultServerContent;
}

function readHtAccessFile() {
  if(fs.existsSync(htaccessFile)) {
    return fs.readFileSync(htaccessFile, "utf8");
  } else
    return defaultHtAccessFileContent;
}

const sns = require("sketch-n-sketch");

function evaluateToHtml(path, env, serverFileContent) {
  var result = sns.objEnv.string.evaluate(env)(serverFileContent);
  if(result.ctor == "Ok") {
    var out = sns.valToHTMLSource(result._0)
    if(out.ctor == "Ok") {
      return out;
    } else {
      return { ctor: "Err", _0: "Error while converting the result to HTML source file: " + out._0}
    }
  } else {
    return { ctor: "Err", _0: `Error while interpreting ${path}: ` + result._0}
  }
}

function lazyListToList(ll) {
  var x = [];
  while(sns.lazyList.nonEmpty(ll)) {
    x.push(sns.lazyList.head(ll));
    ll = sns.lazyList.tail(ll);
  }
  return x;
}

cachedSolutions = {
  key: {
     timestamp: 0,
     computed: [["html page", "environment vars", "fileOperations"],
                ["html page 2", "environment vars 2", "fileOperations 2..."]],
     remaining: "false, or a LazyList whose head element is last computed solution. Call getOneSolution(this.path, this.serverFileContent, sns.lazyList.tail(remaining)) on it to get one more solution if it exists",
     path: "The path that is being computed",
     serverFileContent: "The original source file of the server. Maybe be overwritten in fileOperations"
  }
}

// Retrieves the given solution by 1-based index from the set of solutions
// If the solution is the last computed, computes remaining solutions
function getSolutionByNum(solutionSet, num) {
  if(solutionSet.computed.length >= num && num >= 1) {
    if(solutionSet.computed.length == num) { // If we select the last computed solution, we checked if we can compute more solutions.
      if(solutionSet.remaining !== false) {
        console.log("Checking for ambiguity #" + (num + 1));
        var lt = sns.lazyList.tail(solutionSet.remaining);
        var newSolution = getOneSolution(solutionSet.path, solutionSet.serverFileContent, lt);
        if(newSolution === false) {
          console.log("No more ambiguity");
          solutionSet.remaining = false;
        } else {
          console.log("Ambiguity #" + (num + 1) + " found");
          solutionSet.remaining = lt;
          solutionSet.computed.push(newSolution);
        }
      }
    }
    return solutionSet.computed[num - 1];
  } else {
    console.log(`Requested invalid solution number ${num}. Returning the first`)
    return solutionSet.computed[0];
  }
}

function uniqueKey() {
  var potentialkey = +(new Date());
  while(typeof cachedSolutions["" + potentialkey] != "undefined") {
    potentialkey++;
  }
  return "" + potentialkey;
}

function envToVars(env) { return env.vars; }

function getOneSolution(path, serverFileContent, allSolutions) {
  if(sns.lazyList.isEmpty(allSolutions)) return false;
  var {_0: newEnv, _1: newServerFileContent} = sns.lazyList.head(allSolutions);
  if(newServerFileContent != serverFileContent) { // server file itself modified from the update method
    var d =
      sns.process(sns.objEnv.string.evaluate({x: serverFileContent, y: newServerFileContent})(`__diff__ x y`))(sns.valToNative)
    var diffsServerFileContent = 
      d.ctor == "Ok" ? d._0 ? d._0.args ? d._0.args._1 ? d._0.args._1.args ? d._0.args._1.args._1 ? d._0.args._1.args._1 :
        false : false : false : false : false : false;

    newEnv.fileOperations.unshift(
      {"$t_ctor": "Tuple2",
       _1: serverFile,
       _2: {"$d_ctor": "Write",
       args: {_1: serverFileContent, _2: newServerFileContent, _3: diffsServerFileContent}}
       });
  }
  var fo = newEnv.fileOperations;
  var evaluated = evaluateToHtml(path, newEnv, newServerFileContent);
  return [evaluated, envToVars(newEnv), fo]; 
  // Evaluates everything given the temporary context of writing the files.
}

// Apply the given operations to the file system. TODO: Merge different writes to a single file.
function applyOperations(operations) {
  for(var i = 0; i < operations.length; i++) {
    var {_1: path, _2: action} = operations[i];
    if(action["$d_ctor"] == "Write") {
      fs.writeFileSync(path, action.args._2, "utf8");
    } else if(action["$d_ctor"] == "Create") {
      // TODO: Create the path if necessary
      fs.writeFileSync(path, action.args._1, "utf8");
    } else if(action["$d_ctor"] == "Rename") {
      if(path.startsWith("/")) path = path.substring(1);
      var newName = action.args._1;
      if(newName.startsWith("/")) newName = newName.substring(1);
      fs.renameSync(path, newName);
    } else if(action["$d_ctor"] == "Delete") {
      fs.unlinkSync(path);
    } else {
      console.log("unrecognized action:", action);
    }
  }
}

function stringDiffSummary(oldString, newString, stringDiffs) {
  if(stringDiffs["$d_ctor"] == "Nothing") return "";
  if(stringDiffs["$d_ctor"] == "Just") stringDiffs = stringDiffs.args._1;
  var listStringDiffs = stringDiffs.args._1; // It's a VStringDiffs
  var offset = 0;
  var summary = "";
  for(var i = 0; i < listStringDiffs.length; i++) {
    var {args: {_1: start, _2: end, _3: replaced}} = listStringDiffs[i];
    var removed = oldString.substring(start, end);
    var inserted = newString.substring(start + offset, start + offset + replaced);
    var beforeRemoved = oldString.substring(0, start);
    var linesBeforeRemoved = beforeRemoved.split(/\r\n|\r|\n/);
    var lineNumber = linesBeforeRemoved.length;
    var charNumber = linesBeforeRemoved[linesBeforeRemoved.length - 1].length + 1;
    summary += "L" + lineNumber + "C" + charNumber + ", "
    if(removed == "")
      summary += "inserted '" + inserted + "'";
    else if(inserted == "")
      summary += "removed '" + removed + "'";
    else
      summary += "removed '" + removed + "', inserted '"+ inserted +"'";
    offset += replaced - (end - start);
  }
  return summary;
}

function relativePath(filepath) {
  return filepath.substring(path.length);
}

function fileOperationSummary(operations) {
  if(operations == null) return "";
  var summary = "";
  for(var i = 0; i < operations.length; i++) {
    var {_1: filepath, _2: action} = operations[i];
    if(summary != "") summary += "\n";
    if(action["$d_ctor"] == "Write") {
      summary += "Modify " + relativePath(filepath) + ", " + stringDiffSummary(action.args._1, action.args._2, action.args._3);
    } else if(action["$d_ctor"] == "Create") {
      summary += "Created " + relativePath(filepath);
    } else if(action["$d_ctor"] == "Rename") {
      summary += "Renamed " + relativePath(filepath) + " to " + action.args._1;
    } else if(action["$d_ctor"] == "Delete") {
      summary += "Deleted " + relativePath(filepath);
    } else {
      console.log("unrecognized action:", action);
    }
  }
  return summary;
}

// Returns a [Result of string containing the requested page, new overrides]
// If newvalue is defined, performs an update before returning the page.
function loadpage(path, vars, user, newvalue) {
  // __dirname = path.resolve(); // If in the REPL
  if(typeof vars != "object") vars = {};
  var serverFileContent = readServerFile();
  var env = {
      googleClientId: googleClientId,
      vars: vars,
      user: toLeoQuery(user || {}),
      defaultOptions: toLeoQuery(defaultOptions),
      path: path,
      fileOperations: [] };
  
  if(typeof newvalue == "undefined") {
    return [evaluateToHtml(path, env, serverFileContent), vars];
  } else { // We update the page and re-render it.
    var newVal = sns.nativeToVal(newvalue);
    console.log("Started to update...");
    var result = sns.objEnv.string.update(env)(serverFileContent)(newVal);
    console.log("Update finished (first solution)");
    if(result.ctor == "Ok") {
      var allSolutions = result._0;
      // Instead of iterating through all the solutions, just detect if there is an ambiguity.
      var solution = getOneSolution(path, serverFileContent, allSolutions);
      if(solution === false) {
        return [{ctor: "Err", _0: "Empty list of solutions"}];
      } else {
        console.log("Checking for ambiguities");
        var allSolutionsTail = sns.lazyList.tail(allSolutions);
        var solution2 = getOneSolution(path, serverFileContent, allSolutionsTail);
        if(solution2 === false) { // No ambiguity, we can immediately process the change.
          console.log("No ambiguity");
          return solution;
        } else {
          console.log("Ambiguity found");
          var solutionKey = uniqueKey();
          var cachedSolution = {
              timestamp: (+ new Date()),
              computed: [solution, solution2],
              remaining: allSolutionsTail,
              path: path,
              serverFileContent: serverFileContent
          }
          cachedSolutions[solutionKey] = cachedSolution;
          return solution.concat(solutionKey);
        }
      }
    } else return [result];
  }
}

function toLeoQuery(query) {
  var result = [];
  for(key in query) {
    result.push({"$t_ctor": "Tuple2", _1: key, _2: query[key]});
  }
  return result;
}

var willkill = undefined;

var key = fs.existsSync(defaultOptions.key) ? fs.readFileSync(defaultOptions.key) : null;
var cert = fs.existsSync(defaultOptions.cert) ? fs.readFileSync(defaultOptions.cert) : null;
var httpsOptions = { key: key, cert: cert };
var protocol = key && cert ? "https" : "http";
var httpOrHttps = require(protocol);
if(protocol == "http") {
  console.log(`${defaultOptions.key} (--key) and/or ${defaultOptions.cert} (--cert) files missing. Starting http server instead of https.`);
}

function combinePath(prefix, path) {
  return (prefix == "" ? "." : prefix) + "/" + (path && path.length && path[0] === "/" ? path.substring(1) : path);
}

const server = httpOrHttps.createServer(httpsOptions, (request, response) => {
  var requestURL = request.headers["url"] ? request.headers["url"] : request.url; // Possibility to override the URL.
  var urlParts = url.parse(requestURL, parseQueryString=true);
  var query = toLeoQuery(urlParts.query);
  var pn = urlParts.pathname;
  var path = decodeURIComponent(pn.length && pn[0] == "/" ? pn.substring(1) : pn); // Without the slash.
  var accessResult = sns.objEnv.string.evaluate({path:path,method:request.method})(readHtAccessFile());
  var access = sns.process(accessResult)(sns.valToNative);
  var header = 'text/html; charset=utf-8';
  if(access.ctor == "Err") {
    console.log("Error in htaccess", access._0);
    response.setHeader('Content-Type', header);
    response.statusCode = 500;
    response.end(`<html><body style="color:#cc0000"><div   style="max-width:600px;margin-left:auto;margin-right:auto"><h1>htaccess.elm internal Error report</h1><pre style="white-space:pre-wrap">${access._0}</pre></div></body></html>`);
  } else if(access._0) {
    if(typeof willkill != "undefined") {
      clearTimeout(willkill);
      willkill = undefined;
    }
    if(request.method == "GET") {
      var header = path.endsWith(".ico") ? "image/ico" : header;
      var header = path.endsWith(".jpg") ? "image/jpg" : header;
      var header = path.endsWith(".gif") ? "image/gif" : header;
      var header = path.endsWith(".png") ? "image/png" : header;
      var header = path.endsWith(".svg") ? "image/svg+xml" : header;
      var header = path.endsWith(".css") ? "text/css; charset=utf-8" : header;
      if(!header.startsWith("image/") && !header.startsWith("text/css")) {
        var [htmlContent] = loadpage(path, query, undefined);
        response.setHeader('Content-Type', header);
        response.statusCode = 200;
        if(htmlContent.ctor == "Err") {
          response.end(`<html><body style="color:#cc0000"><div   style="max-width:600px;margin-left:auto;margin-right:auto"><h1>Internal Error report</h1><pre style="white-space:pre-wrap">${htmlContent._0}</pre></div></body></html>`);
        } else {
          response.end(htmlContent._0);
        }
      } else {
        response.setHeader('Content-Type', header);
        let expectedFilePath = combinePath(defaultOptions.path, path);
        if(fs.existsSync(expectedFilePath)) {
          var content = fs.readFileSync(expectedFilePath);
          response.statusCode = 200;
          response.end(content);
        } else {
          response.statusCode = 404;
          response.end(`<html>body>${path} not found</body></html>`);
        }
      }
    } else if(request.method == "POST") {
      const chunks = [];
      request.on('data', chunk => chunks.push(chunk));
      request.on('end', function () {
        var allChunks = Buffer.concat(chunks);
        if(defaultOptions.closeable && request.headers["close"]) {
          willkill = setTimeout(() => process.exit(), timeBeforeExit); // Kills the server after 2 seconds if the webpage is not requested.
          response.statusCode = 200;
          response.end('');
          return;
        } else if(request.headers["write-file"]) { // With this and with the correct permissions, we can overwrite any file.
          console.log("going to write file");
          // Just a file that we write on disk.
          var imageType = request.headers["write-file"];
          var imageLocation = combinePath(defaultOptions.path, path);
          console.log("going to write image file to ", imageLocation);
          fs.writeFileSync(imageLocation, allChunks);
          response.statusCode = 201;
          response.end('');
          return;
        }
        
        var continueWithLoading = (userdata) => {
          var canAskQuestion = (request.headers["question"] || urlParts.query["question"] || (defaultOptions.questions ? "true" : "false")) == "true";
          var body =  allChunks.toString();
          var ambiguityKey = request.headers["ambiguity-key"];
          var numberOfSolutionsSoFar = 2; // Only if Ambiguity-Key is set.
          var numSolutionSelected = 1;
          var htmlContent = {ctor:"Err", _0: "Not yet defined"};
          var newQuery = [];
          var fileOperations = [];
          var ambiguitiesSummary = [];
          if(ambiguityKey !== null && typeof ambiguityKey !== "undefined") {
            var selectAmbiguityStr = request.headers["select-ambiguity"];
            if(selectAmbiguityStr != null) {
              numSolutionSelected = JSON.parse(selectAmbiguityStr);
              var solutionSet = cachedSolutions[ambiguityKey];
              if(typeof solutionSet != "undefined") {
                [htmlContent, newQuery, fileOperations] = getSolutionByNum(solutionSet, numSolutionSelected);
                numberOfSolutionsSoFar = solutionSet.computed.length;
                ambiguitiesSummary = solutionSet.computed.map(a => fileOperationSummary(a[2]));
              } else {
                htmlContent = {ctor:"Err", _0: "Solution set not found"};
              }
            } else {
              var acceptAmbiguityStr = request.headers["accept-ambiguity"];
              if(acceptAmbiguityStr != null) {
                var acceptAmbiguity = JSON.parse(acceptAmbiguityStr);
                var solutionSet = cachedSolutions[ambiguityKey];
                [htmlContent, newQuery, fileOperations] = getSolutionByNum(solutionSet, acceptAmbiguity);
                ambiguityKey = undefined;
              } else {
                var cancelAmbiguityStr = request.headers["cancel-ambiguity"];
                if(cancelAmbiguityStr != null) {
                  ambiguityKey = undefined;
                  [htmlContent, newQuery, fileOperations] = loadpage(path, query, userdata);
                  fileOperations = [];
                } else {
                  htmlContent = {ctor:"Err", _0: "Solution set not found."};
                }
              }
            }
          } else if(request.headers["reload"]) {
            [htmlContent, newQuery, fileOperations] = loadpage(path, query, userdata);
          } else {
            var pushedValue = JSON.parse(body);
            [htmlContent, newQuery, fileOperations, ambiguityKey] = loadpage(path, query, userdata, pushedValue);
          }
          response.statusCode = 201;
          response.setHeader('Content-Type', 'text/html; charset=utf-8');
          if(htmlContent.ctor == "Err") {
            response.end(`<html><body style="color:#cc0000"><div   style="max-width:600px;margin-left:auto;margin-right:auto"><h1>Internal Error report</h1><pre style="white-space:pre-wrap">${htmlContent._0}</pre></div></body></html>`)
          } else {
            if(typeof request.headers["url"] === "string") {
              response.setHeader("New-Local-URL", request.headers["url"]);
            }
            response.setHeader('New-Query', JSON.stringify(newQuery));
            if(ambiguityKey != null && typeof ambiguityKey != "undefined" &&
               !path.endsWith(".html") && canAskQuestion &&
               (urlParts.query["edit"] == "true" || (urlParts.query["edit"] == null && defaultOptions.edit))) {
              var solutionSet = cachedSolutions[ambiguityKey];
              var ambiguityEnd = solutionSet.remaining === false;
              ambiguitiesSummary = solutionSet.computed.map(a => fileOperationSummary(a[2]));
              response.setHeader('Ambiguity-Key', ambiguityKey);
              response.setHeader('Ambiguity-Number', JSON.stringify(numberOfSolutionsSoFar));
              response.setHeader('Ambiguity-Selected', JSON.stringify(numSolutionSelected));
              response.setHeader('Ambiguity-Summaries', JSON.stringify(ambiguitiesSummary));
              response.setHeader('Ambiguity-End', ambiguityEnd ? "true" : "false");
            } else {
              if(fileOperations) {
                applyOperations(fileOperations);
                response.setHeader('Operations-Summary', encodeURI(fileOperationSummary(fileOperations)));
              }
            }
            response.end(htmlContent._0);
          }
        }
        
        var token = request.headers["id-token"];
        if(token) {
          const {OAuth2Client} = require('google-auth-library');
          const client = new OAuth2Client(googleClientId);
 
          async function verify() {
            const ticket = await client.verifyIdToken({
                idToken: token,
                audience: googleClientId // Array of client ids if multiple clients access the backend.
            });
            const userdata = ticket.getPayload();
            continueWithLoading(userdata); // Only authenticated users can access their information. Great!
          }
          verify().catch(err => {
            console.log(err);
            continueWithLoading(undefined);            
          });
          return;
        } else {
          continueWithLoading(undefined);
        }
      });
    } else {
      response.statusCode = 400;
      response.end("Unknown method");
    }
  } else {
    response.statusCode = 401;
    response.end(`<html><body style="color:#cc0000"><div   style="max-width:600px;margin-left:auto;margin-right:auto"><h1>Unauthorized access to ${path}</h1></div></body></html>`);
  }
});

port = await getPort({host: hostname, port: [port, 3000, 3001, 3002, 3003, 3004]})

// Load the Elm program into our namespace.
server.listen(port, hostname, () => {
  console.log("Editor Server serving path " + defaultOptions.path);
  if(defaultOptions.edit) {
    console.log("Edit mode:     activated.    (toggle option: 'edit=false')");
  } else {
    console.log("Edit mode:     deactivated.  (toggle option: 'edit=true')");
  }
  if(defaultOptions.autosave) {
    console.log("Autosave mode: activated.    (toggle option: 'autosave=false')");
  } else {
    console.log("Autosave mode: deactivated.  (toggle option: 'autosave=true')");
  }
  if(defaultOptions.question) {
    console.log("Questions:     activated.    (toggle option: 'question=false')");
  } else {
    console.log("Questions:     deactivated.  (toggle option: 'question=true')");
  }
  console.log("To toggle any of these options in the browser, join these toggle options using '&', prefix this with '?', and append the result to any URL, ");
  console.log(`Point your browser at ${protocol}://${hostname}:${port}`);
});

if(fileToOpen) {
  var opn = require('opn');

  // opens the url in the default browser 
  opn(protocol + "://" + hostname + ":" + port + "/" + fileToOpen);
} else if(defaultOptions.openbrowser) {
  var opn = require('opn');

  // opens the url in the default browser 
  opn(protocol + "://" + hostname + ":" + port);
}
} // async declaration of start()

// Never called when starting the server from command-line.
module.exports = function(requireOptions) {
  if(!requireOptions) {
    start();
    return;
  } else {
    for(var k in requireOptions) {
      defaultOptions[k] = requireOptions[k];
    }
    start();
    return;
  }
}


